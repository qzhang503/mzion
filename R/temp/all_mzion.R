#' Helper in binning precursor masses.
#'
#' For target peptides.
#'
#' @param res The results from \link{calc_pepmasses2}.
#' @param min_mass A minimum mass of precursors.
#' @param max_mass A maximum mass of precursors.
#' @inheritParams matchMS
#' @inheritParams load_mgfs
#' @inheritParams calc_pepmasses2
bin_ms1masses <- function (res = NULL, min_mass = 200L, max_mass = 4500L, 
                           min_len = 7L, max_len = 40L, ppm_ms1 = 20L, 
                           use_ms1_cache = TRUE, .path_cache = NULL, 
                           .path_ms1masses = NULL, is_ms1_three_frame = TRUE, 
                           out_path = NULL, enzyme = "trypsin_p") 
{
  old_opts <- options()
  options(warn = 1L)
  on.exit(options(old_opts), add = TRUE)
  
  on.exit(
    if (exists(".savecall", envir = fun_env)) {
      if (.savecall) {
        res <- NULL
        save_call2(path = file.path(.path_cache, "calc_pepmasses2", .time_stamp), 
                   fun = fun, time = .time_bin)
      }
    },
    add = TRUE
  )
  
  ## Initial setups
  fun <- as.character(match.call()[[1]])
  fun_env <- environment()
  
  ppm_ms1_bin <- calc_threeframe_ppm(ppm_ms1)

  # checks pre-existed precursor masses
  .cache_info <- qs::qread(file.path(out_path, "Calls", ".cache_info.rds"))
  .time_stamp <- .cache_info$.time_stamp
  .path_mass  <- file.path(.path_ms1masses, .time_stamp)
  masses <- list.files(path = .path_mass, pattern = paste0("^pepmasses_", "\\d+\\.rds$"))
  
  if (!(len_m  <- length(masses))) 
    stop("File not found: ", 
         file.path(.path_mass, paste0("pepmasses_", "[...].rds")))

  # checks pre-existed, binned precursor masses
  .time_bin <- match_calltime(path = file.path(.path_cache, 
                                               "calc_pepmasses2", 
                                               .time_stamp), 
                              fun = fun,
                              nms = c("min_mass", "max_mass", "min_len", 
                                      "max_len", "ppm_ms1")) 
  
  # already binned
  if ((len_bts <- length(.time_bin)) > 1L) 
    stop("More than one cached results found: \n\n", 
         paste(file.path(.path_ms1masses, .time_stamp, fun), collapse = "\n"), 
         "\n\nDelete the caches and start over.")
  
  if (len_bts && use_ms1_cache) {
    .path_bin <- file.path(.path_ms1masses, .time_stamp, fun, .time_bin)
    .path_bin <- fs::fs_path(.path_bin) # ensure class fs_path for arg matches
    bins <- list.files(path = .path_bin, pattern = "binned_theopeps_\\d+\\.rds$")

    if (length(bins) == len_m) {
      message("Loading bins of MS1 masses from cache.")
      .savecall <- FALSE
      return(.path_bin)
    }
  }
  
  message("Binning MS1 masses...")
  
  .time_bin <- format(Sys.time(), ".%Y-%m-%d_%H%M%S")
  .path_bin <- create_dir(file.path(.path_ms1masses, .time_stamp, fun, .time_bin))
  
  if (is.null(res)) {
    # (b) reload
    idxes <- local({
      idxes <- gsub("^pepmasses_(\\d+)\\.rds$", "\\1", masses)
      idxes <- as.integer(idxes)
      idxes <- idxes[order(idxes)]
    })
    
    n_cores <- set_bin_ncores(len_m, enzyme)

    if (n_cores > 1L) {
      cl <- parallel::makeCluster(getOption("cl.cores", n_cores))
      
      parallel::clusterExport(cl, list("qread", "qsave"), envir = environment(qs::qsave))
      
      parallel::clusterExport(
        cl,
        c("binTheoSeqs_i", 
          "binTheoSeqs2", 
          "bin_theoseqs", 
          "s_readRDS", 
          "find_ms1_cutpoints"), 
        envir = environment(mzion::matchMS))
      
      # No need of flatten() as saveRDS by INDIVIDUAL idx (and return NULL)
      parallel::clusterApplyLB(
        cl = cl, 
        x = chunksplit(idxes, n_cores, "list"), 
        fun = lapply, 
        FUN = "binTheoSeqs_i", 
        min_mass = min_mass, 
        max_mass = max_mass, 
        ppm_ms1 = ppm_ms1_bin, 
        in_path = .path_mass,
        out_path = .path_bin
      )
      
      parallel::stopCluster(cl)
    } 
    else
      lapply(idxes, binTheoSeqs_i, min_mass, max_mass, ppm_ms1_bin, 
             .path_mass, .path_bin)
  }
  else {
    # (a) process directly
    binTheoSeqs(idxes = NULL,
                res = res,
                min_mass = min_mass,
                max_mass = max_mass,
                ppm_ms1 = ppm_ms1_bin,
                enzyme = enzyme, 
                out_path = file.path(.path_bin, "binned_theopeps.rds"))
  }
  
  pat_b <- "^binned_theopeps_[0-9]+\\.rds"
  len_b <- length(list.files(.path_bin, pattern = pat_b))
  
  if (len_b != len_m)
    stop("May need more RAM: expect ", len_m, " \"", pat_b, "\" files, ", 
         "but found ", len_b, " files under \n\"", .path_bin, "\"\n")
  
  .savecall <- TRUE

  local({
    file <- file.path(out_path, "Calls", ".cache_info.rds")
    
    if (file.exists(file))
      .cache_info <- qs::qread(file)

    .cache_info$.time_bin <- .time_bin
    .cache_info$.path_bin <- .path_bin
    
    qs::qsave(.cache_info, file, preset = "fast")
  })
  
  message("Completed precusor bins at: ", Sys.time())
  
  invisible(.path_bin)
}


#' Helper of \link{binTheoSeqs2}.
#' 
#' @param in_path An input path of \code{pepmasses_}.
#' @inheritParams binTheoSeqs2
binTheoSeqs_i <- function (idx = 1L, min_mass = 200L, max_mass = 4500L,
                           ppm_ms1 = 10L, in_path = NULL, out_path = NULL) 
{
  if (is.null(in_path)) 
    stop("`in_path` cannot be NULL.")
  
  message("\tSet: ", idx)
  
  res <- s_readRDS(paste0("pepmasses_", idx, ".rds"), in_path)
  
  binTheoSeqs2(idx = idx,
               res = res,
               min_mass = min_mass,
               max_mass = max_mass,
               ppm_ms1 = ppm_ms1,
               out_path = out_path)
}


#' Separates theoretical peptides into mass groups.
#'
#' @param idx An index, e.g. "1" for \code{pepmasses_1.rds} and "rev_1" for
#'   \code{pepmasses_rev_1.rds}.
#' @inheritParams binTheoSeqs
binTheoSeqs2 <- function (idx = 1L, res = NULL, min_mass = 200L,
                          max_mass = 4500L, ppm_ms1 = 10L, out_path = NULL) 
{
  if (is.null(res)) 
    stop("`res` cannot be NULL.")
  
  if (is.null(out_path)) 
    stop("`out_path` cannot be NULL.")
  
  out_dir <- create_dir(gsub("(^.*/).*$", "\\1", out_path))
  out_nm <- paste0(paste0("binned_theopeps_", idx), ".rds")
  
  res <- attr(res, "data")
  gc()
  
  bin_theoseqs(res, file.path(out_path, out_nm), min_mass, max_mass, ppm_ms1)
  
  rm(list = c("res"))
  gc()
  
  invisible(NULL)
}


#' Separates theoretical peptides into mass groups.
#'
#' @param peps A list of theoretical peptides with masses.
#' @param out_nm A output name with prepending file path.
#' @inheritParams binTheoSeqs
bin_theoseqs <- function (peps = NULL, out_nm = NULL, min_mass = 200L, 
                          max_mass = 4500L, ppm_ms1 = 10L) 
{
  if (!length(peps)) {
    out <- NULL   
    qs::qsave(out, out_nm, preset = "fast")
    return(NULL)
  }

  ps <- find_ms1_cutpoints(min_mass, max_mass, ppm_ms1)
  frames <- findInterval(peps, ps)
  
  out <- data.frame(pep_seq = names(peps),
                    mass = peps,
                    frame = frames, 
                    row.names = NULL)
  
  out <- dplyr::arrange(out, frame, pep_seq)
  out <- split(out, out$frame, drop = FALSE)
  out <- lapply(out, function (x) { x[["frame"]] <- NULL; x })
  qs::qsave(out, out_nm, preset = "fast")

  invisible(NULL)
}


#' Helper of \link{bin_theoseqs}.
#' 
#' @param idxes A set of indexes, e.g. "1" for \code{pepmasses_1.rds} and
#'   "rev_1" for \code{pepmasses_rev_1.rds}.
#' @param res Lists of data containing theoretical peptides and masses from
#'   \link{readRDS}.
#' @param min_mass Numeric; the minimum MS1 mass.
#' @param max_mass Numeric; the maximum MS1 mass.
#' @param ppm_ms1 Numeric; (half of) the error tolerance of MS1 mass in ppm.
#' @param out_path The output path.
#' @param enzyme The assume enzyme activity.
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' # res <- readRDS("~/mzion/dbs/fasta/uniprot/pepmass/uniprot_hs_2020_05_2miss.rds")
#' # theopeps <- mzion:::binTheoSeqs(res)
#' }
#' @return Lists of theoretical peptides binned by MS1 masses. The lists
#'   correspond to the lists of \code{res}.
binTheoSeqs <- function (idxes = NULL, res = NULL, min_mass = 200L,
                         max_mass = 4500L, ppm_ms1 = 10L, enzyme = "trypsin_p", 
                         out_path = NULL) 
{
  if (is.null(res)) 
    stop("`res` cannot be NULL.")
  
  if (is.null(out_path)) 
    stop("`out_path` cannot be NULL.")
  
  if (is.null(idxes)) 
    idxes <- seq_along(res)
  
  out_dir <- create_dir(gsub("(^.*/).*$", "\\1", out_path))
  
  out_nms <- gsub("^.*/(.*)\\.[^\\.].*$", "\\1", out_path)
  out_nms <- paste0(out_nms, "_", idxes, ".rds")
  
  res <- lapply(res, attributes)
  res <- lapply(res, `[[`, "data")
  gc()
  
  n_cores <- set_bin_ncores(length(res), enzyme)
  cl <- parallel::makeCluster(getOption("cl.cores", n_cores))
  parallel::clusterExport(cl, list("qread", "qsave"), 
                          envir = environment(qs::qsave))
  parallel::clusterExport(cl, c("bin_theoseqs", "find_ms1_cutpoints"), 
                          envir = environment(mzion::matchMS))
  
  out <- parallel::clusterMap(cl, bin_theoseqs, 
                              res, file.path(out_dir, out_nms), 
                              MoreArgs = list(min_mass = min_mass, 
                                              max_mass = max_mass, 
                                              ppm_ms1 = ppm_ms1), 
                              SIMPLIFY = FALSE, USE.NAMES = FALSE, 
                              .scheduling = "dynamic")
  parallel::stopCluster(cl)
  rm(list = c("res"))
  gc()
  
  invisible(NULL)
}


#' Finds the cut-points of MS1 masses for binning.
#'
#' The cut-points will be used as the boundary in data binning. Note that the
#' upper bound is open.
#'
#' @param from Numeric; the starting MS1 mass.
#' @param to Numeric; the ending MS1 mass.
#' @param ppm Numeric; the ppm for data binning.
#' @return Cut points.
find_ms1_cutpoints <- function (from = 200L, to = 4500L, ppm = 10L) 
{
  d <- ppm/1e6
  n <- ceiling(log(to/from)/log(1+d))

  x <- vector("numeric", n)
  x[1] <- from

  for (i in seq_len(n-1)) 
    x[i+1] <- x[i] * (1 + d)

  x
}


#' Helper.
#'
#' Reads single rds.
#'
#' @param file A file name.
#' @param out_path An output path.
s_readRDS <- function (file, out_path) 
{
  ans <- tryCatch(
    qs::qread(file = file.path(out_path, file)),
    error = function (e) NULL
  )
  
  if (is.null(ans)) 
    stop("Files not found: ", file.path(out_path, file))
  
  ans
}


#' Sets the number of CPU cores for precursor mass binning.
#' 
#' @param len_m The number of \code{aa_masses} modules.
#' @param enzyme The assume enzymatic activity.
set_bin_ncores <- function (len_m, enzyme)
{
  n_cores <- detect_cores(15L)
  
  n_cores <- if (len_m > n_cores) 
    min(floor(n_cores/2L), len_m)
  else 
    min(n_cores, len_m)
  
  if (isTRUE(enzyme == "noenzyme"))
    n_cores <- floor(n_cores/2L)
  
  max(1L, n_cores)
}


#' De-isotopes precursor masses.
#'
#' @param moverzs MS1 or MS2 Mass-to-charge ratios. The inputs are typically at
#'   weighted-mean statistics.
#' @param msxints MS1 or MS2 peak intensities. The inputs are typically at mean
#'   statistics.
#' @param n_ms1s The underlying counts that have contributed to \code{moverzs}
#'   and \code{maxints}.
#' @param center The mass center of an isolation window (only for MS1).
#' @param is_dda Logical; is DDA or not.
#' @param ppm Allowance in mass error when deisotoping.
#' @param offset_upr A cardinal number of upper mass off-sets.
#' @param offset_lwr A cardinal number of lower mass off-sets.
#' @param ms_lev MS level.
#' @param maxn_feats The maximum number of MS features.
#' @param max_charge The maximum charge state.
#' @param n_fwd Forward looking up to \code{n_fwd} mass entries. The default is
#'   20 for MS1 and 10 for MS2.
#' @param step Step size for mass binning.
#' @param order_mz Logical; if TRUE, orders peaks from low to high m-over-z's.
#' @param backward_mass_co A mass cut-off to initiate backward looking of an
#'   isotope envelop.
#' @param fct_iso2 The multiplication factor for the second isotopic peak.
#' @inheritParams matchMS
#' @examples
#' \donttest{
#' moverzs <- c(881 + 1:10*.1, 882.0674, 882.0981, 882.4034, 882.60, 882.7372)
#' msxints <- c(1000 * 1:10, 1652869, 788368, 2043015, 2314111, 4314111)
#' n_ms1s <- rep_len(1L, length(msxints))
#'
#' if (FALSE) {
#'   out <- mzion:::find_ms1stat(moverzs, msxints, n_ms1s, ppm = 5L, ms_lev = 1L,
#'                               maxn_feats = 5L, max_charge = 4L, offset_upr = 8L,
#'                               offset_lwr = 8L, order_mz = TRUE)
#' }
#'
#' moverzs <- c(907.968018,908.136475,908.872711,909.073690,909.121,
#'              909.273670,909.280212,909.45,909.454981,909.459717,
#'              909.473072,909.675781,909.721191,909.78,909.79,
#'              909.791633,909.840088,909.969744,910.077278,910.091888,
#'              910.124076,910.130798,910.180115,910.218689,910.341797,
#'              910.456115,910.463650,910.474152,910.791669,911.126692,
#'              911.133219,911.471605)
#' msxints <- c(2971101,3013171,5774301,24508055,40267873,
#'              1E6,7340374,1E6,154459778,8312258,
#'              18375220,22909676,2863776,1.1E6,1.2E6,
#'              191655971,7273611,32089542,9125108,5008687,
#'              167021373,12912115,3242378,16278636,4731828,
#'              98601412,22828501,10539991,26255569,8499971,
#'              8305187,37899662)
#' n_ms1s <- rep_len(1L, length(msxints))
#'
#' if (FALSE) {
#'   out <- mzion:::find_ms1stat(moverzs, msxints, n_ms1s, center = 909.788696,
#'                       exclude_reporter_region = FALSE,
#'                       ppm = 5L, ms_lev = 1L, maxn_feats = 1L, max_charge = 4L,
#'                       order_mz = TRUE, step = 5/1e6)
#'   out <- mzion:::find_ms1stat(moverzs, msxints, n_ms1s, # center = 909.788696,
#'                       exclude_reporter_region = FALSE,
#'                       ppm = 5L, ms_lev = 1L, maxn_feats = 1L, max_charge = 4L,
#'                       order_mz = TRUE, step = 5/1e6)
#' }
#' }
find_ms1stat <- function (moverzs, msxints, n_ms1s = 1L, center = 0, 
                          exclude_reporter_region = FALSE, 
                          tmt_reporter_lower = 126.1, tmt_reporter_upper = 135.2, 
                          is_dda = TRUE, ppm = 8L, ms_lev = 1L, maxn_feats = 300L, 
                          max_charge = 4L, n_fwd = 20L, offset_upr = 30L, 
                          offset_lwr = 30L, order_mz = TRUE, step = ppm/1e6, 
                          backward_mass_co = 800/ms_lev, grad_isotope = 1.6, 
                          fct_iso2 = 3.0, use_defpeaks = FALSE)
{
  ###
  # if to apply intensity cut-offs, should note the difference intensity 
  # scales between Thermo's and Bruker's data
  ###
  
  null_out <- list(masses = NULL, charges = NULL, intensities = NULL)
  
  if (!(len_ms <- length(moverzs)))
    return(null_out)
  
  excl_rptrs <- exclude_reporter_region && ms_lev != 1L
  
  if (excl_rptrs) {
    if (FALSE) {
      tmts <- c(
        `126` = 126.127726, `127N` = 127.124761, `127C` = 127.131080,
        `128N` = 128.128115, `128C` = 128.134435, `129N` = 129.131470,
        `129C` = 129.137790, `130N` = 130.134825, `130C` = 130.141145,
        `131N` = 131.138180, `131C` = 131.144499, `132N` = 132.141535,
        `132C` = 132.147855, `133N` = 133.14489, `133C` = 133.15121,
        `134N` = 134.148245, `134C` = 134.155114, `135N` = 135.152149)
      
      tmt_lwr <- tmts - tmts * 1e-5
      tmt_upr <- tmts + tmts * 1e-5
      
      ok_rptrs <- mapply(function (x, y, m ) m >= x & m <= y, 
                         tmt_lwr, tmt_upr, MoreArgs = list(moverzs), 
                         SIMPLIFY = FALSE, USE.NAMES = FALSE)
      ok_rptrs <- Reduce(`|`, oks_tmt)
    }
    
    ok_rptrs <- moverzs > tmt_reporter_lower & moverzs < tmt_reporter_upper
    rptr_moverzs <- moverzs[ok_rptrs]
    rptr_ints <- msxints[ok_rptrs]
    
    no_rptrs <- !ok_rptrs
    moverzs <- moverzs[no_rptrs]
    msxints <- msxints[no_rptrs]
    
    len_rptrs <- length(rptr_moverzs)
    len_ms <- len_ms - len_rptrs
    
    if (!len_ms)
      return(null_out)
  }
  
  grad_isotope2 <- fct_iso2 * grad_isotope
  
  from <- moverzs[[1]] - .001
  ims  <- index_mz(moverzs, from, step)
  
  lenp <- min(len_ms, maxn_feats)
  peaks_fuz <- intens_fuz <- peaks <- intens <- rep_len(NA_real_, lenp)
  css_fuz <- css <- rep.int(NA_integer_, lenp)
  p_fuz <- p <- 1L
  ymean_fuz <- ymono_fuz <- mass_fuz <- NA_real_

  while(len_ms & p <= maxn_feats) {
    if (len_ms == 1L) {
      intens[[p]] <- msxints
      peaks[[p]] <- moverzs
      css[[p]] <- 0L
      break
    }
    
    if (center > 0 && p == 1L && ms_lev == 1L) {
      imax <- .Internal(which.min(abs(moverzs - center)))
    } else {
      imax <- .Internal(which.max(msxints))
    }
    
    mass <- moverzs[imax]
    mint <- msxints[imax]
    n_ms1 <- n_ms1s[imax]

    ch <- find_charge_state(
      mass = mass, imax = imax, mint = mint, 
      moverzs = moverzs, msxints = msxints, n_ms1s = n_ms1s, 
      lenm = len_ms, max_charge = max_charge, n_fwd = n_fwd, 
      ms_lev = ms_lev, is_dda = is_dda, ppm = ppm)

    if (ch == 0L) {
      peaks[[p]] <- mass
      intens[[p]] <- mint
      len_ms <- len_ms - 1L
      moverzs <- moverzs[-imax]
      msxints <- msxints[-imax]
      ims <- ims[-imax]
      p <- p + 1L
      next
    }
    
    gap <- 1.003355/ch
    err <- ppm/1e6
    sta1 <- min(len_ms, imax + 1L)
    end1 <- min(len_ms, imax + offset_upr)
    ymono <- msxints[imax]
    
    # additional guard for downstream MS1 peak tracing: 
    #  use ymean (the mean of monoisotopics) 
    #  so it won't overwhelem the real apex value when tracing peaks along LC
    ymean <- ymono/n_ms1

    # find monoisotopic m/z
    if (ch * mass > backward_mass_co) {
      if ((lwr <- imax - offset_lwr) < 1L) lwr <- 1L
      if ((upr <- imax + offset_upr) > len_ms) upr <- len_ms

      iths <- index_mz(mass + gap * (-ch-1L):(1L+ch), from, step)
      iexs <- ims[lwr:upr]
      oks2 <- iexs %fin% iths | (iexs - 1L) %fin% iths | (iexs + 1L) %fin% iths
      hits <- .Internal(which(oks2)) + lwr - 1L
      lenh <- length(hits)
      idx <- .Internal(which(hits == imax))
      
      # only one preceding hit
      if (idx == 2L) {
        hi <- hits[[1]]

        if (abs((moverzs[[hi]] + gap)/mass - 1) <= err) { # not satellite to `mass`
          yhi <- msxints[[hi]]
          ri <- mint/yhi
          
          if (ri <= grad_isotope) { # the preceding intensity pass the 1st threshold
            mass <- moverzs[[hi]]
            ymono <- yhi
            n_ms1 <- n_ms1s[hi]
            ymean <- ymono/n_ms1
          }
          else {
            if (ri <= grad_isotope2) { # the preceding intensity pass the 2nd threshold
              mass_fuz <- moverzs[[hi]]
              ymono_fuz <- yhi
              n_ms1_fuz <- n_ms1s[hi]
              ymean_fuz <- ymono_fuz/n_ms1_fuz
            }
          }
        }
      }
      else if (idx > 2L) { # two or more preceding matches
        ix <- lenx <- idx - 1L
        hx <- NULL
        
        for (i in seq_len(lenx)) {
          mzsub <- moverzs[hits[1:ix]]
          ks <- .Internal(which(abs((mzsub + gap)/mass - 1) <= err))
          
          # all satellite to `mass`
          if (!length(ks))
            break

          hsub <- hits[ks]
          isub <- .Internal(which.max(msxints[hsub]))
          hi <- hsub[isub]
          h <- ks[isub]
          gi <- grad_isotope * i
          yhi <- msxints[[hi]]
          ri <- mint/yhi
          
          if (ri <= gi) { # the preceding intensity pass the 1st threshold
            ymono <- yhi
          }
          else {
            if (ri <= fct_iso2 * gi) { # the preceding pass the 2st threshold
              mass_fuz <- moverzs[[hi]]
              ymono_fuz <- yhi
              ###
              n_ms1_fuz <- n_ms1s[hi]
              ymean_fuz <- ymono_fuz/n_ms1_fuz
              ###
              
              break
            }
            else {
              break
            }
          }

          mass <- moverzs[[hi]]
          hx <- c(hi, hx)
          
          if (h == 1L)
            break
          
          ix <- h - 1L
        }
        
        hits <- c(hx, hits[idx:lenh])
        lenh <- length(hits)
      }
    }
    else {
      iths <- index_mz(mass + gap * 1:ch, from, step)
      iexs <- ims[sta1:end1]
      oks1 <- iexs %fin% iths | (iexs - 1L) %fin% iths | (iexs + 1L) %fin% iths
      hits <- c(imax, .Internal(which(oks1)) + imax)
      lenh <- length(hits)
    }
    
    # intens[[p]] <- ymono
    intens[[p]] <- ymean
    peaks[[p]] <- mass
    css[[p]] <- ch
    
    if (!is.na(mass_fuz)) {
      # intens_fuz[[p_fuz]] <- ymono_fuz
      intens_fuz[[p_fuz]] <- ymean_fuz
      peaks_fuz[[p_fuz]] <- mass_fuz
      css_fuz[[p_fuz]] <- ch
      p_fuz <- p_fuz + 1L
      mass_fuz <- NA_real_
    }
    
    len_ms <- len_ms - lenh
    moverzs <- moverzs[-hits]
    msxints <- msxints[-hits]
    ims <- ims[-hits]
    p <- p + 1L
  }
  
  # outputs
  if (ms_lev == 1L)
    oks1 <- css > 1L & !is.na(css)
  else if (ms_lev == 2L)
    oks1 <- !is.na(peaks)
  else
    stop("Unhandled MS level = ", ms_lev)
  
  masses <- peaks[oks1]
  charges <- css[oks1]
  intensities <- intens[oks1]
  
  if (endf <- p_fuz - 1L) {
    masses <- c(masses, peaks_fuz[1:endf])
    charges <- c(charges, css_fuz[1:endf])
    intensities <- c(intensities, intens_fuz[1:endf])
  }
  
  if (excl_rptrs && len_rptrs) {
    masses <- c(rptr_moverzs, masses)
    charges <- c(rep.int(0L, len_rptrs), charges)
    intensities <- c(rptr_ints, intensities)
  }
  
  if (order_mz) {
    ord <- order(masses)
    masses <- masses[ord]
    charges <- charges[ord]
    intensities <- intensities[ord]
  }
  
  out <- list(masses = masses, charges = charges, intensities = intensities)
}


#' Finds charge state.
#' 
#' @param mass The current mass.
#' @param imax The index of the most intense peak.
#' @param mint The maximum intensity (corresponding to the peak at \code{imax}).
#' @param lenm The length of \code{moverzs}.
#' @inheritParams find_ms1stat 
find_charge_state <- function (mass, imax, mint, moverzs, msxints, n_ms1s, lenm, 
                               max_charge = 4L, n_fwd = 20L, ms_lev = 1L, 
                               is_dda = TRUE, ppm = 8)
{
  # find results for all ch -> uses the best...
  # distinguish left, right or both left and right evidence
  # if left-only evidence -> monomass must < mass

  # stopifnot(max_charge >= 2L, ppm >= 1)
  gaps <- 1.003355/2:max_charge
  err <- ppm/1e6

  sta1 <- min(lenm, imax + 1L)
  sta2 <- max(1L, imax - n_fwd)
  end1 <- min(lenm, imax + n_fwd)
  end2 <- max(1L, imax - 1L)
  xsub1 <- moverzs[sta1:end1]
  xsub2 <- moverzs[sta2:end2]
  ysub1 <- msxints[sta1:end1]
  ysub2 <- msxints[sta2:end2]
  
  # if (ms_lev == 1L) {
  #   nsub1 <- n_ms1s[sta1:end1]
  #   nsub2 <- n_ms1s[sta2:end2]
  # }

  mxs1 <- mass + gaps
  ioks1 <- lapply(mxs1, function (x) .Internal(which(abs(xsub1/x - 1L) <= err)))
  lens1 <- lengths(ioks1)
  chs1 <- .Internal(which(lens1 > 0L))
  l1 <- length(chs1)
  
  # l2 not use in the case
  if (l1 > 1L) {
    p1s <- lapply(ioks1[chs1], function (xs) {
      if (length(xs) == 1L)
        sta1 + xs - 1L
      else {
        ps <- sta1 + xs - 1L
        i <- which.max(msxints[ps])
        sta1 + xs[i] - 1L
      }
    })
    p1s <- .Internal(unlist(p1s, recursive = FALSE, use.names = FALSE))
    
    if (ms_lev == 1L) {
      ansduo <- check_chduo(duo = c(1L, 3L), chs1, p1s, msxints)
      chs1 <- ansduo$chs
      p1s <- ansduo$ps
      
      if (max_charge >= 6L) {
        ansduo <- check_chduo(duo = c(2L, 5L), chs1, p1s, msxints)
        chs1 <- ansduo$chs
        p1s <- ansduo$ps
      }
    }
    
    if (FALSE && ms_lev == 1L) {
      if (length(chs1) > 1L) {
        chx1 <- chs1 + 1L
        unqs <- !as.integer(chx1 * 2L) %in% chx1
        chs1 <- chs1[unqs]
        p1s <- p1s[unqs]
      }
      
      nsubs <- n_ms1s[p1s]
      
      if (max(nsubs) == min(nsubs)) {
        chs1 <- chs1[which.max(msxints[p1s])]
        return(chs1 + 1L)
      }
      
      chs1 <- chs1[which.max(n_ms1s[p1s])]
      return(chs1 + 1L)
    }
    else {
      chs1 <- chs1[which.max(msxints[p1s])]
      return(chs1 + 1L)
    }
  }
  
  mxs2 <- mass - gaps
  ioks2 <- lapply(mxs2, function (x) .Internal(which(abs(xsub2/x - 1L) <= err)))
  lens2 <- lengths(ioks2)
  chs2 <- .Internal(which(lens2 > 0L))
  l2 <- length(chs2)
  
  if (l1 == 1L) {
    if (l2 == 0L) {
      return(chs1 + 1L)
    }
    
    if (l2 == 1L) {
      if (chs1 == chs2) {
        return(chs1 + 1L)
      }
      
      p1 <- sta1 + ioks1[[chs1]] - 1L
      p2 <- sta2 + ioks2[[chs2]] - 1L
      yp1 <- max(msxints[p1])
      yp2 <- max(msxints[p2])
      
      if (ms_lev == 1L && is_dda) {
        np1 <- max(n_ms1s[p1])
        np2 <- max(n_ms1s[p2])
        
        if (np1 == np2) {
          if (yp1 >= yp2) return(chs1 + 1L) else return(chs2 + 1L)
        }
        
        if (np1 > np2) return(chs1 + 1L) else return(chs2 + 1L)
      }
      else {
        if (yp1 >= yp2) return(chs1 + 1L) else return(chs2 + 1L)
      }
    }
    
    # l2 > 1L
    if (any(chs2 %in% chs1)) {
      return(chs1 + 1L)
    }
    
    p1 <- sta1 + ioks1[[chs1]] - 1L
    p2s <- lapply(ioks2[chs2], function (xs) {
      if (length(xs) == 1L)
        sta2 + xs - 1L
      else {
        ps <- sta2 + xs - 1L
        i <- which.max(msxints[ps])
        sta2 + xs[i] - 1L
      }
    })
    p2s <- .Internal(unlist(p2s, recursive = FALSE, use.names = FALSE))
    yp1 <- max(msxints[p1])
    yp2 <- max(msxints[p2s])
    
    if (FALSE & ms_lev == 1L) {
      np1 <- max(n_ms1s[p1])
      np2 <- max(ns2 <- n_ms1s[p2s])
      
      if (np1 == np2) {
        if (yp1 >= yp2) {
          return(chs1 + 1L)
        }
        else {
          chx2 <- chs2 + 1L
          unqs <- !as.integer(chx2 * 2L) %in% chx2
          chs2 <- chs2[unqs]
          p2s <- p2s[unqs]
          chs2 <- chs2[which.max(msxints[p2s])]
          return(chs2 + 1L)
        }
      }
      
      if (np1 > np2) {
        return(chs1 + 1L)
      }
      else {
        chs2 <- chs2[which.max(ns2)]
        return(chs2 + 1L)
      }
    }
    else {
      if (yp1 >= yp2) {
        return(chs1 + 1L)
      }
      else {
        if (ms_lev == 1L) {
          ansduo <- check_chduo(duo = c(1L, 3L), chs2, p2s, msxints)
          chs2 <- ansduo$chs
          p2s <- ansduo$ps
          
          if (max_charge >= 6L) {
            ansduo <- check_chduo(duo = c(2L, 5L), chs2, p2s, msxints)
            chs2 <- ansduo$chs
            p2s <- ansduo$ps
          }
        }
        
        if (FALSE && ms_lev == 1L) {
          if (length(chs2) > 1L) {
            chx2 <- chs2 + 1L
            unqs <- !as.integer(chx2 * 2L) %in% chx2
            chs2 <- chs2[unqs]
            p2s <- p2s[unqs]
          }
          
          nsubs <- n_ms2s[p2s]
          
          if (max(nsubs) == min(nsubs)) {
            chs2 <- chs2[which.max(msxints[p2s])]
            return(chs2 + 1L)
          }
          
          chs2 <- chs2[which.max(n_ms1s[p2s])]
          return(chs2 + 1L)
        }
        else {
          chs2 <- chs2[which.max(msxints[p2s])]
          return(chs2 + 1L)
        }
      }
    }
  }
  
  # z = 1
  # may only needed when min_change >= 2L 
  if (!(l1 || l2)) {
    gap <- 1.003355
    mx1 <- mass + gap
    mx2 <- mass - gap
    iok1 <- .Internal(which(abs(xsub1/mx1 - 1L) <= err))
    iok2 <- .Internal(which(abs(xsub1/mx2 - 1L) <= err))
    len1 <- length(iok1)
    len2 <- length(iok2)
    
    if (len1 || len2) return(1L) else return(0L)
  }

  if (l2 == 1L) { # && l1 == 0
    return(chs2 + 1L)
  }
  
  # l2 > 1 && l1 == 0
  p2s <- lapply(ioks2[chs2], function (xs) {
    if (length(xs) == 1L)
      sta2 + xs - 1L
    else {
      ps <- sta2 + xs - 1L
      i <- which.max(msxints[ps])
      sta2 + xs[i] - 1L
    }
  })
  p2s <- .Internal(unlist(p2s, recursive = FALSE, use.names = FALSE))
  
  if (ms_lev == 1L) {
    ansduo <- check_chduo(duo = c(1L, 3L), chs2, p2s, msxints)
    chs2 <- ansduo$chs
    p2s <- ansduo$ps
    
    if (max_charge >= 6L) {
      ansduo <- check_chduo(duo = c(2L, 5L), chs2, p2s, msxints)
      chs2 <- ansduo$chs
      p2s <- ansduo$ps
    }
  }

  if (FALSE && ms_lev == 1L) {
    chx2 <- chs2 + 1L
    unqs <- !as.integer(chx2 * 2L) %in% chx2
    chs2 <- chs2[unqs]
    p2s <- p2s[unqs]
    
    nsubs <- n_ms1s[p2s]
    
    if (max(nsubs) == min(nsubs)) {
      chs2 <- chs2[which.max(msxints[p2s])]
      return(chs2 + 1L)
    }
    
    chs2 <- chs2[which.max(n_ms1s[p2s])]
    return(chs2 + 1L)
  }
  else {
    chs2 <- chs2[which.max(msxints[p2s])]
    return(chs2 + 1L)
  }
}


#' Checks the duplicacy between charge states 2 and 4.
#'
#' @param duo The potentially duplicated charge states. The values are off by
#'   one less in that the input charge states are derived from searches
#'   beginning charge states 2 instead of 1.
#' @param chs The charge states for checking duplicacy.
#' @param ps The corresponding positions of the observed \code{chs} in a
#'   m-over-z sequence.
#' @param msxints A sequence of intensity values.
#' @param cutoff A discriminating cut-off threshold.
check_chduo <- function (duo = c(1L, 3L), chs, ps, msxints, cutoff = 1.5)
{
  if (length(chs) < 2L)
    return(list(chs = chs, ps = ps))
  
  idxs <- match(duo, chs)
  i1 <- idxs[[1]]
  i2 <- idxs[[2]]
  
  if (!(is.na(i1) || is.na(i2))) {
    p1 <- ps[[i1]]
    p2 <- ps[[i2]]
    
    if (msxints[p1]/msxints[p2] < cutoff) {
      chs <- chs[-i1]
      ps <- ps[-i1]
    }
    else {
      chs <- chs[-i2]
      ps <- ps[-i2]
    }
  }
  
  list(chs = chs, ps = ps)
}


#' Is logical one.
#' 
#' @param x A logical vector.
is_true <- function(x) `==`(x, 1L)


#' Searches for a possible doubled charge state.
#'
#' Not used.
#' 
#' @param ch The initial charge state.
#' @param p The position in \code{moverzs}.
#' @param sta The position of start.
#' @param mass The current m-over-z.
#' @param moverzs A vector of m-over-z values.
#' @param max_charge The maximum charge state for consideration.
#' @param ppm Mass error tolerance.
#' @param f A function of \code{+} or \code{-} for forward or backward
#'   searching.
find_dbl_z <- function(ch = 2L, p = 2L, sta, mass, moverzs, max_charge = 4L, 
                       ppm = 5L, f = `+`) 
{
  # stopifnot(p >= 1L) # no other peaks in between
  
  # no other peaks in between
  if (p <= 1L) 
    return(ch)

  ans <- ch

  while((ch <- ch * 2L) <= max_charge) {
    mx  <- f(mass, 1.003355/ch)
    sta <- f(sta, 1L)
    end <- f(sta, p - 1L)
    oks <- abs((mx - moverzs[sta:end])/mx) * 1E6 <= ppm
    ps  <- Position(is_true, oks)
    
    if (is.na(ps)) 
      break 
    else
      ans <- ch
  }
  
  ans
}


#' Detects chromatographic peaks.
#' 
#' May be over-killing.
#' 
#' https://stackoverflow.com/questions/22583391/peak-signal-detection-in-realtime-timeseries-data
#' https://stackoverflow.com/questions/58942623/isolating-peaks-in-from-time-series-data-in-r
#' 
#' @param y Values of y.
#' @param lag The lag length.
#' @param threshold The threshold.
#' @param influence The influence.
#' @param min_len The minimum length of y for peak-picking algorithm.
#' @param min_lag The minimum length of the lag.
#' @param max_lag The maximum length of the lag.
#' @param min_var The minimum variance.
#' @param static Is the time series static (or adaptive).
find_lcpeaks <- function (y, lag = 5L, min_lag = 3L, max_lag = 200L, 
                          min_len = 10L, min_var = 1E-5, static = TRUE,
                          threshold = 3, influence = 0) 
{
  if (min_len < min_lag)
    stop("`min_len` cannot be smaller than `min_lag`.")
  
  if (lag < min_lag)
    stop("`lag` cannot be smaller than `min_lag`.")
  
  if (lag > max_lag)
    stop("`lag` cannot be greater than `max_lag`.")
  
  if ((len <- length(y)) <= min_len) {
    # return(list(signals = NA_integer_, avgFilter = NA_real_, stdFilter = NA_real_))
    return(rep.int(1L, len))
  }
  
  if (lag >= (len2 <- len * .15)) 
    lag <- min(max_lag, ceiling(len2))
  else
    lag <- min(max_lag, lag)
  
  n <- lag - 1L
  n2 <- lag * n
  filteredY <- y
  
  # global (if static)
  # also need a default, static gl_va and gl_sd...
  gl_su <- sum(y, na.rm = TRUE)
  gl_me <- gl_su/len
  
  if ((gl_va <- sum(y^2, na.rm = TRUE)/len - gl_su^2/len/(len - 1L)) < 0) {
    gl_va <- var(y)
    gl_sd <- sqrt(gl_va)
  }
  else {
    gl_sd <- sqrt(gl_va) * .10
  }
  
  # initialization
  signals <- rep.int(0L, len)
  va_y <- su_y <- ss_y <- stdFilter <- avgFilter <- rep_len(NA_real_, len)
  
  i <- lag
  ys <- y[1:i]
  ss_y[i] <- ss_yi <- sum(ys^2, na.rm = TRUE)
  su_y[i] <- su_yi <- sum(ys, na.rm = TRUE)
  avgFilter[i] <- su_me <- su_yi/lag
  
  if ((va_yi <- ss_yi/n - (su_yi)^2/n2) < min_var) 
    va_yi <- gl_va
  
  if ((sd_yi <- sqrt(va_yi)) < gl_sd)
    sd_yi <- gl_sd
  
  va_y[i] <- va_yi
  stdFilter[i] <- sd_yi
  
  # rolling
  for (i in (lag + 1L):len) {
    p <- i - 1L
    l <- i - lag + 1L
    yi <- y[i]
    d <- yi - avgFilter[p]
    
    if (abs(d) > threshold * stdFilter[p]) {
      signals[i] <- if (d > 0) 1L else -1L
      filteredY[i] <- influence * yi + (1 - influence) * filteredY[p]
    }
    
    ss_y[i] <- ss_yi <- ss_y[p] + filteredY[i]^2 - filteredY[l]^2
    su_y[i] <- su_yi <- su_y[p] + filteredY[i] - filteredY[l]
    avgFilter[i] <- su_yi/lag
    
    if ((va_yi <- ss_yi/n - (su_yi)^2/n2) < 1E-5) 
      va_yi <- 0
    
    if ((sd_yi <- sqrt(va_yi)) < gl_sd)
      sd_yi <- gl_sd
    
    va_y[i] <- va_yi
    stdFilter[i] <- sd_yi
  }
  
  # list(signals = signals, avgFilter = avgFilter, stdFilter = stdFilter)
  signals
}


#' Chunks of precursor lists by continuous retention-time bins.
#' 
#' Not used.
#' 
#' @param df A data frame of precursors.
sep_ms1rts <- function (df)
{
  dfs <- split(df, df$irt) 
  len <- length(dfs)
  frs <- as.integer(names(dfs))
  brs <- which(diff(frs) > 1L)
  
  ans <- vector("list", length(brs) + 1L)
  
  sta <- 0L
  
  for (i in seq_along(brs)) {
    end <- brs[i]
    ans[[i]] <- dfs[(sta + 1L):end]
    sta <- end
  }
  
  ans[[length(ans)]] <- dfs[(sta + 1L):len]
  
  ans
}


#' Three-frame binning of precursor retention times.
#' 
#' Not used.
#' 
#' @param df A data frame of precursors.
bin_ms1rts <- function (df)
{
  len <- length(df)
  
  if (len <= 3L) {
    return(dplyr::bind_rows(df))
  }
  
  ans <- vector("list", len_out <- len - 2L)
  
  for (i in 1:len_out) {
    ans[[i]] <- dplyr::bind_rows(df[[i]], df[[i+1L]], df[[i+2L]])
  }
  
  ans
}


#' Generate an isotope envelop
#' 
#' Not used.
#' 
#' @param mass Precursor mass.
#' @param charge Charge state.
gen_isoenvlope <- function (mass = 560, charge = 2L)
{
  # averagine: C 4.9384; H 7.7583; N 1.3577; O 1.4773; S 0.0417
  # 4.9384*12 + 7.7583*1.007825 + 1.3577*14.003074 + 1.4773*15.99491462 + 0.0417*31.9720707
  
  p13c <- .0111   # .9889 + 0.0111
  p2h  <- .000156 # .999844 + .000156
  p18o <- .00187  # .99738 + .00187
  p15n <- .004    # .996 + .004
  p34s <- .043    # .952 + .0425 -> .957 + .0427

  size <- mass / 111
  nc <- round(size*5.1)
  nh <- round(size*7.7)
  no <- round(size*1.4773)
  nn <- round(size*1.3577)
  ns <- round(size*0.0417)
  
  nd <- mass - (nc * 12 + nh * 1.007825 + nn * 14.003074 + no * 15.99491462 + ns * 31.9720707)
  nh <- nh + round(nd/1.007825)
  
  # C19 H25 O5 N5 S3
  dc <- dbinom(0:5, nc, p13c)
  dh <- dbinom(0:5, nh, p2h)
  do <- dbinom(0:5, no, p18o)
  dn <- dbinom(0:5, nn, p15n)
  ds <- dbinom(0:5, ns, p34s)
  
  dc <- dc/dc[[1]]
  dh <- dh/dh[[1]]
  do <- do/do[[1]]
  dn <- dn/dn[[1]]
  ds <- ds/ds[[1]]
  
  ## +1
  p13c * nc # 0.2109; no collapsing at hi-res MS, good approximation
  p13c * nc + p2h * nh + p15n * nn # .235; no collapsing unless with low-res MS

  # no need to incur the computationally more involved version, 
  #   as MS isotope envelope from a single scan probably not have the accuracy
  xc <- nc * p13c * (1 - p13c)^(nc - 1L)/(1 - p13c)^nc
  xh <- nh * p2h  * (1 -  p2h)^(nh - 1L)/(1 - p2h)^nh
  xn <- nn * p15n * (1 - p15n)^(nn - 1L)/(1 - p15n)^nn
  xc + xh + xn # .237
  
  ## +2
  # Xcalibur 9.14E4/6.74E5 # .136
  
  if (ns) {
    # uses the bigger
    ds[[2]]
    dc[[3]]
  }
  else {
    dc[[3]]
  }

  ## +3
  # .111 * .889^18 * 19 # .253
  
  # + p34s * ns
  # p13c * (nc + 1L) + p2h * nh + p18o * no + p15n * nn + p34s * ns
  
  # +2 can be 2*13c, 13c + 2h, 
  
  
  # C19 H25 O5 N5 S3
  nc <- 19; nh <- 25; no <- 5; nn <- 5; ns <- 3
}


#' Function factories for finding the amino-acid residue at a position.
#'
#' If the the value in a \code{vmods} is one of the LETTERS -> a site is
#' specified in the corresponding variable modification. Otherwise, a site is in
#' one of \code{c("C-term", "N-term")}. For example, \code{`Oxidation (M)` =
#' "M"} for the former and \code{`Protein N-term` = "N-term"} for the later. In
#' other words, \code{pos} can be a simple upper case letter or a string of
#' "\code{[NC]-term}".
#'
#' However, \code{vmods} like \code{`Protein N-term` = "N-term"} or \code{`Any
#' N-term` = "N-term"} are trivial and will fail against the \code{oks} check.
#'
#' As pointed out above, there is no need to check \code{is.null(p)}. Also there
#' is no need to check \code{is.null(posns)} as it is always a character string
#' of \code{attr(aa_masses, "vmods_ps", exact = TRUE)}.
#'
#' @param pos The Unimod position of a variable modification, which must be one
#'   of \code{c("Protein N-term", "Protein C-term", "Any N-term", "Any C-term",
#'   "Anywhere")}. No need to check its value for the way the function is called
#'   (by the developer).
#' @return A function for finding the residue at the position specified by the
#'   argument \code{pos}. For each function, it takes a list of variable
#'   modifications specified by argument \code{vmods} and the corresponding
#'   "positions" (for vectorization) as inputs.
find_pos_site <- function (pos) 
{
  p <- paste0("^", pos)

  function (vmods, posns) 
  {
    oks <- .Internal(grepl(p, posns, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE)) & 
      vmods %in% LETTERS
    
    vmods[oks]
  }
}


#' Finds the sites of amino-acid residues at the position of \code{Protein
#' N-term}.
#'
#' Flowchart (1-nt): Dimethyl (Protein N-term = P)
#'
#' @param vmods A named list of variable modifications.
#' @inheritParams find_nmodtree
#' @seealso contain_protntany
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' ## `Protein N-term = P`
#' sites <- list(`Dimethyl (Protein N-term = P)` = "P",
#'               `Acetyl (Protein N-term)` = "N-term", 
#'               `Oxidation (M)` = "M",
#'               `Deamidated (N)` = "N")
#' positions <- c("Protein N-term", "Protein N-term", "Anywhere", "Anywhere")
#' vmods <- purrr::map2(sites, positions, ~ setNames(.x, .y))
#'
#' # (pretend `vmods` in a real workflow)
#' vmods <- unname(vmods)
#' vmods <- unlist(vmods, recursive = FALSE, use.names = TRUE)
#' posns <- names(vmods)
#' # stopifnot(identical(positions, posns))
#'
#' stopifnot(mzion:::contain_protntsite(vmods, names(vmods), length(vmods)))
#' 
#' ans <- mzion:::find_protntsite(vmods, posns)
#' stopifnot(identical(ans, vmods[1]))
#' }
find_protntsite <- find_pos_site("Protein N-term")


#' Finds the sites of amino-acid residues at the position of \code{Any N-term}.
#'
#' Flowchart (3-nt): Gln->pyro Glu (N-term = Q)
#'
#' @rdname  find_protntsite
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' ## Gln->pyro Glu (N-term = Q)
#' sites <- list(`Gln->pyro Glu (N-term = Q)` = "Q",
#'               `Acetyl (N-term)` = "N-term",
#'               `Oxidation (M)` = "M",
#'               `Deamidated (N)` = "N")
#' positions <- c("Any N-term", "Any N-term", "Anywhere", "Anywhere")
#' vmods <- purrr::map2(sites, positions, ~ setNames(.x, .y))
#'
#' vmods <- unname(vmods)
#' vmods <- unlist(vmods, recursive = FALSE, use.names = TRUE)
#' posns <- names(vmods)
#'
#' stopifnot(mzion:::contain_anyntsite(vmods, posns, length(vmods)))
#'
#' ans <- mzion:::find_anyntsite(vmods, posns)
#' stopifnot(identical(ans, vmods[1])) # M and N
#' }
find_anyntsite <- find_pos_site("Any N-term")


#' Finds amino-acid sites for a given set of variable modifications at the
#' position of \code{Anywhere}.
#'
#' Flowchart (5): Oxidation (M)
#'
#' In the less common cases of multiple modifications to the same
#' \code{Anywhere} site, e.g., "Oxidation (M)" and "Carbamyl (M)", an amino-acid
#' sequence should contain at least two "M"s. This is due to the design that
#' \code{vmods} in an \code{aa_masses} are realized. The additional subsetting
#' by the counts of residues is applied at this stage of the peptide
#' distributions. A downstream step in the calculations of MS2 ions will also
#' guard against this.
#'
#' In the case of, e.g., "Oxidation (M)" and "Protein (N-term)", and the peptide
#' sequence has only one "M" on the N-term, the entry is still kept with
#' the "additive" effect of modifications. 
#'
#' @rdname  find_protntsite
#'
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' ## `Oxidation (M)` and `Deamidated (N)`
#' sites <- list(`Acetyl (N-term)` = "N-term",
#'               `Oxidation (M)` = "M",
#'               `Deamidated (N)` = "N")
#' positions <- c("Any N-term", "Anywhere", "Anywhere")
#' vmods <- purrr::map2(sites, positions, ~ setNames(.x, .y))
#'
#' vmods <- unname(vmods)
#' vmods <- unlist(vmods, recursive = FALSE, use.names = TRUE)
#' posns <- names(vmods)
#'
#' stopifnot(mzion:::contain_anysite(vmods, posns, length(vmods)))
#'
#' ans <- mzion:::find_anysite(vmods, posns)
#' stopifnot(length(ans) == 2L)
#'
#'
#' ## `Oxidation (M)` and `Carbamyl (M)`
#' sites <- list(`Dimethyl (Protein N-term = P)` = "P",
#'               `Oxidation (M)` = "M", `Carbamyl (M)` = "M",
#'               `Deamidated (N)` = "N")
#' positions <- c("Any N-term", "Anywhere", "Anywhere", "Anywhere")
#' vmods <- purrr::map2(sites, positions, ~ setNames(.x, .y))
#'
#' vmods <- unname(vmods)
#' vmods <- unlist(vmods, recursive = FALSE, use.names = TRUE)
#' vmods <- vmods[!duplicated.default(vmods)]
#'
#' posns <- names(vmods)
#' stopifnot(length(posns) < length(positions))
#'
#' ans <- mzion:::find_anysite(vmods, posns)
#' stopifnot(length(ans) == 2L)
#' }
find_anysite <- find_pos_site("Anywhere")


#' Finds amino-acid sites at the position of \code{Protein C-term}.
#' 
#' Flowchart f(1-ct): Dehydrated (Protein C-term = N)
#' 
#' @rdname  find_protntsite
#' 
#' @examples 
#' \donttest{
#' library(mzion)
#' 
#' ## `Dehydrated (Protein C-term = N)`
#' sites <- list(`Dehydrated (Protein C-term = N)` = "N", 
#'               `Acetyl (N-term)` = "N-term", 
#'               `Oxidation (M)` = "M", 
#'               `Deamidated (N)` = "N")
#' positions <- c("Protein C-term", "Any N-term", "Anywhere", "Anywhere")
#' vmods <- purrr::map2(sites, positions, ~ setNames(.x, .y))
#' 
#' vmods <- unname(vmods)
#' vmods <- unlist(vmods, recursive = FALSE, use.names = TRUE)
#' posns <- names(vmods)
#' 
#' stopifnot(mzion:::contain_protctsite(vmods, posns, length(vmods)))
#' 
#' ans <- mzion:::find_protctsite(vmods, posns)
#' stopifnot(identical(ans, vmods[1]))
#' }
find_protctsite <- find_pos_site("Protein C-term")


#' Finds amino-acid sites at the position of \code{Any C-term}.
#' 
#' Flowchart f(3-ct): Oxidation (C-term = G)
#' 
#' @rdname  find_protntsite
#' @examples 
#' \donttest{
#' library(mzion)
#' 
#' ## `Oxidation (C-term = G)`
#' sites <- list(`Oxidation (C-term = G)` = "G", 
#'               `Acetyl (N-term)` = "N-term", 
#'               `Oxidation (M)` = "M", 
#'               `Deamidated (N)` = "N")
#' positions <- c("Any C-term", "Any N-term", "Anywhere", "Anywhere")
#' vmods <- purrr::map2(sites, positions, ~ setNames(.x, .y))
#' 
#' vmods <- unname(vmods)
#' vmods <- unlist(vmods, recursive = FALSE, use.names = TRUE)
#' posns <- names(vmods)
#' 
#' stopifnot(mzion:::contain_anyctsite(vmods, posns, length(vmods)))
#' 
#' ans <- mzion:::find_anyctsite(vmods, posns)
#' stopifnot(identical(ans, vmods[1]))
#' }
find_anyctsite <- find_pos_site("Any C-term")


#' Function factories for checking the existence of an amino-acid residue at a
#' position.
#' 
#' No need to check \code{is.null(p)} and \code{is.null(posns)}.
#'
#' @inheritParams find_pos_site
#' @return A function for checking the existence of a residue at the position
#'   specified by the argument \code{pos}. For each function, it takes a list of
#'   variable modifications specified by argument \code{vmods}, and the
#'   corresponding postitions and counts as inputs.
contain_pos_site <- function (pos) 
{
  p <- paste0("^", pos)

  function (vmods, posns, len) 
  {
    if (!len) 
      return(FALSE)
    
    if (len == 1L && vmods == "") 
      return(FALSE)
    
    oks <- .Internal(grepl(p, posns, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE)) & 
      vmods %in% LETTERS

    any(oks)
  }
}


#' Flowchart (1-nt): Dimethyl (Protein N-term = P)
#'
#' @rdname find_protntsite
contain_protntsite <- contain_pos_site("Protein N-term")


#' Flowchart (3-nt): Gln->pyro Glu (N-term = Q)
#' 
#' @rdname  find_protntsite
contain_anyntsite <- contain_pos_site("Any N-term")


#' Flowchart (5): Oxidation (M)
#' 
#' @rdname find_protntsite
contain_anysite <- contain_pos_site("Anywhere")


#' Flowchart (1-ct): Dehydrated (Protein C-term = N)
#' 
#' @rdname find_protntsite
contain_protctsite <- contain_pos_site("Protein C-term")


#' Flowchart (3-ct): Oxidation (C-term = G)
#' 
#' @rdname find_protntsite
contain_anyctsite <- contain_pos_site("Any C-term")


#' Function factories for checking the existence of an amino-acid residue at a
#' \code{terminal} position.
#'
#' Note to the developer: when manufacturing, a \code{pos} must be terminal in
#' one of \code{c("Protein N-term", "Any N-term", "Protein C-term", "Any
#' C-term")}. \code{"Anywhere"} is not one of them.
#' 
#' No need to check \code{is.null(p)} and \code{is.null(posns)}.
#'
#' @param pos The position. It must be terminal in \code{c("Protein N-term",
#'   "Any N-term", "Protein C-term", "Any C-term")}.
#' @return A function for checking the existence of a residue at the
#'   \code{terminal} position specified by the argument \code{pos}. For each
#'   function, it takes a list of variable modifications specified by argument
#'   \code{vmods} as inputs.
contain_termpos_any <- function (pos) 
{
  p <- paste0("^", pos)

  function (vmods, posns, len) 
  {
    if (!len) 
      return(FALSE)
    
    if (len == 1L && vmods == "") 
      return(FALSE)
    
    oks <- .Internal(grepl(p, posns, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE))

    any(oks)
  }
}


#' Checks if variable modifications are on \code{Protein N-term}.
#'
#' Flowchart (2-nt): Acetyl (Protein N-term)
#'
#' @inheritParams find_nmodtree
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' ## `Acetyl (Protein N-term)`
#' sites <- list(`Acetyl (Protein N-term)` = "N-term", 
#'               `Oxidation (M)` = "M", 
#'               `Deamidated (N)` = "N")
#' positions <- c("Protein N-term", "Anywhere", "Anywhere")
#' vmods <- purrr::map2(sites, positions, ~ setNames(.x, .y))
#' 
#' vmods <- unname(vmods)
#' vmods <- unlist(vmods, recursive = FALSE, use.names = TRUE)
#' posns <- names(vmods)
#' 
#' mzion:::contain_protntany(vmods, posns, length(vmods))
#' }
contain_protntany <- contain_termpos_any("Protein N-term")


#' Checks if variable modifications are on \code{Any N-term}.
#' 
#' Flowchart (4-nt): Acetyl (N-term)
#' 
#' @rdname contain_protntany
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' ## `Acetyl (N-term)`
#' sites <- list(`Acetyl (N-term)` = "N-term", 
#'               `Oxidation (M)` = "M", 
#'               `Deamidated (N)` = "N")
#' positions <- c("Any N-term", "Anywhere", "Anywhere")
#' vmods <- purrr::map2(sites, positions, ~ setNames(.x, .y))
#' 
#' vmods <- unname(vmods)
#' vmods <- unlist(vmods, recursive = FALSE, use.names = TRUE)
#' posns <- names(vmods)
#' 
#' mzion:::contain_anyntany(vmods, posns, length(vmods))
#' }
contain_anyntany <- contain_termpos_any("Any N-term")


#' Checks if variable modifications are on \code{Protein C-term}.
#' 
#' Flowchart (2-ct): Amidated (Protein C-term)
#' 
#' @rdname contain_protntany
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' ## `Amidated (Protein C-term)`
#' sites <- list(`Amidated (Protein C-term)` = "C-term", 
#'               `Oxidation (M)` = "M", 
#'               `Deamidated (N)` = "N")
#' positions <- c("Protein C-term", "Anywhere", "Anywhere")
#' vmods <- purrr::map2(sites, positions, ~ setNames(.x, .y))
#' 
#' vmods <- unname(vmods)
#' vmods <- unlist(vmods, recursive = FALSE, use.names = TRUE)
#' posns <- names(vmods)
#' 
#' mzion:::contain_protctany(vmods, posns, length(vmods))
#' }
contain_protctany <- contain_termpos_any("Protein C-term")


#' Checks if variable modifications are on \code{C-term}.
#' 
#' Flowchart (4-ct): Amidated (C-term)
#' 
#' @rdname contain_protntany
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' ## `Amidated (C-term)`
#' sites <- list(`Amidated (C-term)` = "C-term", 
#'               `Oxidation (M)` = "M", 
#'               `Deamidated (N)` = "N")
#' positions <- c("Any C-term", "Anywhere", "Anywhere")
#' vmods <- purrr::map2(sites, positions, ~ setNames(.x, .y))
#' 
#' vmods <- unname(vmods)
#' vmods <- unlist(vmods, recursive = FALSE, use.names = TRUE)
#' posns <- names(vmods)
#' 
#' mzion:::contain_anyctany(vmods, posns, length(vmods))
#' }
contain_anyctany <- contain_termpos_any("Any C-term")


#' Subsets peptides
#' 
#' By individual proteins.
#' 
#' @param ps A list of peptides under a protein
#' @param s A pattern
#' @inheritParams subpeps_by_vmods
subset_by_prps <- function (ps, s, motifs) 
{
  # protein has no suitable peptides
  if (is.null(ps))
    return(NULL)
  
  oks <- .Internal(grepl(s, ps, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE))
  ps <- ps[oks]
  
  if ((!is.null(motifs)) && length(ps)) {
    oks2 <- .Internal(grepl(motifs, ps, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE))
    ps <- ps[oks2]
  }
  
  # if ((nchar(motifs)) && length(ps)) {
  #   oks2 <- .Internal(grepl(motifs, ps, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE))
  #   ps <- ps[oks2]
  # }
  
  ps
}


#' Subsets proteins by variable modifications.
#'
#' Flowchart (1-nt): Dimethyl (Protein N-term = P)
#'
#' @param prps List of proteins.
#' @param peps List of peptides.
#' @param site A site. No need to specify "any terminal" sites.
#' @param sites Sites.
#' @inheritParams find_nmodtree
#' @examples
#' \donttest{
#' library(mzion)
#' library(purrr)
#' 
#' ## Protein N-term (Site)
#' sites <- list(`Dimethyl (Protein N-term = P)` = "P", 
#'               `Oxidation (M)` = "M", 
#'               `Deamidated (N)` = "N")
#' positions <- c("Protein N-term", "Anywhere", "Anywhere")
#' vmods <- purrr::map2(sites, positions, ~ setNames(.x, .y))
#' 
#' vmods <- unname(vmods)
#' vmods <- unlist(vmods, recursive = FALSE, use.names = TRUE)
#' posns <- names(vmods)
#' 
#' prps <- list(PROT_A = c("-MAKEMASSPECFUN", "-PAKEKASSPECFUN"), 
#'              PROT_B = c("PAKEKASSPECFUN", "NKAKEKASSPECFU", 
#'                         "-NKAKEKASSPECFU"))
#' 
#' mzion:::subset_protntsite(prps, mzion:::find_protntsite(vmods, posns))
#' } 
subset_protntsite <- function (prps, site, motifs = NULL) 
{
  lapply(prps, subset_by_prps, paste0("^-", site), motifs)
}


#' Subsets proteins by variable modifications.
#' 
#' Flowchart (2-nt): Acetyl (Protein N-term)
#' 
#' @rdname subset_protntsite
subset_protntany <- function (prps, motifs = NULL) 
{
  lapply(prps, subset_by_prps, "^-", motifs)
}


#' Subsets proteins by variable modifications.
#' 
#' Flowchart (3-nt): Gln->pyro Glu (N-term = Q)
#' 
#' @rdname subset_protntsite
#' @examples 
#' \donttest{
#' library(mzion)
#' 
#' ## Any N-term (Site)
#' sites <- list(`Dimethyl (N-term = P)` = "P", 
#'               `Oxidation (M)` = "M", 
#'               `Deamidated (N)` = "N")
#' positions <- c("Any N-term", "Anywhere", "Anywhere")
#' vmods <- purrr::map2(sites, positions, ~ setNames(.x, .y))
#' 
#' vmods <- unname(vmods)
#' vmods <- unlist(vmods, recursive = FALSE, use.names = TRUE)
#' posns <- names(vmods)
#' 
#' prps <- list(PROT_A = c("-MAKEMASSPECFUN", "-PAKEKASSPECFUN"), 
#'              PROT_B = c("PAKEKASSPECFUN", "NKAKEKASSPECFU", 
#'                         "-NKAKEKASSPECFU"))
#' 
#' # "-PAKEKASSPECFUN" went with `subset_protntsite` (see flow charts)
#' mzion:::subset_anyntsite(prps, mzion:::find_anyntsite(vmods, posns))
#' }
subset_anyntsite <- function (prps, site = "Q", motifs = NULL) 
{
  lapply(prps, subset_by_prps, paste0("^", site), motifs)
}


#' Subsets proteins by variable modifications.
#' 
#' Flowchart f(4-nt): Acetyl (N-term)
#' 
#' @rdname subset_protntsite
subset_anyntany <- function (peps) peps


#' Subsets proteins by variable modifications.
#' 
#' Flowchart (5): Oxidation (M)
#' 
#' @rdname subset_protntsite
#' @inheritParams find_nmodtree
#' @examples 
#' \donttest{
#' library(mzion)
#' 
#' ## Anywhere
#' min_n_res <- c(P = 1, M = 1, N = 1)
#' 
#' sites <- list(`Dimethyl (N-term = P)` = "P", 
#'               `Oxidation (M)` = "M", 
#'               `Deamidated (N)` = "N")
#' positions <- c("Any N-term", "Anywhere", "Anywhere")
#' vmods <- purrr::map2(sites, positions, ~ setNames(.x, .y))
#' 
#' vmods <- unname(vmods)
#' vmods <- unlist(vmods, recursive = FALSE, use.names = TRUE)
#' 
#' prps <- list(PROT_A = c("-MAKEMASSPECFUN", "-PAKEKASSPECFUN"), 
#'              PROT_B = c("PAKEKASSPECFUN", "NKAKEKASSPECFU", 
#'                         "-NKAKEKASSPECFU"))
#' 
#' # should contain both M and N
#' mzion:::subset_anysite(prps, sites, min_n_res)
#' 
#' ## Multiple mods to the same site
#' # (mimic from aa_masses)
#' min_n_res <- c(P = 1, M = 2, N = 1)
#' 
#' sites <- list(`Dimethyl (N-term = P)` = "P", 
#'               `Oxidation (M)` = "M", `Carbamyl (M)` = "M", 
#'               `Deamidated (N)` = "N")
#' positions <- c("Any N-term", "Anywhere", "Anywhere", "Anywhere")
#' vmods <- purrr::map2(sites, positions, ~ setNames(.x, .y))
#' 
#' # No need of modification names
#' vmods <- unname(vmods)
#' sites <- unname(sites)
#' vmods <- unlist(vmods, recursive = FALSE, use.names = TRUE)
#' 
#' is_same <- any(length(min_n_res) > 1L)
#' if (is_same) {
#'   ok <- !duplicated.default(vmods)
#'   vmods <- vmods[ok]
#'   sites <- sites[ok]
#' }
#' 
#' prps <- list(PROT_A = c("-MAKEMASSPECFUN", "-PAKEKASSPECFUN"), 
#'              PROT_B = c("PAKEKASSPECFUN", "NKAKEKASSPECFU", 
#'                         "-NKAKEKASSPECFU"))
#' 
#' ans <- mzion:::subset_anysite(prps, sites, min_n_res)
#' }
subset_anysite <- function (prps, sites, min_n_res, motifs = NULL, excepts = NULL) 
{
  # ps - peptides under a protein
  # p  - a peptide
  # ns - counts for each site

  if (!is.null(excepts)) {
    sites <- sites[!sites %in% excepts]
    min_n_res <- min_n_res[sites]
  }

  if (!length(sites))
    return(prps)
  
  ok_mo <- !is.null(motifs)

  lapply(prps, function (ps) {
    oks <- lapply(ps, function (p) {
      ns <- .Call(stringi:::C_stri_count_fixed, str = p, pattern = sites, opts_fixed = NULL)
      ok <- all(ns >= min_n_res)
      
      if (ok_mo && ok)
        ok <- ok && .Internal(grepl(motifs, p, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE))
      
      # if (nchar(motifs) && ok)
      #   ok <- ok && .Internal(grepl(motifs, p, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE))
      
      ok
    })
    
    oks <- .Internal(unlist(oks, recursive = FALSE, use.names = FALSE))
    
    ps[oks]
  })
}


#' Subsets proteins by variable modifications.
#' 
#' Flowchart (1-ct): Dehydrated (Protein C-term = N)
#' 
#' @rdname subset_protntsite
subset_protctsite <- function (prps, site, motifs = NULL) 
{
  lapply(prps, subset_by_prps, paste0(site, "-$"), motifs)
}


#' Subsets proteins by variable modifications.
#' 
#' Flowchart f(2-ct)
#' 
#' @rdname subset_protntsite
subset_protctany <- function (prps, motifs = NULL) 
{
  lapply(prps, subset_by_prps, "-$", motifs)
}


#' Subsets proteins by variable modifications.
#' 
#' Flowchart (3-ct): Oxidation (C-term = G)
#' 
#' @rdname subset_protntsite
subset_anyctsite <- function (prps, site, motifs = NULL) 
{
  lapply(prps, subset_by_prps, paste0(site, "$"), motifs)
}


#' Subsets proteins by variable modifications.
#' 
#' Flowchart (4-ct): Amidated (C-term)
#' 
#' @rdname subset_protntsite
subset_anyctany <- function (peps) peps


#' Find and subset peptides.
#'
#' (1-nt) Protein N-term + site -> (2-nt) Any protein N-term -> (3-nt) Any
#' N-term + site -> (4-nt) Any N-term -> (5) Anywhere + site.
#'
#' @param vmods A named list of variable modifications. See also
#'   \link{find_protntsite} for examples of \code{vmods}.
#' @param excepts Sites to be exempted from matching during distribution.
#' @param min_n_res The minimum numbers of residues for a given set of sites.
#' @param posns The position (e.g., \code{Protein N-term}, \code{Anywhere},
#'   etc.) of \code{vmods}. The argument can be obtained from \code{vmods} but
#'   passed as a parameter for vectorization.
#' @param len The count of \code{vmods} (passed as a parameter for
#'   vectorization).
#' @inheritParams distri_peps
#' @inheritParams subpeps_by_vmods
find_nmodtree <- function (prps, excepts = NULL, min_n_res, vmods, posns, len, 
                           motifs = NULL) 
{
  if (contain_protntsite(vmods, posns, len)) { # level_1: Protein N-term + Site
    prps <- subset_protntsite(prps, find_protntsite(vmods, posns), motifs)
    
    if (contain_anysite(vmods, posns, len)) {
      # (1) -|* .. |
      prps <- subset_anysite(prps, find_anysite(vmods, posns), min_n_res, motifs, excepts)
    } else {
      # (2) -|*    |
      prps <- prps
    }
  } 
  else {
    if (contain_protntany(vmods, posns, len)) { # level_2: Protein N-term 
      prps <- subset_protntany(prps, motifs)
      
      if (contain_anysite(vmods, posns, len)) {
        # (3) -|o .. |
        prps <- subset_anysite(prps, find_anysite(vmods, posns), min_n_res, motifs, excepts)
      } else {
        # (4) -|o    |
        prps <- prps
      }
    } 
    else { 
      if (contain_anyntsite(vmods, posns, len)) { # level_3: Any N-term + Site
        prps <- subset_anyntsite(prps, find_anyntsite(vmods, posns), motifs)
        
        if (contain_anysite(vmods, posns, len)) {
          # (5) |* .. |
          prps <- subset_anysite(prps, find_anysite(vmods, posns), min_n_res, motifs, excepts)
        } else {
          # (6) |*    |
          prps <- prps
        }
      } 
      else { 
        if (contain_anyntany(vmods, posns, len)) { # level_4: Any N-term 
          prps <- prps 
          
          if (contain_anysite(vmods, posns, len)) {
            # (7) |o .. |
            prps <- subset_anysite(prps, find_anysite(vmods, posns), min_n_res, motifs, excepts)
          } else {
            # (8) |o    |
            prps <- prps
          }
        } 
        else { 
          if (contain_anysite(vmods, posns, len)) { # level_5: Anywhere
            # (9) |  .. |
            prps <- subset_anysite(prps, find_anysite(vmods, posns), min_n_res, motifs, excepts)
          } else {
            # (10) |     |
            prps <- prps
          }
        }
      }
    }
  }
}


#' Find and subset peptides.
#'
#' (1-ct) Protein C-term + site -> (2-ct) Any protein C-term -> (3-ct) Any
#' C-term + site -> (4-ct) Any C-term.
#'
#' @inheritParams find_nmodtree
#' @inheritParams subpeps_by_vmods
find_cmodtree <- function (prps, excepts = NULL, min_n_res, vmods, posns, len, 
                           motifs = NULL) 
{
  if (contain_protctsite(vmods, posns, len)) { # level_1: Protein C-term + Site
    # (1) -|* .. *|-, (2) -|*    *|-, (3) -|o .. *|-, (4) -|o    *|-, (5) |* .. *|-, 
    # (6) |*    *|-, (7) |o .. *|-, (8) |o    *|-, (9) |  .. *|-, (10) |     *|-
    prps <- subset_protctsite(prps, find_protctsite(vmods, posns), motifs)
  } 
  else {
    if (contain_protctany(vmods, posns, len)) { # level_2: Protein C-term 
      # (1) -|* .. o|-, (2) -|*    o|-, (3) -|o .. o|-, # (4) -|o    o|-, # (5) |* .. o|-, 
      # (6) |*    o|-, (7) |o .. o|-, (8) |o    o|-, (9) |  .. o|-, (10) |     o|-
      prps <- subset_protctany(prps, motifs)
    } 
    else {
      if (contain_anyctsite(vmods, posns, len)) { # level_3: Any C-term + Site
        # (1) -|* .. *|, (2) -|*    *|, (3) -|o .. *|, # (4) -|o    *|, # (5) |* .. *|, 
        # (6) |*    *|, (7) |o .. *|, (8) |o    *|, (9) |  .. *|, (10) |     *|
        prps <- subset_anyctsite(prps, find_anyctsite(vmods, posns), motifs)
      } 
      else {
        if (contain_anyctany(vmods, posns, len)) { # level_4: Any C-term
          # (1) -|* .. o|, (2) -|*    o|, (3) -|o .. o|, # (4) -|o    o|, # (5) |* .. o|, 
          # (6) |*    o|, (7) |o .. o|, (8) |o    o|, (9) |  .. o|, (10) |     o|
          prps <- prps 
        } # else {
          # No use
        # }
      }
    }
  }
  
  invisible(prps)
}


#' Subsets peptides by variable modifications.
#'
#' From N-term to C-term.
#'
#' @param motifs A list of motifs of amino-acide residues. for example,
#' "MN|NG". See also \link{matchMS}.
#' @inheritParams add_var_masses
#' @inheritParams distri_peps
subpeps_by_vmods <- function(aa_masses, prps, motifs = NULL) 
{
  vmods <- attr(aa_masses, "vmods_ps", exact = TRUE) 
  min_n_res <- attr(aa_masses, "min_n_res", exact = TRUE)
  is_same <- attr(aa_masses, "is_same", exact = TRUE)
  
  excepts <- attr(aa_masses, "anywhere_excepts", exact = TRUE)

  if (is.list(vmods)) {
    vmods <- unname(vmods)
    vmods <- .Internal(unlist(vmods, recursive = FALSE, use.names = TRUE))
  }
  
  if (is_same) 
    vmods <- vmods[!duplicated.default(vmods)]

  posns <- names(vmods)
  len <- length(vmods)

  # don't change the order: nomdtree -> cmodtree
  prps <- find_nmodtree(prps, excepts, min_n_res, vmods, posns, len, motifs)
  prps <- find_cmodtree(prps, excepts, min_n_res, vmods, posns, len, motifs)
}


### Also in proteoQ

#' Reads a file in fasta format
#'
#' Reads a file in fasta format by line.
#'
#' @param file A character string to the name of a protein fasta file.
#' @param acc_pattern A regular expression describing the pattern to separate
#'   the header lines of fasta entries. The default is to separate a header and
#'   keep the character string before the first space where the so kept will be
#'   used as the name of an entry. The character ">" at the beginning of the
#'   header will also be removed.
#' @param comment_char Character: a character or an empty string. Use "" to turn
#'   off the interpretation of comment lines.
#' @examples
#' \dontrun{
#' # assume the file and location of "uniprot_hs_2020_05.fasta"
#' fasta <- read_fasta("~/mzion/dbs/fasta/uniprot/uniprot_hs_2020_05.fasta")
#' head(names(fasta))
#'
#' # use the first fifty characters
#' fasta <- read_fasta("~/mzion/dbs/fasta/uniprot/uniprot_hs_2020_05.fasta",
#'                     ">(.{50}).*")
#' head(names(fasta))
#'
#' # uniprot_acc
#' fasta <- read_fasta("~/mzion/dbs/fasta/uniprot/uniprot_hs_2020_05.fasta",
#'                     ">..\\|([^\\|]+)\\|.*")
#' head(names(fasta))
#'
#' # use all characters in the header
#' fasta <- read_fasta("~/mzion/dbs/fasta/uniprot/uniprot_hs_2020_05.fasta",
#'                     ">(.*)")
#' head(names(fasta))
#' }
#'
#' @seealso \code{\link{write_fasta}}
#' @export
read_fasta <- function (file = NULL, acc_pattern = ">([^ ]+?) .*", 
                        comment_char = "") 
{
  lines   <- readLines(file)
  empties <- grep("^\\s*$", lines)
  
  if (length(empties)) 
    lines <- lines[-empties]

  # removes comment lines
  if (nchar(comment_char)) 
    lines <- lines[!grepl(paste0("^", comment_char), lines)]

  # begins and ends
  headers <- grep(">", lines)
  begins  <- headers + 1L
  ends <- c(headers[-1L] - 1L, length(lines))

  seqs <- mapply(function (x, y) {
    Reduce(paste0, lines[x : y])
  }, begins, ends, SIMPLIFY = FALSE, USE.NAMES = FALSE)
  
  hdrs <- lines[headers]

  db <- mapply(function (x, y) {
    attr(x, "header") <- y
    x
  }, seqs, hdrs, SIMPLIFY = FALSE, USE.NAMES = FALSE)
  
  names(db) <- gsub(acc_pattern, "\\1", hdrs)
  
  invisible(db)
}


#' Writes fasta
#'
#' Writes a fasta file (Not yet used).
#'
#' @param fasta_db A list of protein entries from \code{\link{read_fasta}}.
#' @inheritParams read_fasta
#' @examples
#' \dontrun{
#' fasta_db <- read_fasta(file = "~/mzion/dbs/fasta/uniprot/uniprot_hs_2020_05.fasta")
#' write_fasta(fasta_db, "~/mzion/examples/my.fasta")
#' }
write_fasta <- function (fasta_db, file) 
{
  filepath <- gsub("(^.*/).*$", "\\1", file)
  dir.create(filepath, showWarnings = FALSE, recursive = TRUE)
  
  res <- lapply(fasta_db, function (x) paste(attr(x, "header"), x, sep = "\n"))
  res <- unlist(res)
  writeLines(res, file)
}


#' Loads fasta
#' 
#' Not used in mzion.
#'
#' @param fasta Character string(s) to the name(s) of fasta file(s) with
#'   prepended directory path. There is no default and the experimenters need to
#'   supply the files.
#' @examples
#' \dontrun{
#' fasta_db <- load_fasta("~/mzion/dbs/fasta/uniprot/uniprot_hs_2020_05.fasta")
#' }
load_fasta <- function (fasta = NULL) 
{
  if (is.null(fasta)) 
    stop("FASTA file(s) are required.")
  
  oks <- file.exists(fasta)

  if (!all(oks))
    stop("Missing FASTA file(s): \n", paste(fasta[!oks], collapse = "\n"))

  ans <- lapply(fasta, function (x) read_fasta(x))
  ans <- flatten_list(ans)
  names(ans) <- gsub(">", "", names(ans))
  ans <- ans[!duplicated(names(ans))]
}

### End of also in proteoQ




#' Loads fasta (with parsing rule).
#'
#' The length of \code{acc_type} needs to match the length of \code{fasta};
#' otherwise, the first value will be used for all \code{fasta} files.
#' 
#' @param acc_type Character string(s); the types of protein accessions in one
#'   of c("uniprot_acc", "uniprot_id", "refseq_acc", "other"). For custom names,
#'   the corresponding regular expressions need to be supplied via argument
#'   \code{acc_pattern}.
#' @param acc_pattern Regular expression(s) describing the patterns to separate
#'   the header lines of fasta entries. At the \code{NULL} default, the pattern
#'   will be automated when \code{acc_type} are among c("uniprot_acc",
#'   "uniprot_id", "refseq_acc", "other").
#' @inheritParams matchMS
#' @examples
#' \dontrun{
#' fasta_db <- load_fasta2(
#'               c("~/mzion/dbs/fasta/uniprot/uniprot_hs_2020_05.fasta",
#'                 "~/mzion/dbs/fasta/crap/crap.fasta"),
#'               c("uniprot_acc", "other"))
#'
#' # Need `acc_pattern` as "crap" is not one of the default acc_type
#' load_fasta2(
#'    c("~/mzion/dbs/fasta/uniprot/uniprot_hs_2020_05.fasta",
#'      "~/mzion/dbs/fasta/crap/crap.fasta"),
#'    c("uniprot_acc", "crap"))
#'
#' # ok
#' fasta_db2 <- load_fasta2(
#'                c("~/mzion/dbs/fasta/uniprot/uniprot_hs_2020_05.fasta",
#'                  "~/mzion/dbs/fasta/crap/crap.fasta"),
#'                c("uniprot_acc", "crap"),
#'                c("^>..\\|([^\\|]+)\\|[^\\|]+", "(.*)"))
#'
#' fasta_db3 <- load_fasta2(
#'                c("~/mzion/dbs/fasta/uniprot/uniprot_hs_2020_05.fasta",
#'                  "~/mzion/dbs/fasta/crap/crap.fasta"),
#'                c("my_acc", "crap"),
#'                c("^>..\\|([^\\|]+)\\|[^\\|]+", "(.*)"))
#'
#' stopifnot(identical(fasta_db, fasta_db2),
#'           identical(fasta_db, fasta_db3))
#' }
#' @export
load_fasta2 <- function (fasta = NULL, acc_type = NULL, acc_pattern = NULL) 
{
  if (is.null(fasta)) 
    stop("FASTA file(s) are required.")

  oks <- file.exists(fasta)
  
  if (!all(oks)) {
    warning("Removed missing FASTA file(s): \n", paste(fasta[!oks], collapse = "\n"))
    fasta <- fasta[oks]
    acc_type <- acc_type[oks]
  }
  
  len_f <- length(fasta)
  len_a <- length(acc_type)
  len_p <- length(acc_pattern)
  
  if (!len_f)
    stop("None of the supplied fasta files were found.")

  if (len_f < len_a) 
    stop("More accession types than fasta files.")

  if (len_f < len_p) 
    stop("More acc_pattern types than fasta files.")

  if (len_a && (len_a < len_f)) {
    warning("More fasta files than accession types; ",
            "the first accession type will be used for all fastas.")
    acc_type <- rep(acc_type[1], len_f)
  }

  if (len_p && (len_p < len_f)) {
    warning("More fasta files than acc_pattern expressions; ",
            "the first acc_pattern expression will be used for all fastas.")
    acc_pattern <- rep(acc_pattern[1], len_f)
  }

  if (!(is.null(acc_type) || is.null(acc_pattern))) {
    acc_type <- acc_type
    acc_pattern <- acc_pattern
  } 
  else if (is.null(acc_type) && is.null(acc_pattern)) {
    acc_type <- rep("other", len_f)
    acc_pattern <- rep("(.*)", len_f)
  } 
  else if (!is.null(acc_type)) {
    acc_pattern <- lapply(acc_type, find_acc_pattern)
    acc_pattern <- unlist(acc_pattern, recursive = FALSE, use.names = FALSE)
  } 
  else {
    acc_type <- lapply(acc_pattern, find_acc_type)
    acc_type <- unlist(acc_type, recursive = FALSE, use.names = FALSE)
  }

  if (length(acc_pattern) != len_f)
    stop("Unequal length between `acc_pattern` and `fasta`.")
  
  # Not to USE.NAMES; otherwise fasta names prefix to accession names
  # this is different to map2 where names are NULL for each fasta_db
  ans <- mapply(function (x, y) read_fasta(x, y), fasta, acc_pattern, 
                SIMPLIFY = FALSE, USE.NAMES = FALSE)
  ans <- flatten_list(ans)
  names(ans) <- gsub(">", "", names(ans))
  ans <- ans[!duplicated(names(ans))]
}


#' Helper for \link{load_fasta2}.
#'
#' Not used for custom acc_type, i.e. acc_type = "my_acctype".
#'
#' @inheritParams load_fasta2
find_acc_pattern <- function (acc_type) 
{
  if (length(acc_type) != 1L)
    stop("The length of `acc_type` is not one.")
  
  oks <- c("uniprot_acc", "uniprot_id", "refseq_acc", "other")
  
  if (!acc_type %in% oks)
    stop("`acc_type` is not one of ", paste(oks, collapse = ", "))

  if (acc_type == "uniprot_acc")
    "^>..\\|([^\\|]+)\\|[^\\|]+"
  else if (acc_type == "uniprot_id")
    "^>..\\|[^\\|]+\\|([^ ]+) .*"
  else if (acc_type == "refseq_acc")
    "^>([^ ]+?) .*"
  else if (acc_type == "other")
    "(.*)"
  else
    stop("Unknown `acc_type`.")
}


#' Helper for \link{load_fasta2}.
#'
#' Not used for custom acc_pattern, i.e. acc_pattern = "...".
#'
#' @inheritParams load_fasta2
find_acc_type <- function (acc_pattern) 
{
  if (length(acc_pattern) != 1L)
    stop("The length of `acc_pattern` is not one.")
  
  oks <- c("pat_upacc", "pat_upid", "pat_rsacc", "pat_other")
  
  if (!acc_pattern %in% oks)
    stop("`acc_pattern` is not one of ", paste(oks, collapse = ", "))

  pat_upacc <- "^>..\\|([^\\|]+)\\|[^ ]+?"
  pat_upid <- "^>..\\|[^\\|]+\\|([^ ]+?)"
  pat_rsacc <- "^>([^ ]+?) "
  pat_other <- "(.*)"

  if (acc_pattern == pat_upacc)
    "uniprot_acc"
  else if (acc_pattern == pat_upid)
    "uniprot_id"
  else if (acc_pattern == pat_rsacc)
    "refseq_acc"
  else if (acc_pattern == pat_other)
    "other"
  else
    stop("Unknown `acc_pattern`.")
}


# $bin_masses.R
# [1] "bin_ms1masses"      "binTheoSeqs_i"      "binTheoSeqs2"       "bin_theoseqs"       "binTheoSeqs"        "find_ms1_cutpoints"
# [7] "s_readRDS"          "set_bin_ncores"    
# 
# $deisotope.R
# [1] "find_ms1stat"      "find_charge_state" "check_chduo"       "is_true"           "find_dbl_z"        "find_lcpeaks"     
# [7] "sep_ms1rts"        "bin_ms1rts"        "gen_isoenvlope"   
# 
# $dispatch.R
#  [1] "find_pos_site"       "contain_pos_site"    "contain_termpos_any" "subset_by_prps"      "subset_protntsite"   "subset_protntany"   
#  [7] "subset_anyntsite"    "subset_anyntany"     "subset_anysite"      "subset_protctsite"   "subset_protctany"    "subset_anyctsite"   
# [13] "subset_anyctany"     "find_nmodtree"       "find_cmodtree"       "subpeps_by_vmods"   
# 
# $fastas.R
# [1] "read_fasta"       "write_fasta"      "load_fasta"       "load_fasta2"      "find_acc_pattern" "find_acc_type"   
# 
# $funs.R
# character(0)
# 
# $ion_ladder.R
#  [1] "ms2ions_by_type" "byions"          "czions"          "axions"          "bions_base"      "yions_base"      "cions_base"     
#  [8] "zions_base"      "c2ions"          "z2ions"          "aions_base"      "xions_base"      "a2ions"          "astarions"      
# [15] "astar2ions"      "a0ions"          "a02ions"         "x2ions"         
# 
# $lfq.R
# [1] "subMSfull"     "pretraceXY"    "htraceXY"      "traceXY"       "updateMS1Int"  "updateMS1Int2" "traceMS1"      "getMS1Int"    
# 
# $mapMS2ions.R
#  [1] "mapMS2ions"         "plotMS2ions"        "match_mgf_path"     "match_raw_id"       "add_raw_ids"        "find_secion_types" 
#  [7] "find_mgf_query"     "make_speclib"       "get_mzion_coltypes" "check_ggname"      
# 
# $mgfs.R
#  [1] "load_mgfs"          "readMGF"            "post_readmgf"       "readlineMGFs"       "  f"                "read_mgf_chunks"   
#  [7] "proc_mgf_chunks"    "proc_mgfs"          "reset_rettimes"     "sub_mgftopn"        "integerize_ms2ints" "extract_mgf_rptrs" 
# [13] "index_mz"           "find_mgf_type"      "prepBrukerMGF"      "mprepBrukerMGF"    
# 
# $ms1_precursors.R
#  [1] "calc_pepmasses2"           "find_aa_masses"            "find_motif_pat"            "simple_prots_peps"        
#  [5] "flat_pepseqs"              "find_aa_site"              "calc_aamasses"             "finalize_aamasses"        
#  [9] "save_mod_indexes"          "check_dupfvmods"           "coerce_fvmods"             "find_f_to_v"              
# [13] "check_mod_motifs"          "find_aamasses_vmodscombi"  "add_var_masses"            "add_fixed_masses"         
# [17] "find_except_sites"         "find_modps"                "extract_umods"             "check_resunimod"          
# [21] "check_fmods_pos_site"      "check_dup_term_any"        "add_aamasses_neulosses"    "add_aamasses_motifs"      
# [25] "parse_aamasses"            "split_fastaseqs"           "make_fastapeps0"           "split_fastaseqs_noenz"    
# [29] "mmake_noenzpeps"           "make_noenzpeps"            "hmake_noenzpeps"           "ms1masses_bare_noenz"     
# [33] "keep_n_misses"             "exclude_n_misses"          "str_exclude_count"         "rm_char_in_nfirst"        
# [37] "rm_char_in_nlast"          "adj_base_masses"           "adj_anywhere_masses"       "add_term_mass"            
# [41] "ms1masses_bare"            "add_ms1_13c"               "add_ms1_notches"           "ms1masses_noterm"         
# [45] "calcms1mass_noterm"        "calcms1mass_noterm_byprot" "calcms1mass_noterm_bypep"  "distri_peps"              
# [49] "ct_counts"                 "distri_fpeps"              "roll_sum"                  "hsemipeps_byprots"        
# [53] "semipeps_byprots"          "calc_semipepmasses"        "delta_ms1_a0_fnl1"         "hms1_a0_vnl0_fnl1"        
# [57] "ms1_a0_vnl0_fnl1"          "hms1_a1_vnl0_fnl0"         "ms1_a1_vnl0_fnl0"         
# 
# $ms2_gen.R
# [1] "gen_ms2ions_base"          "gen_ms2ions_a0_vnl0_fnl1"  "gen_ms2ions_a1_vnl0_fnl0"  "calc_ms2ions_a1_vnl0_fnl0"
# [5] "check_ms1_mass_vmods"      "gen_ms2ions_a1_vnl0_fnl1"  "calc_ms2ions_a1_vnl0_fnl1" "gen_ms2ions_a1_vnl1_fnl0" 
# [9] "calc_ms2ions_a1_vnl1_fnl0"
# 
# $ms2frames.R
#  [1] "pair_mgftheos"  "hpair_mgths"    "make_dia_mgfs"  "hms2match"      "ms2match_all"   "mframes_adv"    "find_ms2_bypep"
#  [8] "search_mgf"     "hms2match_one"  "ms2match_one"   "frames_adv"    
# 
# $msfilereader.R
# [1] "readRAW"                   "proc_raws"                 "exeReadRAW"                "acceptMSFileReaderLicense"
# 
# $msmsmatches.R
#  [1] "matchMS"            "try_psmC2Q"         "reproc_psmC"        "psmC2Q"             "post_psmC2Q"        "check_tmt_pars"    
#  [7] "checkMGF"           "check_locmods"      "map_raw_n_scan"     "map_raw_n_scan_old" "check_fdr_group"    "check_notches"     
# 
# $msmsmatches2.R
# [1] "ms2match"              "reverse_peps_in_frame" "reverse_seqs"          "calib_mgf"             "calib_ms1"            
# [6] "cv_ms1err"             "post_calib"            "find_ms1_offsets"      "comb_ms1_offsets"     
# 
# $mzion.R
# character(0)
# 
# $mzml.R
#  [1] "readmzML"          "hloadMZML"         "loadMZML"          "extrDDA"           "hdeisoDDA"         "deisoDDA"         
#  [7] "getMSrowIndexes"   "find_ms2ends"      "getMS1xyz"         "getMS2xyz"         "extrDIA"           "hdeisoDIA"        
# [13] "deisoDIA"          "hsubDIAMS1"        "subDIAMS1"         "htraceDIA"         "traceDIA"          "flattenMSxyz"     
# [19] "spreadMSohw"       "spreadMS_v1"       "comb_mstraces"     "find_gates"        "find_gate_edges"   "traceLCMS"        
# [25] "collapse_xyz"      "mapcoll_xyz"       "find_lc_gates"     "fill_lc_gaps"      "collapse_mms1ints" "calc_ms1xys"      
# [31] "find_mdda_mms1s"   "find_ms1byms2"    
# 
# $mztab.R
# [1] "make_mztab"
# 
# $percolator.R
# [1] "create_folds" "cv_svm"       "perco_svm"   
# 
# $quant2.R
#  [1] "hcalc_tmtint"       "calc_tmtint"        "add_rptrs"          "find_int_cols"      "find_reporter_ints" "find_reporters_ppm"
#  [7] "msub_protpep"       "sub_protpep"        "add_protacc2"       "add_protacc"        "hannot_decoys"      "groupProts"        
# [13] "map_pepprot"        "collapse_sortpeps"  "pcollapse_sortpeps" "find_group_breaks"  "cut_proteinGroups"  "sparseD_fourquad"  
# [19] "as_dist"            "greedysetcover3"   
# 
# $roadmaps.R
# character(0)
# 
# $scores.R
#  [1] "add_seions"             "list_leftmatch"         "calc_probi_byvmods"     "calc_probi_bypep"       "calc_probi"            
#  [6] "scalc_pepprobs"         "calc_pepprobs_i"        "calc_pepscores"         "split_im"               "order_fracs"           
# [11] "order_fracs3"           "combine_fracs"          "move_scfiles"           "find_decoy"             "find_targets"          
# [16] "calcpepsc"              "find_iexunv"            "addChim"                "hadd_primatches"        "add_primatches"        
# [21] "collapse_vecs"          "post_pepscores"         "find_pepscore_co1"      "find_pepscore_co2"      "probco_bypeplen"       
# [26] "sub_td_byfdrtype"       "find_optlens"           "find_probco_valley"     "prep_pepfdr_td"         "keep_pepfdr_best"      
# [31] "calc_pepfdr"            "fill_probco_nas"        "find_fdr_fits"          "fill_probs"             "post_pepfdr"           
# [36] "calc_protfdr"           "aggr_prot_es"           "calc_protfdr_i"         "fit_protfdr"            "  f"                   
# [41] "find_ppm_outer_bycombi" "match_ex2th2"           "calc_peploc"            "calcpeprank_1"          "calcpeprank_2"         
# [46] "calcpeprank_3"          "find_bestnotch"         "find_chunkbreaks"       "findLocFracsDF"         "concatFracs"           
# [51] "na.interp"              "is.constant"            "tsoutliers"             "rm_dup13c"             
# 
# $silac.R
# [1] "matchMS_silac_mix"   "matchMS_par_groups"  "add_fixedlab_masses" "matchMS_noenzyme"    "combine_ion_matches" "comine_PSMsubs"     
# [7] "matchMS_ms1calib"   
# 
# $unimods.R
#  [1] "parse_unimod"             "find_unimod"              "hfind_unimod"             "table_unimods"           
#  [5] "htable_unimods"           "add_unimod"               "add_modification"         "add_specificy"           
#  [9] "add_delta"                "add_neuloss"              "hadd_neuloss"             "add_comp_elements"       
# [13] "remove_unimod"            "standardize_unimod_ps"    "remove_unimod_title"      "calc_unimod_compmass"    
# [17] "parse_unimod_composition"
# 
# $utils_engine.R
#  [1] "which_topx"            "which_topx2"           "get_topn_vals"         "insVal"                "topx"                 
#  [6] "find_ppm_error"        "find_mass_error_range" "`%+%`"                 "`%+%`"                 "post_frame_adv"       
# [11] "subset_theoframes"     "subset_neuloss_peps"   "find_nterm_mass"       "find_cterm_mass"       "quick_rightjoin"      
# [16] "quick_leftjoin"        "detect_cores"          "find_free_mem"         "find_mod_indexes"      "is_equal_sets"        
# [21] "expand_grid_rows"      "expand_grid"           "expand_gr"             "expand_grid_rows0"     "count_elements"       
# [26] "vec_to_list"           "split_matrix"          "split_vec"             "fold_vec"              "fold_vec2"            
# [31] "sep_vec"               "rep_vec"               "accumulate_char"       "combi_mat"             "make_zero_df"         
# [36] "calc_threeframe_ppm"   "get_ms1charges"        "finds_uniq_vec"        "my_dataframe"          "flatten_list"         
# [41] "calc_rev_ms2"          "bind_dfs"              "find_min_ncores"      
# 
# $utils_os.R
#  [1] "`names_pos<-`"          "ins_cols_after"         "add_cols_at"            "replace_cols_at"        "reloc_col_after"       
#  [6] "reloc_col_after_last"   "reloc_col_after_first"  "reloc_col_before"       "reloc_col_before_last"  "reloc_col_before_first"
# [11] "find_preceding_colnm"   "recur_flatten"          "chunksplit"             "chunksplitLB"           "find_dir"              
# [16] "create_dir"             "save_call2"             "find_callarg_vals"      "match_calltime"         "delete_files"          
# [21] "find_ms1_times"         "is_nulllist"            "add_nulllist"          
# 
# $utils_ui.R
# [1] "calc_monopeptide"  "calc_monopep"      "check_aaseq"       "calc_ms2ionseries" "calc_ms2ions"      "unique_mvmods"    
# [7] "vmods_elements"    "find_intercombi"  
# 
# $vmod_ms1_labels.R
#  [1] "match_mvmods"      "make_ms1vmod_i"    "make_ms1_vmodsets" "bacth_vmods_combi" "make_unique_sets"  "find_unique_sets" 
#  [7] "gtools_combn"      "    sub"           "  else sub"        "find_intercombi2" 
# 
# $vmod_ms2_labels.R
# [1] "find_vmodposU"   "find_vmodposM"   "make_ms2vmods"   "find_ms2resids"  "find_perm_sets"  "add_one_permlab" "add_one_label"  
# [8] "ins_permlab"     "sim_combn"      
# 
# $wrappers.R
# [1] "my_dist"       "cos_sim"       "matchMS_NES"   "rematchMS_NES"
# 
# $zzz.R
# [1] ".onAttach"
# 
#' Helper: switches among ion types for calculating MS2 masses.
#'
#' @param aam A sequence of amino-acid residues with \emph{masses}. Residues
#'   are in names and masses in values (note that argument \code{aas}
#'   corresponds to residues without masses).
#' @param ntmass The mass of a fixed or variable N-term modification.
#' @param ctmass The mass of a fixed or variable C-term modification.
#' @inheritParams matchMS
ms2ions_by_type <- function (aam, ntmass, ctmass, type_ms2ions = "by") 
{
  switch(type_ms2ions, 
         by = byions(ntmass = ntmass, ctmass = ctmass, aam = aam), 
         cz = czions(ntmass = ntmass, ctmass = ctmass, aam = aam), 
         ax = axions(ntmass = ntmass, ctmass = ctmass, aam = aam), 
         stop("Unknown type.", call. = FALSE))
}


#' Masses of singly-charged b- and y-ions.
#' 
#' b-ions first, then y-ions
#' 
#' @rdname bions_base
byions <- function (ntmass, ctmass, aam) 
  c(cumsum(c(ntmass, aam))[-1], cumsum(c(ctmass, aam[length(aam):1L]))[-1])


#' Masses of singly-charged c- and z-ions.
#'
#' @rdname bions_base
czions <- function (ntmass, ctmass, aam)
  c(cumsum(c(ntmass + 17.026549, aam))[-1], 
    cumsum(c(ctmass - 17.026549, aam[length(aam):1L]))[-1])


#' Masses of singly-charged a- and x-ions.
#'
#' @rdname bions_base
axions <- function (ntmass, ctmass, aam) 
  c(cumsum(c(ntmass - 27.9949146, aam))[-1], 
    cumsum(c(ctmass + 25.9792646, aam[length(aam):1L]))[-1])


###
# No direct uses of the followings.
###

#' B-ions.
#'
#' For (1) "amods- tmod- vnl- fnl-", (2) "amods- tmod+ vnl- fnl-".
#'
#' @param aam A sequence of amino-acid residues with \emph{masses}. Residues
#'   are in names and masses in values.
#'
#'   The masses reflects fixed/variable modifications, and/or fixed/variable
#'   neutral losses.
#'   
#' @param ntmass The mass of a fixed or variable N-term modification.
#'
#' @importFrom stringr str_split
#' @examples
#' \donttest{
#' library(mzion)
#' library(stringr)
#' 
#' ## (1) "amods- tmod- vnl- fnl-"
#' # (Fixed N-term mods; also for no N-term mod)
#'
#' fixedmods <- c("TMT6plex (N-term)", "TMT6plex (K)", "Carbamidomethyl (C)")
#' varmods <- c("Oxidation (M)", "Deamidated (N)")
#'
#' aa_masses_all <- calc_aamasses(fixedmods, varmods)
#'
#' aa_masses <- aa_masses_all[[1]]
#'
#' ntmod <- attr(aa_masses, "ntmod", exact = TRUE)
#' ctmod <- attr(aa_masses, "ctmod", exact = TRUE)
#'
#' if (!length(ntmod)) {
#'   ntmass <- aa_masses["N-term"] - 0.000549 # - electron
#' } else {
#'   ntmass <- aa_masses[names(ntmod)] - 0.000549
#' }
#'
#' if (!length(ctmod)) {
#'   ctmass <- aa_masses["C-term"] + 2.01510147 # + (H) + (H+)
#' } else {
#'   ctmass <- aa_masses[names(ctmod)] + 2.01510147
#' }
#'
#' aa_seq <- "MAKEMASSPECFUN"
#' aas <- stringr::str_split(aa_seq, "", simplify = TRUE)
#' aam <- aa_masses[aas]
#'
#' b <- mzion:::bions_base(aam, ntmass)
#' y <- mzion:::yions_base(aam, ctmass)
#'
#'
#' ## (2) "amods- tmod+ vnl- fnl-"
#' # (2a, N-term)
#' fixedmods <- c("TMT6plex (K)", "Carbamidomethyl (C)")
#' varmods <- c("TMT6plex (N-term)", "Acetyl (Protein N-term)", "Oxidation (M)",
#'              "Deamidated (N)", "Gln->pyro-Glu (N-term = Q)")
#'
#' aa_masses_all <- calc_aamasses(fixedmods, varmods)
#'
#' aa_masses <- aa_masses_all[[3]]
#'
#' # (Fixed or variable C-term mods +/- makes no difference on b-ions;
#' # and vice versa for y-ions)
#' ntmod <- attr(aa_masses, "ntmod", exact = TRUE)
#' ctmod <- attr(aa_masses, "ctmod", exact = TRUE)
#'
#' if (!length(ntmod)) {
#'   ntmass <- aa_masses["N-term"] - 0.000549
#' } else {
#'   ntmass <- aa_masses[names(ntmod)] - 0.000549
#' }
#'
#' if (!length(ctmod)) {
#'   ctmass <- aa_masses["C-term"] + 2.01510147
#' } else {
#'   ctmass <- aa_masses[names(ctmod)] + 2.01510147
#' }
#'
#' aa_seq <- "MAKEMASSPECFUN"
#' aas <- stringr::str_split(aa_seq, "", simplify = TRUE)
#' aam <- aa_masses[aas]
#'
#' b <- mzion:::bions_base(aam, ntmass)
#' y <- mzion:::yions_base(aam, ctmass)
#'
#'
#' # (2b, C-term)
#' fixedmods <- c("TMT6plex (K)", "Carbamidomethyl (C)")
#' varmods <- c("TMT6plex (N-term)", "Amidated (Protein C-term)", "Oxidation (M)",
#'              "Deamidated (N)", "Gln->pyro-Glu (N-term = Q)")
#'
#' aa_masses_all <- calc_aamasses(fixedmods, varmods)
#'
#' # `TMT6plex (N-term)`; `Amidated (Protein C-term)`
#' aa_masses <- aa_masses_all[[7]]
#'
#' ntmod <- attr(aa_masses, "ntmod", exact = TRUE)
#' ctmod <- attr(aa_masses, "ctmod", exact = TRUE)
#'
#' if (!length(ntmod)) {
#'   ntmass <- aa_masses["N-term"] - 0.000549
#' } else {
#'   ntmass <- aa_masses[names(ntmod)] - 0.000549
#' }
#'
#' if (!length(ctmod)) {
#'   ctmass <- aa_masses["C-term"] + 2.01510147
#' } else {
#'   ctmass <- aa_masses[names(ctmod)] + 2.01510147
#' }
#'
#' b <- mzion:::bions_base(aam, ntmass)
#' y <- mzion:::yions_base(aam, ctmass)
#' }
bions_base <- function (aam, ntmass) cumsum(c(ntmass, aam))[-1]


#' Y-ions.
#' 
#' # (1) OH (C-term), + H (neutralizes the N-term on a fragment) + H+ 
#' # (2) Other C-term (other than OH) + H + H+: X + 1.007825 + 1.00727647
#' 
#' @param ctmass The mass of a fixed or variable C-term modification.
#' @rdname bions_base
yions_base <- function (aam, ctmass) cumsum(c(ctmass, aam[length(aam):1L]))[-1]


#' C-ions.
#' 
#' \code{NH3 = 17.026549}
#' 
#' @rdname bions_base
cions_base <- function (aam, ntmass) cumsum(c(ntmass + 17.026549, aam))[-1]


#' Z-ions.
#' 
#' @rdname bions_base
zions_base <- function (aam, ctmass) 
  cumsum(c(ctmass - 17.026549, aam[length(aam):1L]))[-1]


#' C2-ions.
#' 
#' @param n The charge state.
#' @rdname bions_base
c2ions <- function (aam, ntmass, n = 2L) (cions_base(aam, ntmass) + 1.00727647)/n


#' Z2-ions.
#' 
#' @param n The charge state.
#' @rdname bions_base
z2ions <- function (aam, ctmass, n = 2L) (zions_base(aam, ctmass) + 1.00727647)/n


#' A-ions.
#' 
#' \code{CO = 27.9949146}

#' @rdname bions_base
aions_base <- function (aam, ntmass) cumsum(c(ntmass - 27.9949146, aam))[-1]


#' X-ions.
#' 
#' \code{+CO -H2 = 27.9949146 - 2 * 1.007825}
#' 
#' @rdname bions_base
xions_base <- function (aam, ctmass) 
  cumsum(c(ctmass + 25.9792646, aam[length(aam):1L]))[-1]


#' A2-ions.
#' 
#' @param n The charge state.
#' @rdname bions_base
a2ions <- function (aam, ntmass, n = 2L) (aions_base(aam, ntmass) + 1.00727647)/n


#' A*-ions.
#' 
#' \code{-CO -NH3 = -(27.9949146 + 17.026549)}
#' 
#' @rdname bions_base
astarions <- function (aam, ntmass) cumsum(c(ntmass - 45.0214636, aam))[-1]


#' A*2-ions.
#' 
#' @param n The charge state.
#' @rdname bions_base
astar2ions <- function (aam, ntmass, n = 2L) (astarions(aam, ntmass) + 1.00727647)/n


#' A0-ions.
#' 
#' \code{-CO -H2O = -(27.9949146 + 18.010565)}
#' 
#' @rdname bions_base
a0ions <- function (aam, ntmass) cumsum(c(ntmass - 46.0054796, aam))[-1]


#' A02-ions.
#' 
#' @param n The charge state.
#' @rdname bions_base
a02ions <- function (aam, ntmass, n = 2L) (a0ions(aam, ntmass) + 1.00727647)/n


#' X2-ions.
#' 
#' @param n The charge state.
#' @rdname bions_base
x2ions <- function (aam, ctmass, n = 2L) (xions_base(aam, ctmass) + 1.00727647)/n


#' Subsets full MS by the universe of monoisotopic moverzs.
#'
#' Some non-monoisotopic moverzs can be removed.
#'
#' @param xs Vectors of full-spectrum m/z values.
#' @param ys Vectors of full-spectrum intensity values.
#' @param ms1s Vectors of MS2-specific MS1 m/z values (corresponding to
#'   \code{ms_level == 2L}).
#' @param from The starting m/z value for calculating bin indexes.
#' @param step The size of bins.
#' @param gap The gap of MS1 scans.
#' @importFrom fastmatch %fin%
subMSfull <- function (xs, ys, ms1s, from = 200L, step = 1E-5, gap = 256L)
{
  lens <- lengths(xs)
  len <- length(xs)
  yout <- xout <- vector("list", len)

  # for each xi, keeps entries found in ms1s.
  if (gap >= len) {
    ms1s <- .Internal(unlist(ms1s, recursive = FALSE, use.names = FALSE))
    ms1s <- index_mz(ms1s, from, step)
    ms1s <- sort(unique(ms1s))

    for (i in 1:len) {
      xi <- xs[[i]]
      li <- lens[[i]]
      
      if (!li)
        next
      
      ix <- as.integer(ceiling(log(xi/from)/log(1+step)))
      ps0 <- fastmatch::fmatch(ix, ms1s)
      ps1 <- fastmatch::fmatch(ix + 1L, ms1s)
      ps2 <- fastmatch::fmatch(ix - 1L, ms1s)
      i0 <- .Internal(which(!is.na(ps0)))
      i1 <- .Internal(which(!is.na(ps1)))
      i2 <- .Internal(which(!is.na(ps2)))
      
      i1 <- i1[!i1 %fin% i0]
      i2 <- i2[!(i2 %fin% i0 | i2 %fin% i1)]
      i012 <- c(i0, i1, i2)
      i012 <- sort(i012)
      xout[[i]] <- xi[i012]
      yout[[i]] <- ys[[i]][i012]
    }
  }
  else {
    for (i in 1:len) {
      xi <- xs[[i]]
      li <- lens[[i]]
      
      if (!li)
        next
      
      sta <- max(1, i - gap)
      end <- min(i + gap, len)
      ms1s_sub <- .Internal(unlist(ms1s[sta:end], recursive = FALSE, use.names = FALSE))
      ms1s_sub <- index_mz(ms1s_sub, from, step)
      ms1s_sub <- sort(unique(ms1s_sub))
      
      ix <- as.integer(ceiling(log(xi/from)/log(1+step)))
      ps0 <- fastmatch::fmatch(ix, ms1s_sub)
      ps1 <- fastmatch::fmatch(ix + 1L, ms1s_sub)
      ps2 <- fastmatch::fmatch(ix - 1L, ms1s_sub)
      i0 <- .Internal(which(!is.na(ps0)))
      i1 <- .Internal(which(!is.na(ps1)))
      i2 <- .Internal(which(!is.na(ps2)))
      
      i1 <- i1[!i1 %fin% i0]
      i2 <- i2[!(i2 %fin% i0 | i2 %fin% i1)]
      i012 <- c(i0, i1, i2)
      i012 <- sort(i012) # logical(0) if all NA
      xout[[i]] <- xi[i012]
      yout[[i]] <- ys[[i]][i012]
    }
  }

  list(x = xout, y = yout)
}


#' Splits \code{df} for parallel tracing.
#' 
#' @param df A data frame of staggering MS1 and MS2 entries.
#' @param from The starting point for mass binning.
#' @param step The step size for mass binning.
#' @param n_chunks The number of chunks.
#' @param gap A gap size for forward and backward looking of precursors.
pretraceXY <- function (df, from = 200L, step = 1e-5, n_chunks = 4L, gap = 256L)
{
  # msx_moverzs at ms_level == 1L: full-spectrum ms1_moverzs
  # msx_charges at ms_level == 1L are list(NULL)
  
  cols1 <- c("ms1_mass", "ms1_moverz", "ms1_int", "ms1_charge", 
             "msx_moverzs", "msx_ints", "msx_charges", "orig_scan")
  rows1 <- df[["ms_level"]] == 1L
  df1 <- df[rows1, cols1]
  len1 <- nrow(df1)

  # Remove non-essential MS1 x and y values
  ans <- subMSfull(
    xs = df1$msx_moverzs, ys = df1$msx_ints, ms1s = df1$ms1_moverz, 
    from = from, step = step, gap = gap)
  
  df1$msx_moverzs <- ans$x # moverzs in ans$x are sorted
  df1$msx_ints <- ans$y
  rm(list = "ans")
  gc()
  
  # at least two chunks
  if (n_chunks <= 1L)
    n_chunks <- 2L
  
  df1s <- chunksplit(df1, n_chunks, type = "row")
  end1s <- cumsum(lapply(df1s, nrow))
  sta1s <- c(1L, end1s[1:(n_chunks-1L)] + 1L)
  
  # Adds 2-min gaps before and after
  gaps <- lapply(df1s, function (x) ceiling(min(gap, nrow(x)/2L)))
  df1s_bf <- df1s_af <- vector("list", n_chunks)
  
  for (i in 2:n_chunks) {
    df1s_bf[[i]] <- head(df1s[[i]], gaps[[i]])
  }
  
  for (i in 1:(n_chunks - 1L)) {
    df1s_af[[i]] <- tail(df1s[[i]], gaps[[i]])
  }
  
  df1s[[1]] <- dplyr::bind_rows(df1s[[1]], df1s_bf[[2]])
  df1s[[n_chunks]] <- dplyr::bind_rows(df1s_af[[n_chunks-1]], df1s[[n_chunks]])
  
  if (n_chunks > 2L) {
    for (i in 2:(n_chunks-1L))
      df1s[[i]] <- dplyr::bind_rows(df1s_af[[i-1]], df1s[[i]], df1s_bf[[i+1]])
  }
  rm(list = c("df1s_bf", "df1s_af", "df1"))
  
  ##  Splits `df` with bracketing entries
  # values: row indexes in `df`, length == nrow(df1) at pad_nas = TRUE
  ms1_stas <- getMSrowIndexes(df$ms_level, pad_nas = TRUE)$ms1_stas
  cols <- c("ms_level", "ms1_moverz", "ms1_int")
  ms1_stax <- dfs <- vector("list", n_chunks)
  
  for (i in 1:n_chunks) {
    stai <- sta1s[[i]] # stai-th MS1 scan
    ms1_stax[[i]] <- ms1_stas[stai] # the corresponding row index in df
  }

  for (i in 1:(n_chunks - 1L)) {
    rowx <- ms1_stax[[i]]:(ms1_stax[[i+1]] - 1L) # ms2_endx can be NA
    dfs[[i]] <- df[rowx, cols] # both df1 and df2 data
  }
  
  dfs[[n_chunks]] <- df[ms1_stax[[n_chunks]]:nrow(df), cols]

  list(dfs = dfs, df1s = df1s, gaps = gaps)
}


#' Helper of \link{traceXY}.
#'
#' @param xs Vectors of full-spectrum MS1 m/z values.
#' @param ys Vectors of full-spectrum MS1 intensities.
#' @param ss Vectors of MS1 scan numbers.
#' @param df A data frame of staggering MS1 and MS2 in the same range of
#'   \code{xs}.
#' @param gap_bf A preceding gap size.
#' @param gap_af A following gap size.
#' @param from The starting point for mass binning.
#' @param step The step size for mass binning.
#' @inheritParams matchMS
htraceXY <- function (xs, ys, ss, df, gap_bf = 256L, gap_af = 256L, 
                      n_mdda_flanks = 6L, from = 200L, step = 1E5)
{
  if (all(lengths(xs) == 0L)) {
    # length(xs) - gap_bf - gap_af - nrow(df) == 0L
    li <- nrow(df)
    null <- rep_len(list(NULL), li)
    
    return(
      tibble::tibble(
        ms_level = df$ms_level, 
        ms1_moverz = null, 
        ms1_int = null, 
        apex_scan_num = null)
    )
  }
  
  mat <- traceXY(
    xs = xs, ys = ys, ss = ss, n_mdda_flanks = n_mdda_flanks, from = from, 
    step = step, reord = FALSE, cleanup = FALSE, # otherwise rows drop
    replace_ms1_by_apex = TRUE)
  
  matx <- mat[["x"]]
  maty <- mat[["y"]]
  nr <- nrow(matx)
  nc <- ncol(matx)
  
  ## apes, rngs and scans: each vector corresponds to a column of mass
  #  apes not ordered by orig_scan, one-hit-wonders goes first
  apes <- mat[["p"]]
  # rngs <- mat[["range"]]
  
  # apes correspond to the row numbers of matx and ss to orig_scan
  scan_apexs <- vector("list", nc)
  
  for (i in 1:nc) {
    rows <- apes[[i]]
    scan_apexs[[i]] <- as.integer(ss[rows])
  }

  rm(list = "mat")
  gc()
  
  if (gap_bf) {
    if (gap_af) { # middle
      sta <- gap_bf + 1L
      end <- nr - gap_af
    }
    else { # last
      sta <- gap_bf + 1L
      end <- nr
    }
  }
  else { # first
    sta <- 1L
    end <- nr - gap_af
  }
  
  if (FALSE) {
    matx <- matx[sta:end, ]
    maty <- maty[sta:end, ]
    ss <- ss[sta:end]
    # look current
    df <- updateMS1Int(df = df, matx = matx, maty = maty, from = from, 
                       step = step)
  }
  else {
    # look both before and after scans
    df <- updateMS1Int2(
      df = df, matx = matx, maty = maty, row_sta = sta, row_end = end, 
      scan_apexs = scan_apexs, from = from, step = step)
  }
}


#' Helper of MS1 tracing.
#'
#' @param xs Vectors of full-spectrum MS1 moverzs.
#' @param ys Vectors of full-spectrum MS1 intensities.
#' @param ss Vectors of MS1 scan numbers.
#' @param step Step size.
#' @param from The starting point for mass binning.
#' @param step A step size for mass binning.
#' @param reord Logical; re-order data or not.
#' @param cleanup Logical; to clean up xs, ys and zs or not. Set the value to
#'   FALSE to maintain one-to-one correspondence between input (data frame) and
#'   the outputs. This will help, e.g., keep track of scan numbers in the input.
#' @param replace_ms1_by_apex Logical; if TRUE, fill all entries within a gate
#'   by its apex values.
#' @inheritParams matchMS
traceXY <- function (xs, ys, ss, n_mdda_flanks = 6L, from = 115L, step = 1E-5, 
                     reord = TRUE, cleanup = FALSE, replace_ms1_by_apex = FALSE)
{
  lens <- lengths(xs)
  
  if (all(lens == 0L)) {
    # return(list(x = NULL, y = NULL, n = NULL, p = NULL, range = NULL))
  }

  if (reord) {
    for (i in seq_along(xs)) {
      xi <- xs[[i]]
      
      if (lens[[i]]) {
        ord <- order(xi)
        xs[[i]] <- xi[ord]
        ys[[i]] <- ys[[i]][ord]
      }
    }
    rm(list = c("xi", "ord"))
  }
  
  ## collapses MS data by the indexes of mass bins; 
  # two matrix outputs; rows: scans; columns: masses or intensities
  
  # xs can be numeric(0)?
  # cleanup = FALSE; otherwise rows drop
  # often coll == cleanup
  ans <- collapse_mms1ints(
    xs = xs, ys = ys, lwr = from, step = step, reord = FALSE, coll = FALSE, 
    cleanup = FALSE, add_colnames = TRUE)
  
  ansx <- ans[["x"]]
  ansy <- ans[["y"]]
  rm(list = c("ans"))
  gc()
  
  ## traces MS data matrices across LC scans; rows: scans; columns: masses
  nrc <- dim(ansy)
  nr <- nrc[[1]]
  nc <- nrc[[2]]
  rm(list = "nrc")
  
  if (nr != length(xs)) {
    stop("Developer: rows drop during MS1 tracing.")
  }
  
  xmat <- ymat <- matrix(rep_len(NA_real_, nc * nr), ncol = nc)
  colnames(xmat) <- colnames(ymat) <- colnames(ansx)
  rownames(xmat) <- rownames(ymat) <- ss
  ranges <- apexes <- ns <- vector("list", nc)
  
  if (replace_ms1_by_apex) {
    for (i in 1:nc) {
      # removes peaks at intensity < 2% of base peak
      yi <- ansy[, i]
      oks <- .Internal(which(!is.na(yi)))
      yoks <- yi[oks]
      yoks[yoks < max(yoks) * .02] <- NA_real_
      yi[oks] <- yoks
      gates <- find_lc_gates(yi, n_dia_scans = n_mdda_flanks)
      # ansy[, i] <- yi

      # one-hit-wonders go first, not ordered scans
      apexes[[i]] <- rows <- gates[["apex"]]
      ns[[i]] <- gates[["ns"]] # number of observing scans
      ranges[[i]] <- rngs <- gates[["ranges"]]

      for (j in seq_along(rows)) {
        rgj <- rngs[[j]]
        rwj <- rows[[j]]
        xmat[rgj, i] <- ansx[rwj, i]
        ymat[rgj, i] <- ansy[rwj, i]
      }
    }
  }
  else {
    for (i in 1:nc) {
      gates <- find_lc_gates(ansy[, i], n_dia_scans = n_mdda_flanks)
      apexes[[i]] <- rows <- gates[["apex"]]
      ns[[i]] <- gates[["ns"]] # number of observing scans
      ranges[[i]] <- rngs <- gates[["ranges"]]
      
      xmat[rows, i] <- ansx[rows, i]
      ymat[rows, i] <- ansy[rows, i]
    }
  }
  
  rm(list = c("ansx", "ansy"))
  gc()
  
  list(x = xmat, y = ymat, n = ns, p = apexes, range = ranges)
}


#' Updates MS1 intensity with apex values.
#'
#' @param df A data frame.
#' @param matx The matrix of moverzs Y: by masses; X: by LC scans.
#' @param maty The matrix of intensities. Y: by masses; X: by LC scans.
#' @param from The starting point for mass binning.
#' @param step A step size for mass binning.
updateMS1Int <- function (df, matx, maty, from = 200L, step = 1E-5)
                          
{
  nrow <- nrow(matx)
  
  pos_levs <- getMSrowIndexes(df$ms_level, pad_nas = TRUE)
  ms1_stas <- pos_levs$ms1_stas
  ms2_stas <- pos_levs$ms2_stas
  ms2_ends <- pos_levs$ms2_ends
  rm(list = "pos_levs")
  
  for (i in seq_along(ms2_stas)) {
    ms2sta <- ms2_stas[[i]]
    
    if (is.na(ms2sta))
      next
    
    ms2end <- ms2_ends[[i]]
    df2 <- df[ms2sta:ms2end, ]
    
    xs <- matx[i, ]
    ys <- maty[i, ]
    oks <- .Internal(which(!is.na(xs)))
    xs <- xs[oks]
    ys <- ys[oks]
    ixs <- as.integer(ceiling(log(xs/from)/log(1+step)))

    for (j in 1:nrow(df2)) {
      xsj <- df2[["ms1_moverz"]][[j]]
      ixsj <- as.integer(ceiling(log(xsj/from)/log(1+step)))
      ps0 <- match(ixsj, ixs)
      
      if (any(nas0 <- is.na(ps0))) {
        ps1 <- match(ixsj + 1L, ixs)
        ps2 <- match(ixsj - 1L, ixs)
        
        if (length(i0 <- which(!nas0))) {
          df2[["ms1_int"]][[j]][i0] <- ys[ps0[!is.na(ps0)]]
        }
        
        if (length(i1 <- which(!is.na(ps1)))) {
          df2[["ms1_int"]][[j]][i1] <- ys[ps1[!is.na(ps1)]]
        }
        
        if (length(i2 <- which(!is.na(ps2)))) {
          df2[["ms1_int"]][[j]][i2] <- ys[ps2[!is.na(ps2)]]
        }
      }
      else {
        df2[["ms1_int"]][[j]] <- ys[ps0]
      }
    }
    
    df[["ms1_int"]][ms2sta:ms2end] <- df2[["ms1_int"]]
  }
  
  df
}


#' Updates MS1 intensity with apex values.
#'
#' Including forward and backward looking.
#'
#' @param df A data frame.
#' @param matx The matrix of moverzs Y: by masses; X: by LC scans.
#' @param maty The matrix of intensities. Y: by masses; X: by LC scans.
#' @param row_sta The starting row of \code{matx}.
#' @param row_end The ending row of \code{matx}.
#' @param scan_apexs The vectors of apex scan number. Each vector corresponds to
#'   a mass in \code{matx}.
#' @param from The starting point for mass binning.
#' @param step A step size for mass binning.
#' @importFrom fastmatch %fin%
updateMS1Int2 <- function (df, matx, maty, row_sta, row_end, scan_apexs, 
                           from = 200L, step = 1E-5)
  
{
  # to update the apexs, vector since can be chimeric precursors
  df$apex_scan_num <- vector("list", nrow(df))
  
  nrow <- nrow(matx)
  unv <- as.integer(colnames(matx))
  ss <- as.integer(rownames(matx))
  
  pos_levs <- getMSrowIndexes(df$ms_level, pad_nas = TRUE)
  ms1_stas <- pos_levs$ms1_stas
  ms2_stas <- pos_levs$ms2_stas
  ms2_ends <- pos_levs$ms2_ends
  rm(list = "pos_levs")
  gap <- row_sta - 1L
  gap2 <- 12L

  ###
  # rowi: the current row index along matx
  # scan: the current scan number (of rowi); 13588
  ###
  
  for (i in seq_along(ms2_stas)) { # the same as by ms1_stas
    # i = 527 - gap; which(rownames(matx) == 13588)
    # i = 100;
    ms2sta <- ms2_stas[[i]]
    if (is.na(ms2sta)) next
    ms2end <- ms2_ends[[i]]
    df2 <- df[ms2sta:ms2end, ]
    
    rowi <- gap + i
    scan <- ss[[rowi]]
    # rows <- max(1L, rowi - gap):min(rowi + gap2, nrow)

    for (j in 1:nrow(df2)) {
      # j = 8
      x2s <- df2[["ms1_moverz"]][[j]] # precursor masses associated with an MS2 scan
      nx <- length(x2s) # nx > 1 with a chimeric spectrum
      if (!nx) next
      ix2s <- as.integer(ceiling(log(x2s/from)/log(1+step)))
      ks <- lapply(ix2s, function (x) which(abs(x - unv) <= 1L))
      
      for (m in 1:nx) {
        k <- ks[[m]] # the k-th column
        
        if (!length(k)) {
          next
        }

        k <- k[[1]] # can have two adjacent matches
        
        # ix <- unv[[k]]; # a <- maty[, which(colnames(matx) == unv[[k]])]; a <- maty[, 3218:3219]
        # apex scan numbers; note: scan_apexs not ordered: one-hit-wonders first
        apexs <- scan_apexs[[k]] # all apexs (scan numbers) under the k-th mass column
        ds <- abs(apexs - scan)
        p1 <- .Internal(which.min(ds))
        ap1 <- apexs[[p1]] # the nearest apex scan; 13525
        ok1 <- .Internal(which(ss == ap1))
        y1 <- maty[ok1, k]

        # checks neighbors
        if (length(apexs) > 1L) {
          ps <- which_topx2(-ds, 2L)
          p2 <- ps[ps != p1]
          ap2 <- apexs[[p2]] # the second nearest apex scan; 13686
          ok2 <- .Internal(which(ss == ap2))
          y2 <- maty[ok2, k]

          # later checks peak spacing and peak width (for small satellite peaks)
          if ((y1 < y2) && (abs(ap2 - ap1) <= 200L)) { # 200L somewhat arbitrary
            y1 <- y2
            df2$apex_scan_num[[j]][[m]] <- ap2 # ss[ok2]
          }
          else {
            df2$apex_scan_num[[j]][[m]] <- ap1 # ss[ok1]
          }
        }

        df2[["ms1_int"]][[j]][m] <- max(df2[["ms1_int"]][[j]][m], y1)
        # df2[["ms1_int"]][[j]][m] <- y1
      }
    }

    ms2rng <- ms2sta:ms2end
    df[["apex_scan_num"]][ms2rng] <- df2[["apex_scan_num"]]
    df[["ms1_int"]][ms2rng] <- df2[["ms1_int"]]
  }
  
  df
}


#' Helper of MS1 tracing.
#' 
#' Not yet used.
#' 
#' @param df MS1 data.
#' @param step Step size.
#' @param n_ms1peakpicking_flanks The number of flanking MS1 scans for precursor
#'   peak picking.
#' @param replace_ms1_by_apex Logical; if TRUE, fill all entries within a gate
#'   by its apex values.
#' @param filename A peaklist filename.
#' @param temp_dir A temp_dir to the filename.
#' @param min_mass A minimum mass.
traceMS1 <- function (df, min_mass = 200L, step = 8E-6, 
                      n_ms1peakpicking_flanks = 4L, replace_ms1_by_apex = TRUE, 
                      filename = NULL, temp_dir = NULL)
  
{
  rows <- which(lengths(df$ms1_moverz) == 0L)
  
  if (length(rows)) {
    df$ms1_int[rows] <- df$ms1_mass[rows] <- df$ms1_moverz[rows] <- list(NA_real_)
    df$ms1_charge[rows] <- list(NA_integer_)
  }
  
  for (i in nrow(df)) {
    xi <- df[["ms1_moverz"]][[i]]
    yi <- df[["ms1_int"]][[i]]
    zi <- df[["ms1_charge"]][[i]]
    mi <- df[["ms1_mass"]][[i]]
    oki <- .Internal(which(yi > 0))
    
    if (length(oki)) {
      df[["ms1_moverz"]][[i]] <- xi[oki]
      df[["ms1_int"]][[i]] <- yi[oki]
      df[["ms1_charge"]][[i]] <- zi[oki]
      df[["ms1_mass"]][[i]] <- mi[oki]
    }
  }
  rm(list = c("xi", "yi", "zi", "mi", "oki"))
  
  mat <- traceLCMS(
    xs = df[["ms1_moverz"]], 
    ys = df[["ms1_int"]], 
    zs = df[["ms1_charge"]], 
    n_dia_scans = n_ms1peakpicking_flanks, 
    from = min_mass, 
    step = step, 
    reord = FALSE, # already ordered
    cleanup = FALSE, # already cleaned
    replace_ms1_by_apex = replace_ms1_by_apex, 
    direct_out = TRUE, 
    temp_dir = temp_dir)
}


#' Gets MS1 intensity values from full MS1 data.
#' 
#' Not yet used.
#' 
#' @param df1 Data frame corresponding to \code{ms_level == 1L}.
#' @param from The starting point for mass binning
#' @param step A step size.
#' @param set_missing_zero Logical; if TRUE, set 0-intensity for peaks not
#'   found.
getMS1Int <- function (df1, from = 200L, step = 8E-6, set_missing_zero = FALSE)
{
  for (i in 1:nrow(df1)) {
    xs1 <- df1$ms1_moverz[[i]]
    len <- length(xs1)
    
    if (!len)
      next
    
    ys <- df1$msx_ints[[i]]
    ixxs <- as.integer(ceiling(log(df1$msx_moverzs[[i]]/from)/log(1+step)))
    ixs1 <- as.integer(ceiling(log(xs1/from)/log(1+step)))
    ps0 <- match(ixs1, ixxs)
    oks <- !is.na(ps0)
    
    if (all(oks)) {
      df1[["ms1_int"]][[i]] <- ys[ps0]
    }
    else {
      ps1 <- match(ixs1 + 1L, ixxs)
      ps2 <- match(ixs1 - 1L, ixxs)
      i1 <- .Internal(which(!is.na(ps1)))
      i2 <- .Internal(which(!is.na(ps2)))
      i0 <- .Internal(which(oks))
      
      if (length(i0)) {
        df1[["ms1_int"]][[i]][i0] <- ys[ps0[i0]]
      }
      
      if (length(i1)) {
        df1[["ms1_int"]][[i]][i1] <- ys[ps1[i1]]
      }
      
      if (length(i2)) {
        df1[["ms1_int"]][[i]][i2] <- ys[ps2[i2]]
      }
      
      # not matched at all
      if (set_missing_zero) {
        i012 <- c(i0, i1, i2)
        
        if (length(i012) < len) {
          bads <- !1:len %in% i012
          df1[["ms1_int"]][[i]][bads] <- 0
        }
      }
    }
  }
  
  df1
}


#' Visualization of matched MS2 ions.
#'
#' @param in_name An input file name of PSMs, such as psmQ.txt, psmC.txt,
#'   psmT2.txt, psmT3.txt etc.
#' @param out_name An output file name for saving the the plot of MS2 ions.
#' @param out_path A file path where outputs of \link{matchMS} can be
#'   identified.
#' @param scan A scan number that can be found from the outputs. Positive
#'   integer, Thermo's Orbitrap data; character string, Bruker's timsTOF data.
#'
#'   The searches of scan number will proceed automatically through
#'   \code{psmQ.txt},  \code{psmT2.txt}, \code{psmT3.txt} and/or
#'   \code{psmC.txt}.
#' @param raw_file Character string; a RAW file name.
#' @param rank Positive integer; the rank of a match. The default is one for the
#'   best match.
#' @param is_decoy Logical; is the match from decoy. The default is FALSE.
#' @param type_ms2ions Type of MS2 ions.
#' @param width Plot width.
#' @param height Plot height.
#' @rawNamespace import(ggplot2, except = c("%+%"))
#' @examples
#' \dontrun{
#' library(mzion)
#' 
#' ans <- mapMS2ions(
#'     out_path = "a/mzion/output/folder", in_name = "psmQ.txt", 
#'     out_name = "bar.png", raw_file = "a-raw-file-name.raw", scan = 9933, 
#'     rank = 1L, is_decoy = FALSE, type_ms2ions = "by"
#'   )
#'
#' # Custom plots
#' library(ggplot2)
#'
#' mgf <- ans$mgf
#' duo <- ans$duo
#' duo2 <- ans$duo2
#'
#' p <- ggplot() +
#'   geom_segment(mgf, mapping = aes(x = ms2_moverz, y = ms2_int,
#'                                          xend = ms2_moverz, yend = 0),
#'                       color = "gray", size = .1) +
#'   geom_segment(duo, mapping = aes(x = ms2_moverz, y = ms2_int,
#'                                            xend = ms2_moverz, yend = 0,
#'                                            color = type),
#'                         size = 1, show.legend = FALSE) +
#'   geom_text(duo, mapping = aes(x = ms2_moverz, y = ms2_int,
#'                                         label = label, color = type),
#'                      size = 6, alpha = .5, hjust = 0, angle = 90, vjust = 0,
#'                      nudge_x = 0.05, nudge_y = 0.05, na.rm = TRUE,
#'                      show.legend = FALSE) +
#'   labs(x = "m/z", y = "Intensity")
#' 
#' if (nrow(duo2)) {
#'   p <- p + 
#'     ggplot2::geom_segment(duo2, mapping = aes(x = ms2_moverz, y = ms2_int, 
#'                                               xend = ms2_moverz, yend = 0, 
#'                                               color = type), 
#'                           size = .5, show.legend = FALSE) + 
#'     ggplot2::geom_text(duo2, mapping = aes(x = ms2_moverz, y = ms2_int, 
#'                                            label = label, color = type),
#'                        size = 4, alpha = .5, hjust = 0, angle = 90, vjust = 0, 
#'                        nudge_x = 0.05, nudge_y = 0.05, na.rm = TRUE, 
#'                        show.legend = FALSE) 
#' }
#' 
#' pep <- paste0(duo$site[1:(nrow(duo)/2L)], collapse = " ")
#' p + annotate("text", -Inf, Inf, label = pep, hjust = -.2, vjust = 2)
#' 
#' }
#' 
#' @export
mapMS2ions <- function (out_path = NULL, in_name = "psmQ.txt", 
                        out_name = "bar.png", raw_file = "foo.raw", 
                        scan = 1234, rank = 1L, is_decoy = FALSE, 
                        type_ms2ions = "by", width = 12.5, height = 6) 
{
  if (is.null(out_path) || is.na(out_path) || out_path == "") {
    warning("\"out_path\" cannot be empty.")
    return(NULL)
  }
  
  if (is.null(raw_file) || is.na(raw_file) || raw_file == "" ) {
    warning("\"raw_file\" cannot be empty.")
    return(NULL)
  }
  
  if (is.null(in_name) || is.na(in_name) || in_name == "" ) {
    warning("\"in_name\" is empty; assume `psmQ.txt`.")
    in_name <- "psmQ.txt"
  }
  
  if (is.null(out_name) || out_name == "") {
    warning("\"out_name\" is empty; use `bar.png`.")
    out_name <- "bar.png"
  }
  
  out_name <- check_ggname(out_name)
  
  # MGF
  if (!file.exists(fi_psm <- file.path(out_path, in_name))) {
    warning("PSM file not found: ", fi_psm)
    return(NULL)
  }
  
  mgf_path <- match_mgf_path(out_path)
  raw_id <- match_raw_id(raw_file, mgf_path)
  scan <- as.character(scan)
  
  mgf_ok <- find_mgf_query(mgf_path, raw_id, scan)
  
  if (is.null(mgf_ok) || !nrow(mgf_ok)) {
    warning("MGF query not found.")
    return(NULL)
  }

  req_cols <- c("ms2_moverzs", "ms2_ints")
  
  if (!all(oks <- req_cols %in% names(mgf_ok))) {
    warning("Developer: missing PSM columns ", 
            paste(req_cols[!oks], collapse = ", "))
    return(NULL)
  }

  mgf <- data.frame(ms2_moverz = mgf_ok$ms2_moverzs[[1]], 
                    ms2_int = mgf_ok$ms2_ints[[1]])
  mgf$iex <- seq_len(nrow(mgf))
  
  ## PSMs
  cols_excl <- c("pep_ms2_moverzs", "pep_ms2_ints", "pep_ms2_theos", 
                 "pep_ms2_theos2", "pep_ms2_exptints", "pep_ms2_exptints2", 
                 "pep_n_matches", "pep_n_matches2")
  
  gl_vals <- ls(all.names = TRUE, envir = .GlobalEnv)
  ok_psms <- any(gl_vals == ".psms")
  
  ok_file <- if (any(gl_vals == ".psm_file"))
    identical(get(".psm_file", envir = .GlobalEnv), fi_psm)
  else
    FALSE
  
  if (ok_psms && ok_file) {
    .psms <- get(".psms", envir = .GlobalEnv)
  }
  else {
    # some columns in psmQ.txt not in psmC.txt
    .psms <- suppressWarnings(
      readr::read_tsv(fi_psm, show_col_types = FALSE, 
                      col_types = get_mzion_coltypes()))
    .psms <- .psms[, -which(names(.psms) %in% cols_excl), drop = FALSE]
    assign(".psms", .psms, envir = .GlobalEnv)
    assign(".psm_file", file.path(out_path, in_name), envir = .GlobalEnv)
  }
  
  req_psmcols <- c("pep_scan_num", "raw_file", "pep_rank", "pep_isdecoy")
  
  if (!all(oks <- req_psmcols %in% names(.psms))) {
    warning("Developer: missing PSM columns ", 
            paste(req_psmcols[!oks], collapse = ", "))
    return(NULL)
  }

  psm <- .psms |>
    dplyr::filter(pep_scan_num == scan, 
                  .data$raw_file == .env$raw_file, 
                  pep_rank == rank,
                  pep_isdecoy == is_decoy) 
  psm <- psm[, -grep("^prot_", names(psm)), drop = FALSE]
  psm <- unique(psm) # can be duplicated by prot_accs
  
  if (!(nrow <- nrow(psm))) {
    warning("PSM entry not found. Check the correctness of scan number etc.")
    return(NULL)
  }
  
  if (nrow > 1L) {
    warning("Multiple PSMs found and the the first match being used.")
    psm <- psm[1, , drop = FALSE]
  }
  
  cols_duo <- c("ms2_moverz", "theo", "ms2_int", "site", "type", "label")
  aas <- strsplit(psm$pep_seq, "")[[1]]
  naa <- length(aas)
  
  ## Primary
  duo <- local({
    ion_types <- unlist(strsplit(type_ms2ions, ""))
    
    if (length(ion_types) != 2L)
      stop("Not a two-character `type_ms2ions = ", type_ms2ions, "`.")
    
    cols_pri <- c("pep_ms2_deltas", "pep_ms2_ideltas", "pep_ms2_iexs")

    if (!all(oks <- cols_pri %in% names(psm))) {
      warning("Developer: missing PSM columns ", 
              paste(cols_pri[!oks], collapse = ", "))
      return(NULL)
    }

    theoexpt <- lapply(psm[, cols_pri], function (x) strsplit(x, ";")[[1]]) |>
      dplyr::bind_cols() |>
      dplyr::mutate(pep_ms2_deltas = as.numeric(pep_ms2_deltas)/1E3, 
                    pep_ms2_ideltas = as.integer(pep_ms2_ideltas), 
                    pep_ms2_iexs = as.integer(pep_ms2_iexs)) |>
      dplyr::rename(ith = pep_ms2_ideltas, iex = pep_ms2_iexs)
    
    duo <- data.frame(site = c(aas, aas[naa:1L]))
    duo$ith <- seq_len(nrow(duo))
    duo$type <- rep(ion_types, each = naa)
    idxes <- paste0("(", seq_len(naa), ")")
    duo$label <- unlist(lapply(ion_types, function (x) paste0(x, idxes)))
    
    duo <- duo |>
      dplyr::left_join(theoexpt, by = "ith")  |> 
      dplyr::arrange(ith) |>
      dplyr::left_join(mgf, by = "iex") |> 
      dplyr::mutate(theo = ms2_moverz + pep_ms2_deltas) |> 
      dplyr::select(cols_duo)
  })
  
  ## Secondary
  duo2 <- local({
    cols_sec <- c("pep_ms2_deltas2", "pep_ms2_ideltas2", "pep_ms2_iexs2")
    
    if (!all(oks <- cols_sec %in% names(psm))) {
      warning("Developer: missing PSM columns ", 
              paste(cols_sec[!oks], collapse = ", "))
      return(NULL)
    }

    theoexpt2 <- lapply(psm[, cols_sec], function (x) strsplit(x, ";")[[1]]) |>
      dplyr::bind_cols() |>
      dplyr::mutate(pep_ms2_deltas2 = as.numeric(pep_ms2_deltas2)/1E3, 
                    pep_ms2_ideltas2 = as.integer(pep_ms2_ideltas2), 
                    pep_ms2_iexs2 = as.integer(pep_ms2_iexs2)) |>
      dplyr::rename(ith = pep_ms2_ideltas2, iex = pep_ms2_iexs2) 
    
    ion_types2 <- find_secion_types(type_ms2ions)
    nsec   <- length(ion_types2)/2L
    type2  <- rep(ion_types2, each = naa)
    idxes2 <- paste0("(", seq_len(naa), ")")
    labs2  <- unlist(lapply(ion_types2, function (x) paste0(x, idxes2)))
    
    duo2 <- data.frame(site = c(rep(aas, nsec), rep(aas[naa:1L], nsec)), 
                       ith = seq_len(nsec * 2L * naa), 
                       type = type2, label = labs2)
    
    duo2 <- duo2 |>
      dplyr::left_join(theoexpt2, by = "ith")  |>
      dplyr::arrange(ith) |>
      dplyr::left_join(mgf, by = "iex") |>
      dplyr::mutate(theo = ms2_moverz + pep_ms2_deltas2) |>
      dplyr::select(cols_duo)
  })
  
  duos <- list(duo = duo, duo2 = duo2, mgf = mgf[, c("ms2_moverz", "ms2_int")])
  plotMS2ions(duos, out_path = out_path, out_name = out_name, width = width, 
              height = height)
}


#' Plots matched MS2 ions
#' 
#' @param duos The duo of MGF data and matched data.
#' @param out_path An output path.
#' @param out_name An output file name for saving the the plot of MS2 ions.
#' @param width Plot width.
#' @param height Plot height.
plotMS2ions <- function (duos, out_path = "~", out_name = "bar.png", 
                         width = 12.5, height = 9)
{
  duo  <- duos$duo
  duo2 <- duos$duo2
  mgf  <- duos$mgf
  
  ## Visualizations
  if (!requireNamespace("ggplot2", quietly = TRUE)) {
    warning("\n======================================================", 
            "\nPackage \"ggplot2\" required for visualization.",
            "\n======================================================",
            call. = FALSE)
  }
  
  p <- ggplot2::ggplot() + 
    ggplot2::geom_segment(mgf, mapping = aes(x = ms2_moverz, y = ms2_int, 
                                             xend = ms2_moverz, yend = 0), 
                          color = "gray", linewidth = .1) + 
    ggplot2::geom_segment(duo, mapping = aes(x = ms2_moverz, y = ms2_int, 
                                             xend = ms2_moverz, yend = 0, 
                                             color = type), 
                          linewidth = 1, show.legend = FALSE) + 
    ggplot2::geom_text(duo, mapping = aes(x = ms2_moverz, y = ms2_int, 
                                          label = label, color = type),
                       size = 6, alpha = .5, hjust = 0, angle = 90, vjust = 0, 
                       nudge_x = 0.05, nudge_y = 0.05, na.rm = TRUE, 
                       show.legend = FALSE) + 
    ggplot2::labs(x = "m/z", y = "Intensity")
  
  if (nrow(duo2)) {
    p <- p + 
      ggplot2::geom_segment(duo2, mapping = aes(x = ms2_moverz, y = ms2_int, 
                                                xend = ms2_moverz, yend = 0, 
                                                color = type), 
                            linewidthlinewidth = .5, show.legend = FALSE) + 
      ggplot2::geom_text(duo2, mapping = aes(x = ms2_moverz, y = ms2_int, 
                                             label = label, color = type),
                         size = 4, alpha = .5, hjust = 0, angle = 90, vjust = 0, 
                         nudge_x = 0.05, nudge_y = 0.05, na.rm = TRUE, 
                         show.legend = FALSE) 
  }
  
  pep <- paste0(duo$site[1:(nrow(duo)/2L)], collapse = " ")
  
  if (nrow(duo2)) 
    ymax <- max(duo$ms2_int, duo2$ms2_int, na.rm = TRUE)
  else 
    ymax <- max(duo$ms2_int, na.rm = TRUE)
  
  p <- p + 
    annotate("text", -Inf, Inf, label = pep, hjust = -.2, vjust = 2) + 
    ylim(0, ymax * 1.05)

  ggplot2::ggsave(file.path(out_path, out_name), width = width, height = height,
                  dpi = 300)

  ans <- list(mgf = mgf, duo = duo, duo2 = duo2, p = p)
  rds <- paste0(gsub("\\.[^.]*$", "", out_name), ".rds")
  saveRDS(ans, file.path(out_path, rds))

  invisible(ans)
}


#' Matches the value of mgf_path.
#' 
#' @param out_path An output path.
match_mgf_path <- function (out_path) 
{
  rda <- file.path(out_path, "Calls", "matchMS.rda")
  
  if (!file.exists(rda))
    stop("Parameter file not found: ", rda)
  
  load(rda)
  
  call_pars$mgf_path
}


#' Matches the id of raw_file.
#' 
#' @param mgf_path An MGF path.
#' @inheritParams mapMS2ions
match_raw_id <- function (raw_file, mgf_path) 
{
  file <- file.path(mgf_path, "raw_indexes.rds")
  
  if (!file.exists(file))
    stop("File not found ", file)
  
  raw_map <- qs::qread(file)
  raw_id <- unname(raw_map[raw_file])
  
  if (is.na(raw_id)) {
    stop(raw_file, " not found in ", file, ".\n", 
         "Aside from the possibility of incorrect `raw_file`, ",
         "have the folder name been changed?")
  }
  
  raw_id
}


#' Adds \code{raw_ids}.
#'
#' Currently only used with psmC.txt during matchMS. An inverse function of
#' \link{match_raw_id}.
#'
#' @param df A PSM table.
#' @inheritParams matchMS
add_raw_ids <- function (df, mgf_path) 
{
  if (!"raw_file" %in% names(df))
    stop("Column `raw_file` not found.")
  
  raw_files <- unique(df$raw_file)
  raw_ids <- unlist(lapply(raw_files, match_raw_id, mgf_path))
  raws_lookup <- data.frame(raw_file = raw_files, raw_id = raw_ids)
  
  dplyr::left_join(df, raws_lookup, by = "raw_file")
}


#' Finds the types of secondary ions.
#' 
#' The order of secondary ions was defined in \link{add_seions}.
#'
#' @inheritParams matchMS
find_secion_types <- function (type_ms2ions = "by") 
{
  switch(type_ms2ions, 
         by = c("b2", "b*", "b*2", "b0", "b02", "y2", "y*", "y*2", "y0", "y02"), 
         cz = c("a2", "a*", "a*2", "a0", "a02", "x2"), 
         ax = c("c2", "z2"), 
         stop("Unknown type.", call. = FALSE))
}


#' Finds matched MGF query.
#' 
#' @param mgf_path An MGF path.
#' @param raw_id The index of raw_file.
#' @param scan A scan number or identifier.
#' @param to_global Logical; if TRUE, assigned to the Global environment.
find_mgf_query <- function (mgf_path, raw_id, scan, to_global = TRUE) 
{
  gl_vals <- ls(all.names = TRUE, envir = .GlobalEnv)
  ok_mgfs <- any(gl_vals == ".mgf_queries")
  
  ok_file <- if (any(gl_vals == ".mgf_path"))
    identical(get(".mgf_path", envir = .GlobalEnv), mgf_path)
  else
    FALSE
  
  if (ok_mgfs && ok_file) {
    .mgf_queries <- get(".mgf_queries", envir = .GlobalEnv)
  }
  else {
    files <- list.files(path = file.path(mgf_path), 
                        pattern = "mgf_queries_.*\\.rds$")
    
    if (!length(files)) {
      warning("No parsed `mgf_queries.rds` under ", mgf_path)
      return(NULL)
    }

    .mgf_queries <- lapply(files, function (x) qs::qread(file.path(mgf_path, x)))
    .mgf_queries <- do.call(rbind, .mgf_queries)
    .mgf_queries <- dplyr::mutate(.mgf_queries, scan_num = as.character(scan_num))

    if (to_global) {
      assign(".mgf_queries", .mgf_queries, envir = .GlobalEnv)
      assign(".mgf_path", mgf_path, envir = .GlobalEnv)
    }

    rm(list = "files")
  }
  
  mgf <- .mgf_queries |>
    dplyr::filter(raw_file == raw_id, scan_num == scan)

  if (!(nrow <- nrow(mgf))) {
    warning("MGF entries not found.")
  }
  else if (nrow > 1L) {
    warning("Multiple `mgf_query` matches and used the first one.")
    mgf <- mgf[1, , drop = FALSE]
  }
  
  mgf
}


#' Makes spectrum library
#'
#' @param score_co The cut-off in PSM scores for library construction.
#' @param mdev_co The cut-off in PSM \code{pep_ms2_deltas_mean}. The default is
#'   5 (ppm).
#' @param sd_co The cut-off in PSM \code{pep_ms2_deltas_sd}. The default is 10.
#' @param type_ms2ions Type of MS2 ions.
#' @inheritParams mapMS2ions
#' @export
make_speclib <- function (out_path = NULL, in_name = "psmQ.txt", score_co = 15, 
                          mdev_co = 5, sd_co = 10, type_ms2ions = "by")
{
  if (is.null(out_path) || is.na(out_path) || out_path == "") {
    warning("\"out_path\" cannot be empty.", call. = FALSE)
    return(NULL)
  }
  
  if (is.null(in_name) || is.na(in_name) || in_name == "" ) {
    warning("\"in_name\" is empty; assume `psmQ.txt`.", call. = FALSE)
    in_name <- "psmQ.txt"
  }
  
  if (!file.exists(fileQ <- file.path(out_path, in_name))) {
    warning("PSM file not found: ", fileQ)
    return(NULL)
  }
  
  if (length(ion_types <- unlist(strsplit(type_ms2ions, ""))) != 2L)
    stop("Not a two-character `type_ms2ions = ", type_ms2ions, "`.")
  
  cols <- c("prot_acc", "pep_seq", "pep_score", "pep_expect", "pep_n_ms2", 
            "pep_exp_mz", "pep_exp_mr", "pep_exp_z", "pep_calc_mr", 
            "pep_delta", "pep_tot_int", "pep_ret_range", "pep_scan_num", 
            "pep_ms1_offset", "pep_fmod", "pep_vmod", "pep_ivmod", "pep_len", 
            "pep_ms2_moverzs", "pep_ms2_ints", "pep_n_matches", 
            # "pep_scan_title", "pep_mod_group", "pep_ms2_theos", 
            # "pep_ms2_theos2", "pep_ms2_exptints", "pep_ms2_exptints2", 
            "pep_n_matches2", "pep_ms2_deltas", "pep_ms2_ideltas", 
            "pep_ms2_iexs", "pep_ms2_deltas2", "pep_ms2_ideltas2", 
            "pep_ms2_iexs2", "pep_ms2_deltas_mean", "pep_ms2_deltas_sd", 
            "pep_locprob", "pep_locdiff", "pep_rank", "raw_file")
  df <- readr::read_tsv(fileQ)
  df <- df[, names(df) %in% cols, drop = FALSE]
  
  cols_pri <- c("pep_ms2_deltas", "pep_ms2_ideltas", "pep_ms2_iexs")
  cols_sec <- c("pep_ms2_deltas2", "pep_ms2_ideltas2", "pep_ms2_iexs2")
  
  if (!all(oks <- cols_pri %in% names(df))) {
    warning("PSM columns not found: ", paste(cols_pri[!oks], collapse = ", "), 
            "\nPlease use the latest version of mzion.")
    return(NULL)
  }
  
  if (!all(oks <- cols_sec %in% names(psm))) {
    warning("PSM columns not found: ", paste(cols_sec[!oks], collapse = ", "), 
            "\nPlease use the latest version of mzion.")
    return(NULL)
  }
  
  df <- df[df$pep_rank == 1L, ]
  df <- dplyr::arrange(df, -pep_score)
  df <- tidyr::unite(df, uid2, pep_seq, pep_ivmod, sep = "@", remove = FALSE)
  df <- df[!duplicated(df$uid2), ]
  df$uid2 <- NULL
  # df <- df[with(df, pep_score >= quantile(pep_score, .05)), ]
  df <- df[with(df, pep_score >= score_co), ]
  df <- df[with(df, abs(pep_ms2_deltas_mean) <= mdev_co), ]
  df <- df[with(df, pep_ms2_deltas_sd <= sd_co), ]

  if (all(is.na(df$pep_ms2_moverzs)) || all(is.na(df$pep_ms2_ints))) {
    mgf_path  <- match_mgf_path(out_path)
    mgf_files <- list.files(file.path(mgf_path), "mgf_queries_.*\\.rds$")
    
    if (!length(mgf_files)) {
      warning("Processed `mgf_queries.rds` not found under ", mgf_path)
      return(NULL)
    }
    
    mgfs <- lapply(mgf_files, function (x) qs::qread(file.path(mgf_path, x)))
    mgfs <- do.call(rbind, mgfs)
    mgfs <- dplyr::mutate(mgfs, scan_num = as.character(scan_num))
    mgfs <- mgfs[, c("raw_file", "scan_num", "ms2_moverz", "ms2_int")]
    mgfs <- tidyr::unite(mgfs, uid, raw_file, scan_num, sep = "@", remove = TRUE)
    
    raw_files <- unique(df$raw_file)
    raw_ids <- unlist(lapply(raw_files, match_raw_id, mgf_path))
    names(raw_ids) <- raw_files
    df$raw_file <- unname(raw_ids[df$raw_file])
    df <- tidyr::unite(df, uid, raw_file, pep_scan_num, sep = "@", remove = FALSE)
    df <- dplyr::left_join(df, mgfs, by = "uid")
    rm(list = c("mgfs", "raw_files", "raw_ids", "mgf_path", "mgf_files"))
    df$uid <- NULL

    df$pep_ms2_moverzs <- lapply(df$ms2_moverz, function (x) 
      .Internal(paste0(list(x), collapse = ";", recycle0 = FALSE)))
    df$pep_ms2_ints <- lapply(df$ms2_int, function (x) 
      .Internal(paste0(list(x), collapse = ";", recycle0 = FALSE)))
  }
  
  readr::write_tsv(dplyr::select(df, -c("ms2_moverz", "ms2_int")),
                   file.path(out_path, "psmLib.txt"))
  df$pep_ms2_moverzs <- df$ms2_moverz
  df$pep_ms2_ints <- df$ms2_int
  df$ms2_moverz <- df$ms2_int <- NULL
  
  purrr::walk(cols_pri, function (x) df[[x]] <<- strsplit(df[[x]], ";"))
  df$pep_ms2_deltas <- lapply(df$pep_ms2_deltas, function (x) as.numeric(x)/1E3)
  df$pep_ms2_ideltas <- lapply(df$pep_ms2_ideltas, as.integer)
  df$pep_ms2_iexs <- lapply(df$pep_ms2_iexs, as.integer)
  
  purrr::walk(cols_sec, function (x) df[[x]] <<- strsplit(df[[x]], ";"))
  df$pep_ms2_deltas2 <- lapply(df$pep_ms2_deltas2, function (x) as.numeric(x)/1E3)
  df$pep_ms2_ideltas2 <- lapply(df$pep_ms2_ideltas2, as.integer)
  df$pep_ms2_iexs2 <- lapply(df$pep_ms2_iexs2, as.integer)
  
  qs::qsave(df, file.path(out_path, "psmLib.rds"), preset = "fast")
}


#' Gets column types.
#' 
#' @import readr
#' @export
get_mzion_coltypes <- function () 
{
  col_types_pq <- cols(
    prot_acc = col_character(), 
    prot_issig = col_logical(), 
    prot_isess = col_logical(),
    prot_tier = col_integer(), 
    prot_hit_num = col_integer(), 
    prot_family_member = col_integer(), 
    prot_es = col_number(), 
    prot_es_co = col_number(), 
    pep_seq = col_character(), 
    pep_n_ms2 = col_integer(), 
    pep_scan_title = col_character(), 
    pep_exp_mz = col_number(),
    pep_exp_mr = col_number(), 
    pep_exp_z = col_character(), 
    pep_calc_mr = col_number(), 
    pep_delta = col_number(),
    pep_tot_int = col_number(), 
    pep_ret_range = col_number(), 
    pep_scan_num = col_character(), # timsTOF
    pep_mod_group = col_integer(), 
    pep_fmod = col_character(),
    pep_vmod = col_character(),
    pep_isdecoy = col_logical(),
    pep_ivmod = col_character(),
    pep_len = col_integer(), 
    
    pep_ms2_moverzs = col_character(),
    pep_ms2_ints = col_character(), 
    pep_ms2_theos = col_character(),
    pep_ms2_theos2 = col_character(),
    pep_ms2_exptints = col_character(),
    pep_ms2_exptints2 = col_character(),
    
    pep_n_matches = col_integer(), 
    pep_n_matches2 = col_integer(),
    pep_ms2_deltas = col_character(),
    pep_ms2_ideltas = col_character(),
    pep_ms2_deltas2 = col_character(), 
    pep_ms2_ideltas2 = col_character(),
    pep_ms2_deltas_mean = col_double(),
    pep_ms2_deltas_sd = col_double(),
    
    pep_issig = col_logical(),
    pep_score = col_double(),
    # pep_score_co = col_double(),
    pep_rank = col_integer(), 
    pep_locprob = col_double(),
    pep_locdiff = col_double(),
    # pep_rank_nl = col_integer(), 
    pep_literal_unique = col_logical(),
    pep_razor_unique = col_logical(),
    raw_file = col_character(), 
  )
  
  nms <- names(col_types_pq$cols)
  
  stopifnot(length(nms) == length(unique(nms)))
  
  col_types_pq
}


#' Checks file names for ggsave
#' 
#' The same as proteoQ::gg_imgname.
#' 
#' @param filename Character string; An output file name.
check_ggname <- function(filename) 
{
  fn_suffix <- gsub("^.*\\.([^.]*)$", "\\1", filename)
  fn_prefix <- gsub("\\.[^.]*$", "", filename)
  
  exts <- c("png", "eps", "ps", "tex", "pdf", "jpeg", "tiff", "png", "bmp", "svg") 
  
  if(!fn_suffix %in% exts) {
    warning("Unrecognized file extenstion: '", fn_suffix, 
            "'. Image will be saved as a '.png'.", 
            call. = FALSE)
    
    fn_suffix <- "png"
  }
  
  paste0(fn_prefix, ".", fn_suffix)
}
#' Helper in loading MGFs.
#' 
#' @param topn_dia_ms2ions The top-n DIA-MS2 ions for deisotoping.
#' @param is_ms1_three_frame Logical; is the searches by the three frames of
#'   preceding, current and following.
#' @param is_ms2_three_frame Logical; is the searches by the three frames of
#'   preceding, current and following.
#' @param mgf_cutmzs Cut points of MS1 m-over-z values in peak picking.
#' @param mgf_cutpercs The counts of MS2 features in each region of
#'   \code{mgf_cutmzs}.
#' @inheritParams matchMS
load_mgfs <- function (out_path = NULL, mgf_path = NULL, topn_ms2ions = 150L, 
                       maxn_dia_precurs = 1000L, # max MS1 deisotoping features
                       topn_dia_ms2ions = 500L, # max MS2 deisotoping features
                       delayed_diams2_tracing = FALSE, 
                       n_dia_ms2bins = 3L, n_dia_scans = 4L, 
                       min_mass = 200L, max_mass = 4500L, 
                       min_ms2mass = 115L, max_ms2mass = 4500L, 
                       min_ms1_charge = 2L, max_ms1_charge = 4L, 
                       min_scan_num = 1L, max_scan_num = .Machine$integer.max, 
                       min_ret_time = 0, max_ret_time = Inf, 
                       ppm_ms1 = 20L, ppm_ms2 = 20L, 
                       tmt_reporter_lower = 126.1, tmt_reporter_upper = 135.2, 
                       exclude_reporter_region = FALSE, 
                       is_ms1_three_frame = TRUE, is_ms2_three_frame = TRUE, 
                       mgf_cutmzs = numeric(), mgf_cutpercs = numeric(), 
                       enzyme = "trypsin_p", 
                       deisotope_ms2 = TRUE, grad_isotope = 1.6, fct_iso2 = 3.0,
                       max_ms2_charge = 3L, use_defpeaks = FALSE, 
                       maxn_mdda_precurs = 1L, n_mdda_flanks = 6L, 
                       ppm_ms1_deisotope = 8L, ppm_ms2_deisotope = 8L, 
                       quant = "none", use_lfq_intensity = TRUE, digits = 4L) 
{
  old_opts <- options()
  options(warn = 1L)
  on.exit(options(old_opts), add = TRUE)
  
  on.exit(
    if (exists(".savecall", envir = fun_env)) {
      if (.savecall) {
        save_call2(path = file.path(out_path, "Calls"), fun = fun)
      }
    }, add = TRUE)

  # ---
  this_call <- match.call()
  fun <- as.character(this_call[[1]])
  fun <- fun[length(fun)] # may be called as mzion:::load_mgfs
  fun_env <- environment()
  
  args_except <- c("out_path", "use_lfq_intensity")
  args <- names(formals(fun))
  args_must <- args[!args %in% args_except]
  
  cache_pars <- find_callarg_vals(
    time = NULL, 
    path = file.path(out_path, "Calls"), 
    fun = paste0(fun, ".rda"), 
    args = args_must, 
    new_args = unlist(formals(load_mgfs)[c("enzyme")]))

  cache_pars <- cache_pars[sort(names(cache_pars))]
  call_pars <- mget(args_must, envir = fun_env, inherits = FALSE)
  call_pars <- call_pars[sort(names(call_pars))]
  ok_pars <- identical(call_pars, cache_pars)
  
  # suboptimal for handling matchMS_noenzyme()
  if ((!ok_pars) && isTRUE(enzyme == "noenzyme")) 
    ok_pars <- TRUE
  
  scns <- list.files(mgf_path, pattern = "^scan_map_.*\\.rds$")
  ques <- list.files(mgf_path, pattern = "^mgf_queries_.*\\.rds$")
  n_scns <- length(scns)
  n_ques <- length(ques)
  
  if (n_scns) {
    ok_mgfs <- if (n_scns == n_ques) TRUE else FALSE
  }
  else {
    # backward compatible
    ok_mgfs <- local({
      raws_indexes <- file.path(mgf_path, "raw_indexes.rds")
      
      if (file.exists(raws_indexes)) {
        raws <- qs::qread(raws_indexes)
        ques <- list.files(mgf_path, pattern = "^mgf_queries_\\d+\\.rds$")
        if (length(raws) == length(ques)) TRUE else FALSE
      }
      else {
        FALSE
      }
    })
  }

  rm(list = c("scns", "ques", "n_scns", "n_ques"))
  
  file_type_acqu <- file.path(mgf_path, "type_acqu.rds")
  ok_type_acqu <- file.exists(file_type_acqu)

  if (ok_pars && ok_mgfs && ok_type_acqu) {
    message("Found cached MGFs.")
    .savecall <- FALSE
    type_acqu <- qs::qread(file_type_acqu)
    return(type_acqu)
  }
  
  ppm_ms1_bin <- calc_threeframe_ppm(ppm_ms1)
  ppm_ms2_bin <- calc_threeframe_ppm(ppm_ms2)

  delete_files(
    out_path, 
    ignores = c("\\.[Rr]$", "\\.(mgf|MGF)$", "\\.(mzML|mzml)$", "\\.(raw|RAW)$", 
                "\\.xlsx$", "\\.xls$", "\\.csv$", "\\.txt$", "\\.pars$", 
                "^mgf$", "^mgfs$", "^mzML$", "^mzMLs$", "^raw$", 
                "Calls", "^PSM$", "^Peptide$", "^Protein$", 
                "fraction_scheme.rda", "label_scheme.rda", 
                "label_scheme_full.rda"))

  fi_mgf   <- list.files(path = mgf_path, pattern = "^.*\\.(mgf|MGF)$")
  fi_mzml  <- list.files(path = mgf_path, pattern = "^.*\\.(mzML|mzml)$")
  fi_raw   <- list.files(path = mgf_path, pattern = "^.*\\.(raw|RAW)$")
  len_mgf  <- length(fi_mgf)
  len_mzml <- length(fi_mzml)
  len_raw <- length(fi_raw)
  
  data_type <- if (len_raw) {
    "raw"
  } else if (len_mzml) {
    "mzml"
  } else if (len_mgf) {
    "mgf"
  }
  
  if (len_mgf && len_mzml || len_mgf && len_raw || len_raw && len_mzml)
    stop("Peak lists need to be exactly in one of MGF, mzML or RAW.")
  
  filelist <- if (len_mgf) fi_mgf else if (len_mzml) fi_mzml else fi_raw

  if (len_mgf) {
    type_acqu <- readMGF(
      filepath = mgf_path,
      filelist = filelist, 
      out_path = out_path, 
      topn_ms2ions = topn_ms2ions,
      min_mass = min_mass,
      max_mass = max_mass, 
      min_ms2mass = min_ms2mass,
      max_ms2mass = max_ms2mass, 
      min_ms1_charge = min_ms1_charge, 
      max_ms1_charge = max_ms1_charge,
      min_scan_num = min_scan_num, 
      max_scan_num = max_scan_num, 
      min_ret_time = min_ret_time, 
      max_ret_time = max_ret_time, 
      ppm_ms1 = ppm_ms1_bin, # change arg name from ppm_ms1 to ppm_ms1_bin
      ppm_ms2 = ppm_ms2_bin, # change arg name from ppm_ms2 to ppm_ms2_bin
      tmt_reporter_lower = tmt_reporter_lower, 
      tmt_reporter_upper = tmt_reporter_upper, 
      exclude_reporter_region = exclude_reporter_region, 
      mgf_cutmzs = mgf_cutmzs, 
      mgf_cutpercs = mgf_cutpercs, 
      use_defpeaks = use_defpeaks, 
      deisotope_ms2 = deisotope_ms2, 
      max_ms2_charge = max_ms2_charge, 
      maxn_dia_precurs = maxn_dia_precurs, 
      maxn_mdda_precurs = maxn_mdda_precurs, 
      n_mdda_flanks = n_mdda_flanks, 
      ppm_ms1_deisotope = ppm_ms1_deisotope, 
      ppm_ms2_deisotope = ppm_ms2_deisotope, 
      quant = quant, 
      digits = digits)
  }
  else if (len_mzml || len_raw) {
    type_acqu <- readmzML(
      filelist = filelist, 
      mgf_path = mgf_path, 
      data_type = data_type, 
      topn_ms2ions = topn_ms2ions, 
      topn_dia_ms2ions = topn_dia_ms2ions, 
      maxn_dia_precurs = maxn_dia_precurs, 
      n_dia_ms2bins = n_dia_ms2bins, 
      n_dia_scans = n_dia_scans, 
      delayed_diams2_tracing = delayed_diams2_tracing, 
      min_mass = min_mass, 
      max_mass = max_mass, 
      min_ms2mass = min_ms2mass, 
      max_ms2mass = max_ms2mass, 
      min_ms1_charge = min_ms1_charge, 
      max_ms1_charge = max_ms1_charge, 
      min_scan_num = min_scan_num, 
      max_scan_num = max_scan_num, 
      min_ret_time = min_ret_time, 
      max_ret_time = max_ret_time, 
      ppm_ms1 = ppm_ms1_bin, # change arg name from ppm_ms1 to ppm_ms1_bin
      ppm_ms2 = ppm_ms2_bin, # change arg name from ppm_ms2 to ppm_ms2_bin
      tmt_reporter_lower = tmt_reporter_lower, 
      tmt_reporter_upper = tmt_reporter_upper, 
      exclude_reporter_region = exclude_reporter_region, 
      is_ms1_three_frame = is_ms1_three_frame, 
      is_ms2_three_frame = is_ms2_three_frame, 
      mgf_cutmzs = mgf_cutmzs, 
      mgf_cutpercs = mgf_cutpercs, 
      enzyme = enzyme, 
      deisotope_ms2 = deisotope_ms2, 
      grad_isotope = grad_isotope, 
      fct_iso2 = fct_iso2,
      max_ms2_charge = max_ms2_charge, 
      use_defpeaks = use_defpeaks, 
      maxn_mdda_precurs = maxn_mdda_precurs, 
      n_mdda_flanks = n_mdda_flanks, 
      ppm_ms1_deisotope = ppm_ms1_deisotope, 
      ppm_ms2_deisotope = ppm_ms2_deisotope, 
      quant = quant, 
      use_lfq_intensity = use_lfq_intensity, 
      digits = digits)
  }
  else {
    stop("No peak lists at an mzML, MGF or RAW format were found.")
  }
  
  .savecall <- TRUE

  qs::qsave(type_acqu, file.path(mgf_path, "type_acqu.rds"))
  
  type_acqu
}


#' Reads MGF files in chunks.
#'
#' @param filepath The file path to a list of MGF or mzML files.
#' @param filelist A list of MGF or mzML files.
#' @param min_mass Numeric; the minimum mass of MS1 species. The value needs to
#'   match the one in  \link{binTheoSeqs}.
#' @param topn_ms2ions A non-negative integer; the top-n species for uses in
#'   MS2 ion searches. The default is to use the top-100 ions in an MS2 event.
#' @param out_path An output path.
#' @inheritParams load_mgfs
#' @inheritParams matchMS
#' @inheritParams frames_adv
#' @import stringi
#' @import readr
#' @import fs
readMGF <- function (filepath = NULL, filelist = NULL, out_path = NULL, 
                     topn_ms2ions = 150L, min_mass = 200L, max_mass = 4500L, 
                     min_ms2mass = 115L, max_ms2mass = 4500L, 
                     min_ms1_charge = 2L, max_ms1_charge = 4L,
                     min_scan_num = 1L, max_scan_num = .Machine$integer.max, 
                     min_ret_time = 0, max_ret_time = Inf, 
                     ppm_ms1 = 10L, ppm_ms2 = 10L, 
                     tmt_reporter_lower = 126.1, tmt_reporter_upper = 135.2, 
                     exclude_reporter_region = FALSE, 
                     mgf_cutmzs = numeric(), mgf_cutpercs = numeric(), 
                     deisotope_ms2 = TRUE, max_ms2_charge = 3L, 
                     use_defpeaks = FALSE, maxn_dia_precurs = 1000L, 
                     maxn_mdda_precurs = 1L, n_mdda_flanks = 6L, 
                     ppm_ms1_deisotope = 8L, ppm_ms2_deisotope = 8L, 
                     quant = "none", digits = 4L) 
{
  message("Processing MGF lists.")
  
  if (maxn_mdda_precurs >= 1L) {
    warning("No multi-precursor DDA with MGF. Use mzML to enable the feature.")
    maxn_mdda_precurs <- 0L
  }

  ## Parsing rules
  pat_mgf <- find_mgf_type(file.path(filepath, filelist[[1]]))
  type_mgf <- pat_mgf$type
  n_bf_begin <- pat_mgf$n_bf_begin
  n_spacer <- pat_mgf$n_spacer
  n_hdr <- pat_mgf$n_hdr
  n_to_pepmass <- pat_mgf$n_to_pepmass
  n_to_title <- pat_mgf$n_to_title
  n_to_scan <- pat_mgf$n_to_scan
  n_to_rt <- pat_mgf$n_to_rt
  n_to_charge <- pat_mgf$n_to_charge
  sep_ms2s <- pat_mgf$sep_ms2s
  nfields_ms2s <- pat_mgf$nfields_ms2s
  sep_pepmass <- pat_mgf$sep_pepmass
  nfields_pepmass <- pat_mgf$nfields_pepmass
  raw_file <- pat_mgf$raw_file
  
  len <- length(filelist)
  
  if (type_mgf == "default_pasef") {
    mprepBrukerMGF(filepath, len)
  }

  local({
    if (type_mgf == "msconv_thermo") {
      data_format <- "Thermo-RAW"
      mgf_format <- "MSconvert"
    }
    else if (type_mgf == "pd") {
      data_format <- "Thermo-RAW"
      mgf_format <- "Thermo-ProteomeDiscoverer"
    }
    else if (type_mgf == "msconv_pasef") {
      data_format <- "Bruker-D"
      mgf_format <- "MSconvert"
    }
    else if (type_mgf == "default_pasef") {
      data_format <- "Bruker-D"
      mgf_format <- "Bruker-DataAnalysis"
    }
    
    qs::qsave(list(data_format = data_format, mgf_format = mgf_format), 
              file.path(filepath, "info_format.rds"), preset = "fast")
  })

  ## Reads MGF into chunks
  # separate parallel process: 
  # (1) one large MGF file and parallel chunks
  # (2) parallel five MGF files and parallel chunks in each
  
  n_cores <- min(len, detect_cores(32L))
  
  if (n_cores == 1L) {
    raw_files <- vector("list", len)
    
    for (i in 1:len) {
      raw_files[[i]] <- readlineMGFs(i, filelist[[i]], filepath, raw_file)
    }
  }
  else {
    cl <- parallel::makeCluster(getOption("cl.cores", n_cores))
    raw_files <- parallel::clusterMap(cl, readlineMGFs, 
                                      1:len, filelist, 
                                      MoreArgs = list(filepath = filepath, 
                                                      raw_file = raw_file), 
                                      SIMPLIFY = FALSE, USE.NAMES = FALSE)
    parallel::stopCluster(cl)
  }
  
  ## Reads from chunks
  warning("An mzML or MGF with multiple RAWs not supported since v1.3.4. ", 
          "Each peaklist file need contain exactly one RAW file.")

  out <- vector("list", len)
  
  for (i in seq_along(filelist)) {
    file <- filelist[i]
    temp_dir <- file.path(filepath, paste0("temp_", i))
    
    message("Loading '", file, "'.")
    
    out[[i]] <- read_mgf_chunks(
      filepath = filepath, 
      temp_dir = temp_dir, 
      raw_id = i, 
      topn_ms2ions = topn_ms2ions,
      min_ms1_charge = min_ms1_charge, 
      max_ms1_charge = max_ms1_charge, 
      min_scan_num = min_scan_num, 
      max_scan_num = max_scan_num, 
      min_ret_time = min_ret_time, 
      max_ret_time = max_ret_time, 
      min_mass = min_mass, 
      max_mass = max_mass, 
      min_ms2mass = min_ms2mass,
      max_ms2mass = max_ms2mass, 
      ppm_ms1 = ppm_ms1, 
      ppm_ms2 = ppm_ms2,
      mgf_cutmzs = mgf_cutmzs, 
      mgf_cutpercs = mgf_cutpercs, 
      type_mgf = type_mgf, 
      n_bf_begin = n_bf_begin, 
      n_spacer = n_spacer,
      n_hdr = n_hdr,
      n_to_pepmass = n_to_pepmass,
      n_to_title = n_to_title,
      n_to_scan = n_to_scan,
      n_to_rt = n_to_rt,
      n_to_charge = n_to_charge, 
      sep_ms2s = sep_ms2s, 
      nfields_ms2s = nfields_ms2s, 
      sep_pepmass = sep_pepmass, 
      nfields_pepmass = nfields_pepmass, 
      # raw_files == list() and no raw_files[[1]] at single Thermo MGF file
      raw_file = if (len <= 1L && !length(raw_files)) raw_files else raw_files[[i]], 
      tmt_reporter_lower = tmt_reporter_lower, 
      tmt_reporter_upper = tmt_reporter_upper, 
      exclude_reporter_region = exclude_reporter_region, 
      use_defpeaks = use_defpeaks, 
      deisotope_ms2 = deisotope_ms2, 
      max_ms2_charge = max_ms2_charge, 
      maxn_dia_precurs = maxn_dia_precurs, 
      maxn_mdda_precurs = maxn_mdda_precurs, 
      n_mdda_flanks = n_mdda_flanks, 
      ppm_ms1_deisotope = ppm_ms1_deisotope, 
      ppm_ms2_deisotope = ppm_ms2_deisotope, 
      quant = quant, 
      digits = digits)
    
    local({
      dir2 <- file.path(filepath, gsub("\\.[^.]*$", "", file))
      dir.create(dir2, showWarnings = FALSE)
      dir2 <- find_dir(dir2)
      
      if (fs::file_exists(dir2)) 
        fs::file_delete(dir2)
      
      fs::file_move(temp_dir, dir2)
    })
  }
  
  raws <- unlist(out, recursive = FALSE, use.names = TRUE)
  qs::qsave(raws, file.path(filepath, "raw_indexes.rds"), preset = "fast")

  type_acqu <- "dda"
}


#' Post-processing of MGF or mzML
#' 
#' Calculates mass \code{frame}s etc.
#' 
#' @param df A data frame of processed peak lists.
#' @param raw_id An ID to replace the original RAW file name.
#' @param mgf_path A path to mzML or MGF files.
post_readmgf <- function (df, raw_id, mgf_path) 
{
  raw <- unique(df$raw_file)
  
  if (length(raw) > 1L)
    stop("An mzML or MGF with multiple RAWs not supported since v1.3.4. ", 
         "Each peaklist file need contain exactly one RAW file.")
  
  raw_map <- raw_id
  names(raw_map) <- raw
  df$raw_file <- raw_id
  
  scans <- df$scan_title
  scans_map <- df$scan_title <- seq_along(scans)
  names(scans_map) <- scans
  
  qs::qsave(df, file.path(mgf_path, paste0("mgf_queries_", raw, ".rds")), 
            preset = "fast")
  qs::qsave(scans_map, file.path(mgf_path, paste0("scan_map_", raw, ".rds")), 
            preset = "fast")

  invisible(raw_map)
}


#' Helper of \link{readMGF}.
#'
#' @param i An index of the i-th file.
#' @param file An MGF file name.
#' @inheritParams readMGF
#' @inheritParams read_mgf_chunks
#' @return Updated raw_file (for Bruker's timsTOF). Otherwise, raw_file remains
#'   NULL.
readlineMGFs <- function (i, file, filepath, raw_file) 
{
  f <- function(x, pos) {
    nm <- file.path(filepath, temp_i, paste0("chunk", "_", pos, ".mgf"))
    writeLines(x, nm)
  }
  
  temp_i <- paste0("temp_", i)
  
  # refresh at every `i`
  temp_dir <- local({
    path <- file.path(filepath, temp_i)
    ok <- find_dir(path)
    if (!is.null(ok)) fs::file_delete(ok)
    dir.create(path, showWarnings = FALSE)
    find_dir(path)
  })
  
  readr::read_lines_chunked(
    file = file.path(filepath, file),
    callback = SideEffectChunkCallback$new(f),
    chunk_size = 1000000L)
  
  # for "default_pasef" format
  if (!is.null(raw_file)) {
    raw_file <- local({
      file <- file.path(temp_dir, "chunk_1.mgf")
      hdr <- readLines(file, 50L)
      pat <- "^COM="
      line_file <- hdr[grepl(pat, hdr)]
      gsub(pat, "", line_file)
    })
  }
  
  invisible(raw_file)
}


#' Reads MGFs in chunks.
#'
#' @param temp_dir A temporary path of MGFs.
#' @param raw_id An ID to RAW file name.
#' @param type_mgf The type of MGF format.
#' @param n_bf_begin The number of lines before \code{BEGIN IONS}. Zero for PD
#'   and MSConvert.
#' @param n_spacer The number of spacer lines between the preceding line END
#'   IONS and the following line BEGIN IONS. The value is 1 for Proteome
#'   Discoverer and 0 for MSConvert.
#' @param n_hdr The number of lines before MS2 data in an MGF. The value is +6
#'   for PD and +5 for MSConvert.
#' @param n_to_pepmass The number of lines from BEGIN to PEPMASS.
#' @param n_to_title The number of lines from BEGIN to TITLE. The value is the
#'   same between PD and MSConvert.
#' @param n_to_scan The number of lines from BEGIN to SCANS. The value is +5 for
#'   PD.
#' @param n_to_rt The number of lines from BEGIN to RTINSECONDS.
#' @param n_to_charge The number of lines from BEGIN to CHARGE.
#' @param sep_ms2s The separation character between MS2 m/z and intensity
#'   values.
#' @param nfields_ms2s The number of fields in MS2 entries. Mostely two and can
#'   be three for some Bruker MGFs.
#' @param sep_pepmass The separation character between MS1 m/z and intensity
#'   values.
#' @param nfields_pepmass The number of fields in \code{PEPMASS}.
#' @param raw_file The raw file name. Is NULL for PD and MSConvert.
#' @inheritParams readMGF
#' @inheritParams matchMS
read_mgf_chunks <- function (filepath, temp_dir, raw_id = 1L, topn_ms2ions = 150L, 
                             min_ms1_charge = 2L, max_ms1_charge = 4L,
                             min_scan_num = 1L, max_scan_num = .Machine$integer.max, 
                             min_ret_time = 0, max_ret_time = Inf, 
                             min_mass = 200L, max_mass = 4500L, 
                             min_ms2mass = 115L, max_ms2mass = 4500L, 
                             ppm_ms1 = 10L, ppm_ms2 = 10L, 
                             mgf_cutmzs = numeric(), mgf_cutpercs = numeric(), 
                             type_mgf = "msconv_thermo", n_bf_begin = 0L, 
                             n_spacer = 0L, n_hdr = 5L, n_to_pepmass = 3L, 
                             n_to_title = 1L, n_to_scan = 0L, n_to_rt = 2L, 
                             n_to_charge = 4L, sep_ms2s = " ", nfields_ms2s = 2L, 
                             sep_pepmass = " ", nfields_pepmass = 2L, 
                             raw_file = NULL, 
                             tmt_reporter_lower = 126.1, tmt_reporter_upper = 135.2, 
                             exclude_reporter_region = FALSE, 
                             deisotope_ms2 = TRUE, max_ms2_charge = 3L, 
                             maxn_dia_precurs = 1000L, 
                             use_defpeaks = FALSE, 
                             maxn_mdda_precurs = 5L, n_mdda_flanks = 6L, 
                             ppm_ms1_deisotope = 10L, ppm_ms2_deisotope = 10L, 
                             quant = "none", digits = 4L) 
{
  filelist <- list.files(path = temp_dir, pattern = "^.*\\.mgf$")
  
  if (!(len <- length(filelist))) 
    stop("No mgf files under ", temp_dir)
  
  if (len == 1L) {
    out <- proc_mgf_chunks(
      file.path(temp_dir, filelist),
      topn_ms2ions = topn_ms2ions,
      min_ms1_charge = min_ms1_charge, 
      max_ms1_charge = max_ms1_charge,
      min_scan_num = min_scan_num, 
      max_scan_num = max_scan_num, 
      min_ret_time = min_ret_time, 
      max_ret_time = max_ret_time, 
      min_mass = min_mass, 
      max_mass = max_mass, 
      min_ms2mass = min_ms2mass,
      max_ms2mass = max_ms2mass, 
      ppm_ms1 = ppm_ms1,
      ppm_ms2 = ppm_ms2,
      mgf_cutmzs = mgf_cutmzs, 
      mgf_cutpercs = mgf_cutpercs, 
      type_mgf = type_mgf,
      n_bf_begin = n_bf_begin, 
      n_spacer = n_spacer,
      n_hdr = n_hdr,
      n_to_pepmass = n_to_pepmass,
      n_to_title = n_to_title,
      n_to_scan = n_to_scan,
      n_to_rt = n_to_rt,
      n_to_charge = n_to_charge, 
      sep_ms2s = sep_ms2s, 
      nfields_ms2s = nfields_ms2s, 
      sep_pepmass = sep_pepmass, 
      nfields_pepmass = nfields_pepmass, 
      raw_file = raw_file, 
      tmt_reporter_lower = tmt_reporter_lower, 
      tmt_reporter_upper = tmt_reporter_upper, 
      exclude_reporter_region = exclude_reporter_region, 
      deisotope_ms2 = deisotope_ms2, 
      max_ms2_charge = max_ms2_charge, 
      use_defpeaks = use_defpeaks, 
      maxn_dia_precurs = maxn_dia_precurs, 
      maxn_mdda_precurs = maxn_mdda_precurs, 
      n_mdda_flanks = n_mdda_flanks, 
      ppm_ms1_deisotope = ppm_ms1_deisotope, 
      ppm_ms2_deisotope = ppm_ms2_deisotope, 
      quant = quant, 
      digits = digits)
  }
  else {
    n_cores <- min(detect_cores(32L), len)
    cl <- parallel::makeCluster(getOption("cl.cores", n_cores))
    
    parallel::clusterExport(
      cl, 
      c("stri_startswith_fixed", 
        "stri_endswith_fixed", 
        "stri_replace_first_fixed", 
        "stri_split_fixed"), 
      envir = environment(stringi::stri_startswith_fixed)
    )
    
    parallel::clusterExport(
      cl,
      c("proc_mgf_chunks", 
        "proc_mgfs", 
        "which_topx2", 
        "index_mz", 
        "integerize_ms2ints"), 
      envir = environment(mzion::matchMS)
    )
    
    out <- parallel::clusterApply(
      cl, file.path(temp_dir, filelist),
      proc_mgf_chunks,
      topn_ms2ions = topn_ms2ions,
      min_ms1_charge = min_ms1_charge, 
      max_ms1_charge = max_ms1_charge,
      min_scan_num = min_scan_num, 
      max_scan_num = max_scan_num, 
      min_ret_time = min_ret_time, 
      max_ret_time = max_ret_time, 
      min_mass = min_mass, 
      max_mass = max_mass, 
      min_ms2mass = min_ms2mass,
      max_ms2mass = max_ms2mass, 
      ppm_ms1 = ppm_ms1,
      ppm_ms2 = ppm_ms2,
      mgf_cutmzs = mgf_cutmzs, 
      mgf_cutpercs = mgf_cutpercs, 
      type_mgf = type_mgf,
      n_bf_begin = n_bf_begin, 
      n_spacer = n_spacer,
      n_hdr = n_hdr,
      n_to_pepmass = n_to_pepmass,
      n_to_title = n_to_title,
      n_to_scan = n_to_scan,
      n_to_rt = n_to_rt,
      n_to_charge = n_to_charge, 
      sep_ms2s = sep_ms2s, 
      nfields_ms2s = nfields_ms2s, 
      sep_pepmass = sep_pepmass, 
      nfields_pepmass = nfields_pepmass, 
      raw_file = raw_file, 
      tmt_reporter_lower = tmt_reporter_lower, 
      tmt_reporter_upper = tmt_reporter_upper, 
      exclude_reporter_region = exclude_reporter_region, 
      deisotope_ms2 = deisotope_ms2, 
      max_ms2_charge = max_ms2_charge, 
      use_defpeaks = use_defpeaks, 
      maxn_dia_precurs = maxn_dia_precurs, 
      maxn_mdda_precurs = maxn_mdda_precurs, 
      n_mdda_flanks = n_mdda_flanks, 
      ppm_ms1_deisotope = ppm_ms1_deisotope, 
      ppm_ms2_deisotope = ppm_ms2_deisotope, 
      quant = quant, 
      digits = digits)
    
    parallel::stopCluster(cl)
    
    out <- dplyr::bind_rows(out)
  }
  
  # adds back broken mgf entries
  afs <- local({
    afs <- list.files(path = temp_dir, pattern = "^.*\\_af.mgf$")
    idxes <- sort(as.integer(gsub("^chunk_(\\d+)_af\\.mgf", "\\1", afs)))
    afs <- paste0("chunk_", idxes, "_af.mgf")
    afs <- afs[-length(afs)]
  })
  
  bfs <- local({
    bfs <- list.files(path = temp_dir, pattern = "^.*\\_bf.mgf$")
    idxes <- sort(as.integer(gsub("^chunk_(\\d+)_bf\\.mgf", "\\1", bfs)))
    bfs <- paste0("chunk_", idxes, "_bf.mgf")
    bfs <- bfs[-1]
  })
  
  # stopifnot(length(afs) == length(bfs))
  
  gaps <- purrr::map2(afs, bfs, function (x, y) {
    af <- stringi::stri_read_lines(file.path(temp_dir, x))
    bf <- stringi::stri_read_lines(file.path(temp_dir, y))
    ab <- append(af, bf)
    # perfect case of no gaps: two lines of "" and ""
    if (length(ab) > 2L) ab else NULL
  })
  
  gaps <- unlist(gaps, use.names = FALSE)
  write(gaps, file.path(temp_dir, "gaps.mgf"))
  
  local({
    nms <- list.files(path = file.path(temp_dir), pattern = "^.*\\_[ab]f.mgf$")
    if (length(nms)) suppressMessages(file.remove(file.path(temp_dir, nms)))
  })
  
  if (!is.null(gaps)) {
    out <- dplyr::bind_rows(
      out,
      proc_mgfs(lines = gaps,
                topn_ms2ions = topn_ms2ions,
                min_ms1_charge = min_ms1_charge, 
                max_ms1_charge = max_ms1_charge,
                min_scan_num = min_scan_num, 
                max_scan_num = max_scan_num, 
                min_ret_time = min_ret_time, 
                max_ret_time = max_ret_time, 
                min_mass = min_mass, 
                max_mass = max_mass, 
                min_ms2mass = min_ms2mass,
                max_ms2mass = max_ms2mass, 
                ppm_ms1 = ppm_ms1,
                ppm_ms2 = ppm_ms2,
                mgf_cutmzs = mgf_cutmzs, 
                mgf_cutpercs = mgf_cutpercs, 
                type_mgf = type_mgf, 
                n_bf_begin = n_bf_begin, 
                n_spacer = n_spacer,
                n_hdr = n_hdr,
                n_to_pepmass = n_to_pepmass,
                n_to_title = n_to_title,
                n_to_scan = n_to_scan,
                n_to_rt = n_to_rt,
                n_to_charge = n_to_charge, 
                sep_ms2s = sep_ms2s, 
                nfields_ms2s = nfields_ms2s, 
                sep_pepmass = sep_pepmass, 
                nfields_pepmass = nfields_pepmass, 
                raw_file = raw_file, 
                tmt_reporter_lower = tmt_reporter_lower, 
                tmt_reporter_upper = tmt_reporter_upper, 
                exclude_reporter_region = exclude_reporter_region, 
                deisotope_ms2 = deisotope_ms2, 
                max_ms2_charge = max_ms2_charge, 
                use_defpeaks = use_defpeaks, 
                maxn_dia_precurs = maxn_dia_precurs, 
                maxn_mdda_precurs = maxn_mdda_precurs, 
                n_mdda_flanks = n_mdda_flanks, 
                ppm_ms1_deisotope = ppm_ms1_deisotope, 
                ppm_ms2_deisotope = ppm_ms2_deisotope, 
                quant = quant, 
                digits = digits)
    )
  }
  
  if (type_mgf == "default_pasef") {
    out <- dplyr::mutate(out, scan_id = as.character(scan_num), 
                         scan_num = as.character(row_number()))
  }
  
  post_readmgf(out, raw_id = raw_id, mgf_path = filepath) 
}


#' Processes MGF entries in chunks.
#'
#' @param file A chunk of MGF (chunk_1.mgf etc.) with a prepending file path.
#' @inheritParams readMGF
#' @inheritParams read_mgf_chunks
proc_mgf_chunks <- function (file, topn_ms2ions = 150L, 
                             min_ms1_charge = 2L, max_ms1_charge = 4L, 
                             min_scan_num = 1L, max_scan_num = .Machine$integer.max, 
                             min_ret_time = 0, max_ret_time = Inf, 
                             min_mass = 200L, max_mass = 4500L, 
                             min_ms2mass = 115L, max_ms2mass = 4500L, 
                             ppm_ms1 = 10L, ppm_ms2 = 10L, 
                             mgf_cutmzs = numeric(), mgf_cutpercs = numeric(), 
                             type_mgf = "msconv_thermo", n_bf_begin = 0L, 
                             n_spacer = 0L, n_hdr = 5L, n_to_pepmass = 3L, 
                             n_to_title = 1L, n_to_scan = 0L, n_to_rt = 2L, 
                             n_to_charge = 4L, sep_ms2s = " ", nfields_ms2s = 2L, 
                             sep_pepmass = " ", nfields_pepmass = 2L, 
                             raw_file = NULL, 
                             tmt_reporter_lower = 126.1, 
                             tmt_reporter_upper = 135.2, 
                             exclude_reporter_region = FALSE, 
                             deisotope_ms2 = TRUE, max_ms2_charge = 3L, 
                             use_defpeaks = FALSE, maxn_dia_precurs = 1000L, 
                             maxn_mdda_precurs = 5L, n_mdda_flanks = 6L, 
                             ppm_ms1_deisotope = 10L, ppm_ms2_deisotope = 10L, 
                             quant = "none", digits = 4L) 
{
  message("Parsing '", file, "'.")
  lines <- stringi::stri_read_lines(file)
  basename <- gsub("\\.[^.]*$", "", file)
  
  begins <- .Internal(which(stringi::stri_startswith_fixed(lines, "BEGIN IONS")))
  ends   <- .Internal(which(stringi::stri_endswith_fixed(lines, "END IONS")))

  af <- local({
    le <- ends[length(ends)]
    lb <- begins[length(begins)]
    af <- if (lb > le) lines[(le + n_spacer + 1L):length(lines)] else NULL
    write(af, file.path(paste0(basename, "_af.mgf")))

    af
  })

  bf <- local({
    le <- ends[1]
    lb <- begins[1]
    bf <- if (lb > le) lines[1:(le + n_spacer)] else NULL
    write(bf, file.path(paste0(basename, "_bf.mgf")))

    bf
  })

  if (!is.null(af)) 
    lines <- lines[1:(begins[length(begins)] - n_bf_begin- 1L)]

  if (!is.null(bf)) 
    lines <- lines[-c(1:(ends[1] + n_spacer))]

  out <- proc_mgfs(lines = lines,
                   topn_ms2ions = topn_ms2ions,
                   min_ms1_charge = min_ms1_charge, 
                   max_ms1_charge = max_ms1_charge,
                   min_scan_num = min_scan_num, 
                   max_scan_num = max_scan_num, 
                   min_ret_time = min_ret_time, 
                   max_ret_time = max_ret_time, 
                   min_mass = min_mass, 
                   max_mass = max_mass, 
                   min_ms2mass = min_ms2mass,
                   max_ms2mass = max_ms2mass, 
                   ppm_ms1 = ppm_ms1,
                   ppm_ms2 = ppm_ms2,
                   mgf_cutmzs = mgf_cutmzs, 
                   mgf_cutpercs = mgf_cutpercs, 
                   type_mgf = type_mgf, 
                   n_bf_begin = n_bf_begin,
                   n_spacer = n_spacer,
                   n_hdr = n_hdr,
                   n_to_pepmass = n_to_pepmass,
                   n_to_title = n_to_title,
                   n_to_scan = n_to_scan,
                   n_to_rt = n_to_rt,
                   n_to_charge = n_to_charge, 
                   sep_ms2s = sep_ms2s, 
                   nfields_ms2s = nfields_ms2s, 
                   sep_pepmass = sep_pepmass, 
                   nfields_pepmass = nfields_pepmass, 
                   raw_file = raw_file, 
                   tmt_reporter_lower = tmt_reporter_lower, 
                   tmt_reporter_upper = tmt_reporter_upper, 
                   exclude_reporter_region = exclude_reporter_region, 
                   deisotope_ms2 = deisotope_ms2, 
                   max_ms2_charge = max_ms2_charge, 
                   use_defpeaks = use_defpeaks, 
                   maxn_dia_precurs = maxn_dia_precurs, 
                   maxn_mdda_precurs = maxn_mdda_precurs, 
                   n_mdda_flanks = n_mdda_flanks, 
                   ppm_ms1_deisotope = ppm_ms1_deisotope, 
                   ppm_ms2_deisotope = ppm_ms2_deisotope, 
                   quant = quant, 
                   digits = digits)
}


#' Helper in processing MGF entries in chunks.
#'
#' @param lines Lines of MGF.
#' @inheritParams proc_mgf_chunks
proc_mgfs <- function (lines, topn_ms2ions = 150L, 
                       min_ms1_charge = 2L, max_ms1_charge = 4L, 
                       min_scan_num = 1L, max_scan_num = .Machine$integer.max, 
                       min_ret_time = 0, max_ret_time = Inf, 
                       min_mass = 200L, max_mass = 4500L, 
                       min_ms2mass = 115L, max_ms2mass = 4500L, 
                       ppm_ms1 = 10L, ppm_ms2 = 10L, 
                       mgf_cutmzs = numeric(), mgf_cutpercs = numeric(), 
                       type_mgf = "msconv_thermo", n_bf_begin = 0L, 
                       n_spacer = 0L, n_hdr = 5L, n_to_pepmass = 3L,
                       n_to_title = 1L, n_to_scan = 0L, n_to_rt = 2L,
                       n_to_charge = 4L, sep_ms2s = " ", nfields_ms2s = 2L, 
                       sep_pepmass = " ", nfields_pepmass = 2L, raw_file = NULL, 
                       tmt_reporter_lower = 126.1, tmt_reporter_upper = 135.2, 
                       exclude_reporter_region = FALSE, 
                       deisotope_ms2 = TRUE, max_ms2_charge = 3L, 
                       use_defpeaks = FALSE, maxn_dia_precurs = 1000L, 
                       maxn_mdda_precurs = 5L, n_mdda_flanks = 6L, 
                       ppm_ms1_deisotope = 10L, ppm_ms2_deisotope = 10L, 
                       quant = "none", digits = 4L) 
{
  options(digits = 9L)

  begins <- .Internal(which(stringi::stri_startswith_fixed(lines, "BEGIN IONS")))
  ends   <- .Internal(which(stringi::stri_endswith_fixed(lines, "END IONS")))

  ## MS1 
  # (1) m-over-z and intensity
  ms1s <- stringi::stri_replace_first_fixed(lines[begins + n_to_pepmass], 
                                            "PEPMASS=", "")
  ms1s <- lapply(ms1s, stringi::stri_split_fixed, pattern = sep_pepmass, 
                 n = nfields_pepmass, simplify = TRUE)
  ms1_moverzs <- lapply(ms1s, function (x) as.numeric(x[, 1]))
  ms1_moverzs <- .Internal(unlist(ms1_moverzs, recursive = FALSE, use.names = FALSE))
  # not as.integer; intensity may be > .Machine$integer.max (2147483647)
  ms1_ints <- lapply(ms1s, function (x) as.numeric(x[, 2]))
  ms1_ints <- .Internal(unlist(ms1_ints, recursive = FALSE, use.names = FALSE))
  rm(list = c("ms1s"))

  # (2) retention time
  ret_times <- stringi::stri_replace_first_fixed(lines[begins + n_to_rt], "RTINSECONDS=", "")
  ret_times <- as.numeric(ret_times)

  # (3) MS1 charges and masses
  ms1_charges <- stringi::stri_replace_first_fixed(lines[begins + n_to_charge], "CHARGE=", "")
  ms1_charges <- gsub("[\\+]$", "", ms1_charges)
  if (FALSE) {
    if ((polarity <- gsub(".*([\\+-])$", "\\1", ms1_charges[[1]])) == "+")
      ms1_charges <- gsub("[\\+]$", "", ms1_charges)
    else if (polarity == "-")
      ms1_charges <- gsub("-$", "", ms1_charges)
  }
  ms1_charges <- as.integer(ms1_charges)

  # timsTOF no CHARGE line -> NAs introduced by coercion
  ms1_masses <- mapply(function (x, y) x * y - y * 1.00727647, 
                       ms1_moverzs, ms1_charges, 
                       SIMPLIFY = TRUE, USE.NAMES = FALSE)

  ans_rts <- reset_rettimes(ret_times = ret_times, min_ret_time = min_ret_time, 
                            max_ret_time = max_ret_time)
  min_ret_time <- ans_rts$min_ret_time
  max_ret_time <- ans_rts$max_ret_time

  rows <- (ms1_charges >= min_ms1_charge & ms1_charges <= max_ms1_charge & 
             ret_times >= min_ret_time & ret_times <= max_ret_time & 
             ms1_masses >= min_mass & ms1_masses <= max_mass & 
             # timsTOF: no MS1 masses
             !is.na(ms1_masses))
  
  # timsTOF may have undetermined charge states
  if (length(na_rows <- .Internal(which(is.na(rows))))) 
    rows[na_rows] <- FALSE

  begins <- begins[rows]
  ends <- ends[rows]
  ms1_moverzs <- ms1_moverzs[rows]
  ms1_ints <- ms1_ints[rows]
  ms1_charges <- ms1_charges[rows]
  ret_times <- round(ret_times[rows], digits = 2L)
  ms1_masses <- ms1_masses[rows]
  rm(list = "rows")

  # Others
  scan_titles <- 
    stringi::stri_replace_first_fixed(lines[begins + n_to_title], "TITLE=", "")
  
  if (type_mgf %in% c("msconv_thermo", "msconv_pasef")) {
    raw_files <- 
      stringi::stri_replace_first_regex(scan_titles, "^.* File:\"([^\"]+)\".*", "$1")
    scan_nums <- 
      stringi::stri_replace_first_regex(scan_titles, 
                                        "^.*\\.(\\d+)\\.\\d+\\.\\d+ File:\".*", 
                                        "$1")
  } 
  else if (type_mgf == "pd") {
    raw_files <- gsub("^.*File: \"([^\"]+)\".*", "\\1", scan_titles)
    raw_files <- gsub("\\\\", "/", raw_files)
    raw_files <- gsub("^.*/(.*)", "\\1", raw_files)
    scan_nums <- gsub("^.* scans: \"([0-9]+)\"$", "\\1", scan_titles)
  } 
  else if (type_mgf == "default_pasef") {
    # one raw_file one .d file guaranteed
    raw_files <- rep_len(raw_file, length.out = length(begins))
    scan_nums <- stringi::stri_replace_first_fixed(lines[begins + n_to_scan], "RAWSCANS=", "")
  } 
  else {
    stop("Unknown MGF format.")
  }
  
  ## Low priority: no data subsetting by scan_nums; use retention time instead

  ## MS2
  # (-1L: one line above "END IONS")
  ms2s <- mapply(function (x, y) lines[(x + n_hdr) : (y - 1L)], 
                 begins, ends, SIMPLIFY = FALSE, USE.NAMES = FALSE)
  ms2s <- lapply(ms2s, stringi::stri_split_fixed, pattern = sep_ms2s, 
                 n = nfields_ms2s, simplify = TRUE)
  ms2_moverzs <- lapply(ms2s, function (x) as.numeric(x[, 1]))
  # not as.integer; intensity may be > .Machine$integer.max
  ms2_ints <- lapply(ms2s, function (x) as.numeric(x[, 2]))
  rm(list = c("ms2s"))
  
  ms2_charges <- vector("list", length(ms2_moverzs))
  is_tmt <- if (grepl("^tmt.*\\d+", quant)) TRUE else FALSE
  
  if (deisotope_ms2) {
    mics <- mapply(find_ms1stat, moverzs = ms2_moverzs, msxints = ms2_ints, 
                   MoreArgs = list(
                     center = 0, 
                     exclude_reporter_region = is_tmt, 
                     tmt_reporter_lower = tmt_reporter_lower, 
                     tmt_reporter_upper = tmt_reporter_upper, 
                     ppm = ppm_ms2_deisotope, 
                     ms_lev = 2L, maxn_feats = topn_ms2ions, 
                     max_charge = max_ms2_charge, n_fwd = 10L, 
                     offset_upr = 30L, offset_lwr = 30L, order_mz = FALSE
                   ), SIMPLIFY = FALSE, USE.NAMES = FALSE)
    ms2_moverzs <- lapply(mics, `[[`, "masses")
    ms2_ints <- lapply(mics, `[[`, "intensities")
    ms2_charges <- lapply(mics, `[[`, "charges")
  }
  
  # extract the TMT region of MS2 moverz and intensity
  # (also convert reporter-ion intensities to integers)
  restmt <- extract_mgf_rptrs(ms2_moverzs, 
                              ms2_ints, 
                              quant = quant, 
                              tmt_reporter_lower = tmt_reporter_lower, 
                              tmt_reporter_upper = tmt_reporter_upper, 
                              exclude_reporter_region = exclude_reporter_region)
  
  ms2_moverzs <- restmt[["xvals"]]
  ms2_ints <- restmt[["yvals"]]
  rptr_moverzs <- restmt[["rptr_moverzs"]]
  rptr_ints <- restmt[["rptr_ints"]]
  rm(list = "restmt")

  # subsets by top-n and min_ms2mass
  # (also convert non reporter-ion MS2 intensities to integers)
  mz_n_int <- sub_mgftopn(ms2_moverzs = ms2_moverzs, 
                          ms2_ints = ms2_ints, 
                          ms2_charges = ms2_charges, 
                          topn_ms2ions = topn_ms2ions, 
                          mgf_cutmzs = mgf_cutmzs, 
                          mgf_cutpercs = mgf_cutpercs, 
                          min_ms2mass = min_ms2mass, 
                          max_ms2mass = max_ms2mass)
  
  ms2_moverzs <- mz_n_int[["ms2_moverzs"]]
  ms2_ints <- mz_n_int[["ms2_ints"]]
  ms2_charges <- mz_n_int[["ms2_charges"]]
  lens <- mz_n_int[["lens"]]
  rm(list = "mz_n_int")

  df <- tibble::tibble(
    scan_title = scan_titles,
    raw_file = raw_files,
    ms1_moverz = ms1_moverzs,
    ms1_mass = ms1_masses,
    ms1_int = ms1_ints,
    ms1_charge = ms1_charges,
    ret_time = ret_times,
    scan_num = scan_nums,
    ms2_moverzs= ms2_moverzs,
    ms2_ints = ms2_ints,
    ms2_charges = ms2_charges, 
    ms2_n = lens, 
    rptr_moverzs = rptr_moverzs, 
    rptr_ints = rptr_ints, )
}


#' Resets the range of retention times by experimental observations.
#' 
#' Needed since \code{max_ret_time} can be negative.
#' 
#' @param ret_times A vector of experimental retention times.
#' @inheritParams matchMS
reset_rettimes <- function (ret_times, min_ret_time = 0, max_ret_time = Inf) 
{
  min_rt <- min(ret_times, na.rm = TRUE)
  max_rt <- max(ret_times, na.rm = TRUE)
  
  if (min_ret_time < min_rt)
    min_ret_time <- min_rt 
  
  if (max_ret_time > 0) {
    if (max_ret_time > max_rt)
      max_ret_time <- max_rt
  }
  else {
    max_ret_time <- max_rt + max_ret_time
    
    if (max_ret_time < min_ret_time) {
      warning("Invalid \"max_ret_time\". Choose a less negative value." )
      max_ret_time <- max_rt
    }
  }
  
  list(min_ret_time = min_ret_time, max_ret_time = max_ret_time)
}


#' Subsets MGFs by top-n entries.
#' 
#' \code{lens} after filtered by \code{min_ms2mass} but before subset by 
#' \code{topn_ms2ions} to reflect noise levels.
#' 
#' @param ms2_moverzs Lists of MS2 moverz values.
#' @param ms2_ints Lists of MS2 intensities.
#' @param ms2_charges Lists of MS2 charges.
#' @inheritParams load_mgfs
sub_mgftopn <- function (ms2_moverzs = NULL, ms2_ints = NULL, ms2_charges = NULL, 
                         topn_ms2ions = 150L, mgf_cutmzs = numeric(), 
                         mgf_cutpercs = numeric(), min_ms2mass = 115L, 
                         max_ms2mass = 4500L) 
{
  options(digits = 9L)
  
  ## subsets by min_ms2mass
  oks <- lapply(ms2_moverzs, function (x) x >= min_ms2mass)
  
  ms2_moverzs <- mapply(function (x, y) x[y], ms2_moverzs, oks, 
                        SIMPLIFY = FALSE, USE.NAMES = FALSE)
  ms2_ints <- mapply(function (x, y) x[y], ms2_ints, oks, 
                     SIMPLIFY = FALSE, USE.NAMES = FALSE)
  ms2_charges <- mapply(function (x, y) x[y], ms2_charges, oks, 
                        SIMPLIFY = FALSE, USE.NAMES = FALSE)

  ## subsets by topn
  lens <- lengths(ms2_moverzs)
  
  if (topn_ms2ions < Inf) {
    is_long <- lens > topn_ms2ions
    
    if (length(mgf_cutmzs)) {
      m_long <- ms2_moverzs[is_long]
      i_long <- ms2_ints[is_long]
      z_long <- ms2_charges[is_long]
      
      for (i in seq_along(m_long)) {
        x <- m_long[[i]]
        y <- i_long[[i]]
        z <- z_long[[i]]
        
        # (`<` not `<=`)
        ok_ms2 <- x < max_ms2mass
        x <- x[ok_ms2]
        y <- y[ok_ms2]
        z <- z[ok_ms2]
        
        idxes <- findInterval(x, mgf_cutmzs)
        xs <- split(x, idxes)
        ys <- split(y, idxes)
        zs <- split(z, idxes)
        
        # some zones may have no entries
        ok_idxes <- as.integer(names(xs)) + 1L
        ok_percs <- mgf_cutpercs[ok_idxes]
        
        # e.g. the last interval from ms2masses >= max_ms2mass -> c(100, 10, NA)
        # but no need to remove NA since already `ok_ms2`;
        # 
        # `which_topx2` also guard against NA
        # 
        # ok_percs <- ok_percs[!is.na(ok_percs)]
        
        ## (little benefit with padding) 
        if (FALSE) {
          percs_no_one <- ok_percs[-1]
          ys_no_one <- ys[-1]
          rows_no_one <- mapply(which_topx2,ys_no_one, percs_no_one, 
                                SIMPLIFY = FALSE, USE.NAMES = FALSE)
          
          cts_no_one <- lapply(rows_no_one, length)
          cts_no_one <- .Internal(unlist(cts_no_one, recursive = FALSE, use.names = FALSE))
          cts_delta <- sum(percs_no_one) - sum(cts_no_one)
          
          cts_one <- ok_percs[1] + cts_delta
          rows_one <- which_topx2(ys[[1]], cts_one)
          
          rows <- c(list(rows_one), rows_no_one)
        }

        rows  <- mapply(which_topx2, ys, ok_percs, SIMPLIFY = FALSE, USE.NAMES = FALSE)
        ans_x <- mapply(function (x, y) x[y], xs, rows, SIMPLIFY = FALSE, USE.NAMES = FALSE)
        ans_y <- mapply(function (x, y) x[y], ys, rows, SIMPLIFY = FALSE, USE.NAMES = FALSE)
        ans_z <- mapply(function (x, y) x[y], zs, rows, SIMPLIFY = FALSE, USE.NAMES = FALSE)
        
        ans_x <- .Internal(unlist(ans_x, recursive = FALSE, use.names = FALSE))
        ans_y <- .Internal(unlist(ans_y, recursive = FALSE, use.names = FALSE))
        ans_z <- .Internal(unlist(ans_z, recursive = FALSE, use.names = FALSE))
        
        ms2_moverzs[is_long][[i]] <- ans_x
        ms2_ints[is_long][[i]] <- ans_y
        ms2_charges[is_long][[i]] <- ans_z
      }
    }
    else {
      rows <- lapply(ms2_ints[is_long], which_topx2, topn_ms2ions)

      ms2_ints[is_long] <- mapply(function (x, y) x[y], 
                                  ms2_ints[is_long], rows, 
                                  SIMPLIFY = FALSE, USE.NAMES = FALSE)
      ms2_moverzs[is_long] <- mapply(function (x, y) x[y], 
                                     ms2_moverzs[is_long], rows, 
                                     SIMPLIFY = FALSE, USE.NAMES = FALSE)
      ms2_charges[is_long] <- mapply(function (x, y) x[y], 
                                     ms2_charges[is_long], rows, 
                                     SIMPLIFY = FALSE, USE.NAMES = FALSE)
    }
  }
  
  # also handles MS2 intensity max-outs, which usually don't happen
  ms2_ints <- integerize_ms2ints(ms2_ints)

  list(ms2_moverzs = ms2_moverzs, ms2_ints = ms2_ints, 
       ms2_charges = ms2_charges, lens = lens)
}


#' Integerizes the MS2 intensities.
#'
#' Also guards against intensity integers above machine maximum (32-bit).
#'
#' @param ms2_ints Lists of MS2 intensities
#' @param max_intdbl Maximum 32-bit integer as double:
#'   \code{as.double(.Machine$integer.max)}.
integerize_ms2ints <- function(ms2_ints, max_intdbl = 2147483647.0) 
{
  lapply(ms2_ints, function (x) {
    x[x > max_intdbl] <- max_intdbl
    as.integer(x)
  })
}


#' Extracts reporter-ion data from MGF.
#' 
#' Also purges MS2 m-over-z and intensity when applicable.
#' 
#' @param xvals Lists of MS2 m-over-z values.
#' @param yvals Lists of MS2 intensity values. 
#' @inheritParams matchMS
extract_mgf_rptrs <- function (xvals, yvals, quant = "none", 
                               tmt_reporter_lower = 126.1, 
                               tmt_reporter_upper = 135.2, 
                               exclude_reporter_region = FALSE) 
{
  if (isTRUE(grepl("^tmt.*\\d+", quant))) {
    ok_rptrs <- lapply(xvals, function (x) x > tmt_reporter_lower & 
                         x < tmt_reporter_upper)
    rptr_moverzs <- mapply(function (x, y) x[y], xvals, ok_rptrs, 
                           SIMPLIFY = FALSE, USE.NAMES = FALSE)
    rptr_ints <- mapply(function (x, y) x[y], yvals, ok_rptrs, 
                        SIMPLIFY = FALSE, USE.NAMES = FALSE)
    rptr_ints <- integerize_ms2ints(rptr_ints)
    
    if (exclude_reporter_region) {
      no_rptrs <- lapply(ok_rptrs, `!`)
      xvals <- mapply(function (x, y) x[y], xvals, no_rptrs, 
                      SIMPLIFY = FALSE, USE.NAMES = FALSE)
      yvals <- mapply(function (x, y) x[y], yvals, no_rptrs, 
                      SIMPLIFY = FALSE, USE.NAMES = FALSE)
    }
  }
  else {
    rptr_moverzs <- NA_real_
    rptr_ints <- NA_integer_
  }
  
  list(xvals = xvals, 
       yvals = yvals,  
       rptr_moverzs = rptr_moverzs, 
       rptr_ints = rptr_ints)
}


#' Converts ms2_moverzs to integers.
#'
#' Note that as.integer is needed. When an indexed x equals 0 but is double, it
#' can cause %fin% to fail.
#'
#' @param from Numeric; the starting MS1 mass.
#' @param x Numeric; MS2 mass.
#' @param d Numeric; \eqn{ppm * 10E-6}.
#' @examples
#' xs <- ceiling(log(c(114.0916, 114.9999)/115)/log(1+8E-6))
#' match(xs, xs); fastmatch::fmatch(xs, xs)
#' 
#' ys <- as.integer(xs)
#' match(ys, ys); fastmatch::fmatch(ys, ys)
index_mz <- function (x, from = 115L, d = 1E-5) 
  as.integer(ceiling(log(x/from)/log(1+d)))


#' Finds the type of MGF.
#'
#' @param file The path to an MGF file.
find_mgf_type <- function (file) 
{
  hdr <- readLines(file, 5000L)
  begins <- which(stringi::stri_startswith_fixed(hdr, "BEGIN IONS"))
  ends <- which(stringi::stri_endswith_fixed(hdr, "END IONS"))
  
  len_h <- length(hdr)
  len_b <- length(begins)
  
  if (!len_b) 
    stop("Check corrupted files: the tag of `BEGIN IONS` not found in MGF.")
  else if (len_b == 1L) {
    b2 <- len_h + 1L
    hdr[b2] <- "BEGIN IONS"
    begins <- c(begins, b2)
  }
    
  # if (!length(ends))
  #   stop("The tag of `END IONS` not found in MGF.")

  
  ## MSConvert (Thermo)
  # <RunId>.<ScanNumber><ScanNumber><ChargeState> File:"<SourcePath>", NativID:"<Id>"
  # 
  # BEGIN IONS
  # TITLE=rawname.179.179.3 File:"rawname.raw", NativeID:"controllerType=0 controllerNumber=1 scan=179"
  # RTINSECONDS=63.4689
  # PEPMASS=482.224129434954 280125.927246099978
  # CHARGE=3+
  
  ## MSconvert (timsTOF)
  # BEGIN IONS
  # "TITLE=rawname.2.2.1 File:\"rawname.d\", 
  #   NativeID:\"merged=1 frame=2 scanStart=200 scanEnd=224\", IonMobility:\"1.3990913467070001\""
  # RTINSECONDS=2.950849933
  # PEPMASS=1221.991350361787
  # CHARGE=1+

  ## Proteome Discoverer
  # MASS=Monoisotopic
  # BEGIN IONS
  # TITLE=File: "Z:\Folder\rawname.raw"; SpectrumID: "1"; scans: "179"
  # PEPMASS=482.22421 110739.89844
  # CHARGE=3+
  # RTINSECONDS=63
  # SCANS=179
  
  ## RawConverter
  # BEGIN IONS
  # TITLE=Z:\Folder\rawname.raw
  # SCANS=179
  # RTINSECONDS=63.4689
  # CHARGE=3+
  # PEPMASS=482.2242
  
  # ###FS:    #m/z: 454.22925 #charge 2+
  # ###MS: 1
  # ###MSMS: 7, 9-11
  # ###Mobility: 0.7810
  # BEGIN IONS
  # TITLE=Cmpd 18, +MS2(454.2292), 27.7eV, 0.0min, 1/K0=0.781, #7-11
  # RTINSECONDS=1.04678
  # RAWSCANS=1,7,9-11
  # PEPMASS=454.22925	70295
  # CHARGE=2+
  #   221.10530	104	
  #   ...
  # END IONS
  # 
  # ###FS:    #m/z: 665.07643 #charge 1+
  # ###MS: 8
  # ###MSMS: 23
  # ###Mobility: 1.0572
  # BEGIN IONS
  # TITLE=Cmpd 49, +MS2(665.0764), 39.6eV, 0.1min, 1/K0=1.057, #23

  type <- local({
    ln_tit <- hdr[grepl("TITLE", hdr)][1]

    file_msconvert_pasef <- file_msconvert_thermo <- "File:\""
    file_pd <- "File: \""
    file_default_pasef <- "Cmpd "

    scan_msconv_thermo <- "scan=\\d+"
    scan_msconv_pasef <- "scanStart=\\d+"
    scan_pd <- "scans: \"\\d+\""
    scan_default_pasef <- NULL

    if (isTRUE(grepl(file_msconvert_thermo, ln_tit)) && 
        isTRUE(grepl(scan_msconv_thermo, ln_tit))) 
      "msconv_thermo"
    else if (isTRUE(grepl(file_msconvert_pasef, ln_tit)) && 
             isTRUE(grepl(scan_msconv_pasef, ln_tit)))
      "msconv_pasef"
    else if (isTRUE(grepl(file_pd, ln_tit)) && 
             isTRUE(grepl(scan_pd, ln_tit))) 
      "pd"
    else if (isTRUE(grepl(file_default_pasef, ln_tit)) && 
             isTRUE(is.null(scan_default_pasef)))
      "default_pasef"
    else 
      stop("Unkown format of MGFs.")
  })
  
  # n_bf_begin: the number of lines before `BEGIN IONS`
  # n_spacer: the number of white-space lines between two adjacent blocks
  # n_hdr: the number of hear lines from (including) `BEGIN IONS`
  # raw_file: if ".", an indicator to find RAW file names from the header
  
  # between ends[1] and begins[2]
  n_end <- 1L
  n_begin <- 1L
  
  end <- ends[1]
  begin2 <- begins[2]
  lines_bf <- hdr[end:begin2]
  
  n_spacer <- sum(unlist(lapply(lines_bf, function (x) x == "")))
  n_bf_begin <- begin2 - end - n_spacer - n_end
  
  # between begins[1] and ends[1]
  begin <- begins[1]
  lines <- hdr[begin:end]
  
  n_hdr <- grep("^[0-9]+", lines)[1] - 1L # 5
  n_to_pepmass <- grep("^PEPMASS", lines)[1] - n_begin
  n_to_title <- grep("^TITLE", lines)[1] - n_begin
  n_to_rt <- grep("^RTINSECONDS", lines)[1] - n_begin
  n_to_charge <- grep("^CHARGE", lines)[1] - n_begin

  # the first entry in the original MGF may have no CHARGE line
  if (is.na(n_to_charge) && type == "default_pasef")
    n_to_charge <- 5L
  
  if (type == "msconv_thermo") {
    # n_bf_begin <- 0L
    # n_spacer <- 0L
    # n_hdr <- 5L
    # n_to_pepmass <- 3L
    # n_to_title <- 1L
    # n_to_rt <- 2L
    # n_to_charge <- 4L
    n_to_scan <- 0L
    
    sep_ms2s <- " "
    nfields_ms2s <- 2L
    sep_pepmass <- " "
    nfields_pepmass <- 2L
    raw_file <- NULL
  } 
  else if (type == "msconv_pasef") {
    warning("Suggest MGFs of manufacturer's default")
    
    n_bf_begin <- 0L
    n_spacer <- 0L
    n_hdr <- 5L
    n_to_pepmass <- 3L
    n_to_title <- 1L
    n_to_rt <- 2L
    n_to_charge <- 4L
    n_to_scan <- 0L
    
    sep_ms2s <- " "
    nfields_ms2s <- 2L
    sep_pepmass <- " " # as of 2021-12-27, missing MS1 intensity
    nfields_pepmass <- 2L # "NA" MS1 intensities after parsing
    raw_file <- NULL
  } 
  else if (type == "pd") {
    # n_bf_begin <- 0L
    # n_spacer <- 1L
    # n_hdr <- 6L
    # n_to_pepmass <- 2L
    # n_to_title <- 1L
    # n_to_rt <- 4L
    # n_to_charge <- 3L
    # n_to_scan <- 5L
    
    n_to_scan <- grep("^SCANS", lines)[1] - n_begin
    if (is.na(n_to_scan)) stop("`SCANS` not found.")
    
    sep_ms2s <- " "
    nfields_ms2s <- 2L
    sep_pepmass <- " "
    nfields_pepmass <- 2L
    raw_file <- NULL
  } 
  else if (type == "default_pasef") {
    # n_bf_begin <- 4L
    # n_spacer <- 1L
    # n_hdr <- 6L
    # n_to_pepmass <- 4L
    # n_to_title <- 1L
    # n_to_scan <- 3L
    # n_to_rt <- 2L
    # n_to_charge <- 5L
    
    n_to_scan <- grep("^RAWSCANS", lines)[1] - n_begin
    if (is.na(n_to_scan)) stop("`RAWSCANS` not found.")
    
    sep_ms2s <- "\t"
    nfields_ms2s <- 3L
    sep_pepmass <- " "
    nfields_pepmass <- 2L
    raw_file <- "."
  }
  else {
    stop("Unkown format of MGFs.")
  }

  if (is.na(n_hdr)) stop("MS2 data not found.")
  if (is.na(n_to_pepmass)) stop("`PEPMASS` not found.")
  if (is.na(n_to_title)) stop("`TITLE` not found.")
  if (is.na(n_to_rt)) stop("`RTINSECONDS` not found.")
  if (is.na(n_to_charge)) stop("`CHARGE` not found.")
  
  invisible(list(type = type, 
                 n_bf_begin = n_bf_begin, 
                 n_spacer = n_spacer,
                 n_hdr = n_hdr,
                 n_to_pepmass = n_to_pepmass,
                 n_to_title = n_to_title,
                 n_to_scan = n_to_scan,
                 n_to_rt = n_to_rt,
                 n_to_charge = n_to_charge, 
                 sep_ms2s = sep_ms2s, 
                 nfields_ms2s = nfields_ms2s, 
                 sep_pepmass = sep_pepmass, 
                 nfields_pepmass = nfields_pepmass, 
                 raw_file = raw_file))
}


#' Preprocessing Bruker's MGF
#' 
#' Some entries may have no CHARGE line
#'
#' @param file A file name
#' @param begin_offset The number of lines before a BEGIN line.
#' @param charge_offset The number lines after a BEGIN line to a following
#'   CHARGE line.
prepBrukerMGF <- function (file = NULL, begin_offset = 5L, charge_offset = 5L)
{
  if (is.null(file))
    stop("`file` cannot be NULL.")
  
  message("Processing: ", file)
  
  lines <- readLines(file)
  hd <- lines[1:100]
  
  ### Some MGFs may have additional "SCANS=" lines
  pat_sc <- "SCANS"
  sc <- .Internal(which(stringi::stri_startswith_fixed(hd, pat_sc)))
  
  if (length(sc)) {
    lscs  <- .Internal(which(stringi::stri_startswith_fixed(lines, pat_sc)))
    lines <- lines[-lscs]
    rm(list = "lscs")
  }
  rm(list = c("pat_sc", "sc"))

  ###PrecursorID: 
  pat_pr <- "###PrecursorID"
  pr <- .Internal(which(stringi::stri_startswith_fixed(hd, pat_pr)))
  
  if (length(pr)) {
    lprs  <- .Internal(which(stringi::stri_startswith_fixed(lines, pat_pr)))
    lines <- lines[-lprs]
    rm(list = "lprs")
  }
  rm(list = c("pat_pr", "pr"))

  ###CCS: 
  pat_ccs <- "###CCS"
  ccs <- .Internal(which(stringi::stri_startswith_fixed(hd, pat_ccs)))
  
  if (length(ccs)) {
    ccs  <- .Internal(which(stringi::stri_startswith_fixed(lines, pat_ccs)))
    lines <- lines[-ccs]
    rm(list = "ccs")
  }
  rm(list = c("pat_ccs", "ccs"))

  ## Processing
  begins <- .Internal(which(stringi::stri_startswith_fixed(lines, "BEGIN IONS")))
  ends   <- .Internal(which(stringi::stri_endswith_fixed(lines, "END IONS")))
  hdrs   <- 1:(begins[1]-begin_offset-1L)
  
  zls <- lines[begins+5L]
  # oks <- grepl("^CHARGE", zls) & (zls != "CHARGE=1+")
  oks <- grepl("^CHARGE", zls) & (zls != "CHARGE=1+") & grepl("^###Mobility", lines[begins-1L])
  rm(list = "zls")
  
  b_oks <- begins[oks] - begin_offset
  e_oks <- ends[oks]
  
  ranges <- mapply(function (x, y) x:y, b_oks, e_oks, SIMPLIFY = TRUE)
  ranges <- do.call(`c`, ranges)
  ranges <- c(hdrs, ranges)
  
  writeLines(lines[ranges], file)
}


#' Parallel \link{prepBrukerMGF}
#' 
#' @param filepath A file path to MGF.
#' @param n_cores The number of CPU cores.
#' @export
mprepBrukerMGF <- function (filepath, n_cores = 32L) 
{
  message("Preparing Bruker's MGFs.")
  
  files <- list.files(filepath, pattern = "\\.mgf$", full.names = TRUE, 
                      recursive = TRUE)
  
  len <- length(files)
  
  if (!len)
    stop("No MGF files found.")
  
  if (n_cores > 1L)
    n_cores <- min(parallel::detectCores(), n_cores, len)
  
  if (n_cores > 1L) {
    cl <- parallel::makeCluster(getOption("cl.cores", n_cores))
    parallel::clusterApply(cl, files, prepBrukerMGF)
    parallel::stopCluster(cl)
  }
  else 
    lapply(files, prepBrukerMGF)
  
  message("Done preparing Bruker's MGFs.")
}


#' Generates and Calculates the masses of tryptic peptides from a fasta
#' database.
#'
#' @param aa_masses An amino acid mass look-up.
#' @param enzyme A character string; the proteolytic specificity of the assumed
#'   enzyme will be used to generate peptide sequences from proteins. The enzyme
#'   is currently \code{trypsin}.
#' @param maxn_fasta_seqs Integer; the maximum number of protein sequences in
#'   fasta files.
#' @param min_len Integer; the minimum length of peptides. Shorter peptides will
#'   be excluded.
#' @param max_len Integer; the maximum length of peptides. Longer peptides will
#'   be excluded.
#' @param max_miss The maximum number of mis-cleavages per peptide sequence.
#' @param maxn_sites_per_vmod Integer; the maximum number of combinatorial
#'   variable modifications per site in a per peptide sequence.
#' @param maxn_vmods_per_pep The maximum number of variable modifications per
#'   peptide.
#' @param .path_ms1masses The file path to the theoretical masses of MS1
#'   precursors.
#' @param digits Integer; the number of decimal places to be used.
#' @inheritParams calc_aamasses
#' @inheritParams matchMS
#' @import parallel
#' @examples
#' \donttest{
#' library(mzion)
#' library(purrr)
#' library(magrittr)
#' 
#' if (FALSE) {
#'   res <- calc_pepmasses2()
#'   res_attrs <- lapply(res, attributes)
#'   lapply(res_attrs, names)
#'   lapply(res_attrs, `[[`, "vmods")
#'   res_mods <- lapply(res_attrs, `[`,
#'                      c("fmods", "fmods_ps", "fmods_neuloss",
#'                        "vmods", "vmods_ps", "vmods_neuloss"))
#'   
#'   res_data <- lapply(res_attrs, `[[`, "data")
#'   peps_combi_1 <- res_data[[1]]
#'   
#'   # base: fixedmods without neulosses
#'   length(unlist(res_data[[1]], use.names = FALSE))
#'   
#'   # fixedmods, fixedmods + fixedmods_neulosses, varmods, varmods_neulosses
#'   length(unlist(res_data, use.names = FALSE))
#' }
#' }
calc_pepmasses2 <- function (aa_masses = NULL, 
  fasta = "~/mzion/dbs/fasta/uniprot/uniprot_hs_2020_05.fasta",
  acc_type = "uniprot_acc",
  acc_pattern = NULL,
  fixedmods = c("TMT6plex (N-term)", 
                "TMT6plex (K)", 
                "Carbamidomethyl (C)"),
  varmods = c("Acetyl (Protein N-term)", 
              "Oxidation (M)", 
              "Deamidated (N)",
              "Gln->pyro-Glu (N-term = Q)"),
  rm_dup_term_anywhere = TRUE, 
  fixedlabs = NULL, 
  varlabs = NULL, 
  mod_motifs = NULL, 
  enzyme = c("trypsin_p"),
  custom_enzyme = c(Cterm = NULL, Nterm = NULL), 
  noenzyme_maxn = 0L, 
  maxn_fasta_seqs = 200000L,
  maxn_vmods_setscombi = 64L,
  maxn_vmods_per_pep = 5L,
  maxn_sites_per_vmod = 3L,
  min_len = 7L, max_len = 40L, max_miss = 2L,
  min_mass = 200L, max_mass = 4500L, 
  out_path = NULL,
  digits = 4L,
  use_ms1_cache = TRUE, 
  .path_cache = NULL, 
  .path_fasta = NULL, 
  .path_ms1masses = NULL) 
{
  ## Enzymatic and Semi-enzymatic
  # (1) split_fastaseqs: 
  #     splits FASTA sequences by full-enzyme specificity
  # (2) ms1masses_bare: 
  # (2.1) ms1masses_noterm: 
  #     calculates the bare masses of (1) without terminal masses (e.g. H2O) 
  # (2.2) roll_sum
  #     concatenates sequences and masses according to the value of `max_miss`
  # (2.3) Adds FIXED terminal mass: 
  #     H2O 18.010565, FIXED N-term TMT modification 230.170757 + 17.002740 ...
  #     (which are reflected on aa_masses["N-term"] and aa_masses["C-term"])
  # (2.4) Adds coerced fixed masses
  #     E.g., with the original fixed TMT6plex (K) and variable Acetyl (K),
  #     TMT6plex (K) is back-coerced to fixedmod under some combinations.
  # (2.5) Adds variable masses with the look-up of aa_masses_all
  # 
  # Note:
  # For "historical" reasons, terminal "tmods+" refers to "VARIABLE tmods+". 
  # 
  # (3) distri_peps:
  #     distributes peptides by modifications;
  #     removes terminal tags of "-"
  # (4) hsemipeps_byprots:
  #     semi-enzyme only
  # (5) simple_prots_peps:
  #     records/sets aside the peptide-and-protein associations
  # (6) flat_pepseqs:
  #     removes the information of protein
  # (7) Twelve types of VARIABLE modifications/masses:
  #     adds variable terminal masses (tmod+), variable anywhere masses (vmods+) 
  #     neutral losses (fnl+) etc.

  old_opts <- options()
  options(warn = 1L)
  on.exit(options(old_opts), add = TRUE)

  on.exit(
    if (exists(".savecall", envir = fun_env)) {
      if (.savecall) {
        save_call2(path = .path_cache, fun = fun, time = .time_stamp)
      }
    },
    add = TRUE
  )

  # ---
  fun <- as.character(match.call()[[1]])
  fun_env <- environment()
  
  # argument_name-default_value pair
  new_args <- local({
    args <- c("noenzyme_maxn")
    fmls <- formals(fun)[args]

    # for example `custom_enzyme` (should be NULL after eval)
    nargs <- lapply(fmls, function (x) if (is.call(x)) eval(x) else x)
    
    # unlisting with NUlls being kept
    are_nulls <- lapply(nargs, is.null)
    def_nulls <- unlist(are_nulls)
    c(unlist(nargs), nargs[def_nulls])
  })
  
  # toggle this if no new arguments to bypass
  # new_args <- c(ms1_notches = 0)
  new_args <- NULL

  .time_stamp <- match_calltime(
    path = .path_cache,
    fun = fun,
    # `nms` must be matched in order to retrieve cached results
    nms = c("fasta", "acc_type", "acc_pattern",
            "fixedmods", "varmods", "mod_motifs", 
            "fixedlabs", "varlabs", 
            "enzyme", "custom_enzyme",
            "maxn_fasta_seqs", "maxn_vmods_setscombi",
            "maxn_vmods_per_pep", "maxn_sites_per_vmod",
            "min_len", "max_len", "max_miss", 
            "min_mass", "max_mass"), 
    # exception: new arguments need matches but not defined in earlier versions
    new_args = new_args)

  # ---
  if ((len_ts <- length(.time_stamp)) && use_ms1_cache) {
    # can have multiple matches with use_ms1_cache on/off
    .time_stamp <- .time_stamp[len_ts]

    message("Loading peptide masses from cache.")
    
    aa_masses_all <- find_aa_masses(
      aa_masses = aa_masses, 
      out_path = file.path(.path_fasta, "ms1masses", .time_stamp),
      fixedmods = fixedmods,
      varmods = varmods,
      rm_dup_term_anywhere = rm_dup_term_anywhere, 
      varlabs = varlabs, 
      mod_motifs = mod_motifs, 
      maxn_vmods_setscombi = maxn_vmods_setscombi)

    files <- list.files(path = file.path(.path_ms1masses, .time_stamp),
                        pattern = "pepmasses_\\d+\\.rds$")

    if (length(files) != length(aa_masses_all)) 
      stop("Not all precursor masses were found: ", 
           paste0("\n", files), ".\n",
           "Remove cache file: \n", 
           file.path(.path_cache, fun, paste0(.time_stamp, ".rda")),
           " and try again.")

    fwd_peps <- NULL
    rev_peps <- NULL

    .savecall <- FALSE
  } 
  else {
    # `mgf_quries.rds` kept (only affected by min_mass, max_mass and ppm_ms1)
    delete_files(
      out_path, 
      ignores = c("\\.[Rr]$", "\\.(mgf|MGF)$", "\\.(mzML|mzml)$", "\\.(raw|RAW)$", 
                  "\\.xlsx$", "\\.xls$", "\\.csv$", "\\.txt$", "\\.pars$", 
                  "^mgf$", "^mgfs$", "^mzML$", "^mzMLs$", "^raw$", 
                  "Calls", "^PSM$", "^Peptide$", "^Protein$", 
                  "fraction_scheme.rda", "label_scheme.rda", 
                  "label_scheme_full.rda"))

    .time_stamp <- format(Sys.time(), ".%Y-%m-%d_%H%M%S")
    path_tstamp <- file.path(.path_fasta, "ms1masses", .time_stamp)
    file_ms1    <- file.path(path_tstamp, "aa_masses_ms1.rds")

    aa_masses_all <- find_aa_masses(
      aa_masses = aa_masses, 
      out_path = path_tstamp,
      fixedmods = fixedmods,
      varmods = varmods,
      rm_dup_term_anywhere = rm_dup_term_anywhere, 
      varlabs = varlabs,
      mod_motifs = mod_motifs, 
      maxn_vmods_setscombi = maxn_vmods_setscombi)
    
    if (file.exists(file_ms1))
      aa_masses_ms1 <- qs::qread(file_ms1)
    else
      stop("File not found: ", file_ms1)
    
    aa_masses_0 <- aa_masses_ms1[[1]]
    aa_masses_1 <- aa_masses_all[[1]]
    
    ms1vmods_all <- lapply(aa_masses_all, make_ms1vmod_i,
                           maxn_vmods_per_pep = maxn_vmods_per_pep,
                           maxn_sites_per_vmod = maxn_sites_per_vmod)

    # Design:
    #   variable modifications, including [NC]-term, were appended in parallel 
    #   to unmodified residues in `aa_masses`, e.g., "M", "Oxidation (M)" are 
    #   two separate entries in `aa_masses`
    # 
    # aa_masses_0 - coerced fixedmods: the base for varmod mass calculations
    # aa_masses_1 - original fixedmods: for all-fixed mass calculations
    # 
    # The first entry in aa_masses_all is aa_masses_1, not aa_masses_0: 
    #   Fixed "TMT (K)" coerced to variable under the presence of "Acetyl (K)"; 
    #   If use aa_masses_0, sequences without K will drop when dispatching 
    #   (must contain K as varmods were considered realized).
    # 
    # "tmods-" refers to VARIABLE terminal modifications
    #   aa_masses_0 and aa_masses_1 are always "tmods-"
    
    is_fixed_protnt <- any(grepl("Protein N-term", fixedmods))
    is_fixed_protct <- any(grepl("Protein C-term", fixedmods))

    # --- Forward sequences  ---
    # (enzyme can be NULL)
    if (isTRUE(enzyme == "noenzyme")) {
      if (max_len > 25L) 
        warning("May be out of RAM at `max_len = ", max_len, "`.\n",
                "Consider a sectional search, e.g., `noenzyme_maxn = 10`")

      if (any(is_fixed_protnt, is_fixed_protct))
        stop("Not yet support FIXED protein terminal modifications for ", 
             "noenzyme searches.\n", 
             "Change to VARIABLE protein terminal modifications.")

      seqs_0 <- NULL
      ftmass <- unname(aa_masses_0["N-term"] + aa_masses_0["C-term"])
      
      fwd_peps <- split_fastaseqs_noenz(fasta = fasta, 
                                        acc_type = acc_type,
                                        acc_pattern = acc_pattern,
                                        maxn_fasta_seqs = maxn_fasta_seqs, 
                                        min_len = min_len, 
                                        max_len = max_len, 
                                        aa_masses = aa_masses_0, 
                                        ftmass = ftmass)
      gc()
    }
    else {
      # (not yet concatenation by the number of missed cleavages)
      seqs_0 <- split_fastaseqs(fasta = fasta,
                                enzyme = enzyme, 
                                custom_enzyme = custom_enzyme, 
                                acc_type = acc_type,
                                acc_pattern = acc_pattern,
                                maxn_fasta_seqs = maxn_fasta_seqs,
                                max_miss = max_miss)
      
      ### Special case of FIXED Protein [NC]-term modification(s)
      # 
      # (i) Dispatches `pep_seq`s by `fixedmod`s
      # (only incur at the rare case of Protein terminals being `fixedmods`)
      # (`fixed Protein [NC]-term` -> no `variable Protein [NC]-term`)
      # 
      # (ii) Calculates terminal mass (after `distri_fpeps`)
      # (otherwise, fixed "Protein N|C-terminal" masses in aa_masses["N|C-term"]
      #   will be applied to both "N|C-term" and "Protein N|C term")
      #
      # if `ftmass` is other than 18.010565 -> FIXED [NC]-term 
      #   -> NO variable "Protein N-term" etc.
      # (ftmass will be 18.010565 or plus fixed [NC] terminal modifications)
      #   aa_masses["N-term"] = 1.007825, aa_masses["C-term"] = 17.002740
      
      seqs_0 <- distri_fpeps(data = seqs_0, max_miss = max_miss, 
                             is_fixed_protnt = is_fixed_protnt, 
                             is_fixed_protct = is_fixed_protct)
      ###

      
      # --- Masses of sequences: fixed mods + terminals ---
      message("Calculating bare peptide masses...")
      
      # e.g. if "TMT6plex (N-term)" is a fixedmod -> ftmass = (229 + 1) + 17;
      # if "TMT6plex (N-term)" coerced to a varmod -> ftmass = 1 + 17
      ftmass <- unname(aa_masses_0["N-term"] + aa_masses_0["C-term"])
      
      fwd_peps <- ms1masses_bare(seqs = seqs_0,
                                 aa_masses = aa_masses_0,
                                 ftmass = ftmass,
                                 max_miss = max_miss,
                                 min_len = min_len,
                                 max_len = max_len,
                                 maxn_vmods_per_pep = maxn_vmods_per_pep,
                                 maxn_sites_per_vmod = maxn_sites_per_vmod,
                                 is_fixed_protnt = is_fixed_protnt,
                                 is_fixed_protct = is_fixed_protct)

      message("\tCompleted bare peptide masses.")
    }

    
    # --- Semi-enzymatic and distribution ---
    # Note 1-to-n expansion: 
    #   `length(fwd_peps) == length(aa_masses_all)` after the step.
    # Note 1-to-n expansion: 
    #   `length(fwd_peps) == length(aa_masses_all)` after the step.
    n_cores <- detect_cores(15L)
    
    if (isTRUE(enzyme == "noenzyme"))
      n_cores <- floor(max(1L, n_cores/4L))

    fwd_peps <- chunksplit(fwd_peps, n_cores, "list")
    
    # (a) Optional semi-enzymatic peptides
    if (isTRUE(grepl("^semi", enzyme))) {
      message("Generating semi-enzymatic peptides.")
      
      cl <- parallel::makeCluster(getOption("cl.cores", n_cores))
      
      parallel::clusterExport(
        cl,
        c("hsemipeps_byprots", 
          "semipeps_byprots", 
          "calc_semipepmasses"), 
        envir = environment(mzion::matchMS))

      fwd_peps <- parallel::clusterApply(
        cl, 
        fwd_peps, 
        hsemipeps_byprots, 
        min_len = min_len , 
        max_len = max_len, 
        aa_masses = aa_masses_0)

      parallel::stopCluster(cl)
    }
    
    # (b) Distribution
    message("Distributing peptides by variable modifications.")
    motifs_all <- lapply(aa_masses_all, find_motif_pat)
    
    # maybe at noenzyme searches: 
    #  flatten_list(fwd_peps)
    #  n_cores2 <- min(16L, n_cores * 2L)
    #  chunksplit(fwd_peps, n_cores2)
    #  makeCluster(n_cores2)
    cl <- parallel::makeCluster(getOption("cl.cores", n_cores))

    parallel::clusterExport(
      cl,
      c("distri_peps", 
        "ct_counts", 
        "rm_char_in_nfirst", 
        "rm_char_in_nlast"), 
      envir = environment(mzion::matchMS))

    # aa_masses_all[[1]] is for the original all-fixed mode not for the coerced,
    # otherwise, e.g. fixed to variable coercion of "TMT (K)" with a conflicting 
    # "Acetyl (K)", sequences without "K" will be dropped.

    fwd_peps <- parallel::clusterApply(
      cl, 
      fwd_peps, 
      distri_peps, 
      aa_masses_all = aa_masses_all, 
      motifs_all = motifs_all, 
      max_miss = max_miss, 
      max_len = max_len, # different purpose
      enzyme = enzyme)

    parallel::stopCluster(cl)
    
    fwd_peps <- lapply(seq_along(aa_masses_all), function (i) {
      # by i-th aa_masses from each node
      fwd_peps_i <- lapply(fwd_peps, `[[`, i)
      # combines i-th results across nodes
      flatten_list(fwd_peps_i)
    })
    
    message("\tCompleted bare peptides distributions.")
    rm(list = c("seqs_0"))

    # (c) Protein-peptide associations
    message("Summarizing the association of proteins and peptides.")
    
    path_prp <- create_dir(file.path(.path_ms1masses, .time_stamp))
    
    cl <- parallel::makeCluster(getOption("cl.cores", n_cores))
    
    parallel::clusterExport(cl, c("simple_prots_peps"), 
                            envir = environment(mzion::matchMS))

    prps <- parallel::clusterApply(
      cl, 
      chunksplit(fwd_peps[[1]], n_cores * 4L), 
      simple_prots_peps)
    
    parallel::stopCluster(cl)

    prps <- flatten_list(prps)
    qs::qsave(prps, file.path(path_prp, "simple_prot_pep.rds"), preset = "fast")
    rm(list = c("prps"))

    # (d) Flattened peptide lists (prot_acc's removed)
    fwd_peps <- lapply(fwd_peps, flat_pepseqs)

    # (e) Adjusted base masses if with fixed-to-variable coercion
    # fwd_peps[[1]] ties to the original user-supplied fixed and variable mods;
    #   adjusted against all of the coerced N-, C-term and Anywhere sites
    # also filtered by min_mass and max_mass since it is a final
    fwd_peps[[1]] <- adj_base_masses(fwd_peps[[1]], aa_masses_0, aa_masses_1, 
                                     min_mass = min_mass, max_mass = max_mass, 
                                     digits = digits)

    
    # --- Delta masses of `variable` terminals  ---
    # e.g., on top of the `fixed` 18.010565; 
    # 
    # no effect on fwd_peps[[1]] since it is a "tmod-" (better term "vtmod")
    # 
    # also irrespective to fixed-to-variable coercions:
    #   only one N- or C-term, simple summation makes no difference  
    #   either its under fixed or variable modifcations
    message("Adding variable terminal masses...")
    
    fwd_peps <- mapply(add_term_mass, fwd_peps, aa_masses_ms1, 
                       MoreArgs = list(min_mass = min_mass, max_mass = max_mass), 
                       SIMPLIFY = FALSE)

    # (1) aa_masses_ms1 are the interim coerced lookups
    #   e.g. K = 128.094963 and TMT6plex (K) = 229.1629
    # (2) aa_masses_all are the final back-coerced lookups 
    #   e.g., with TMT6plex (K) coerced back to fixed if no variable Acetyl (K);
    #   K = 357.2579 and no TMT6plex in the lookup
    # -> adds n*229.1629 to the masses to reflect K = 357.2579 in aa_masses_all
    # 
    # attr("anywhere_excepts") in aa_masses_ms1 tells the sites  
    #   that are back-coerced to fixed from aa_masses_ms1 to aa_masses_all
    # (no effect on fwd_peps[[1]] since it is a "amod-")
    message("Adding back-coerced fixed \"Anywhere\" masses...")
    
    if (length(varmods)) 
      fwd_peps <- mapply(adj_anywhere_masses, fwd_peps, aa_masses_ms1, 
                         SIMPLIFY = FALSE)
    
    rm(list = "aa_masses_ms1")

    
    # --- Mass of variable mods and/or NLs ---
    # !!! switch to the "ultimate" aa_masses_all (with back coercion)
    message("Adding variable masses...")
    types <- lapply(aa_masses_all, attr, "type", exact = TRUE)
    types <- unlist(types, recursive = FALSE, use.names = FALSE)

    fmods_ps <- lapply(aa_masses_all, attr, "fmods_ps", exact = TRUE)
    vmods_ps <- lapply(aa_masses_all, attr, "vmods_ps", exact = TRUE)
    fmods_nl <- lapply(aa_masses_all, attr, "fmods_nl", exact = TRUE)
    vmods_nl <- lapply(aa_masses_all, attr, "vmods_nl", exact = TRUE)
    amods    <- lapply(aa_masses_all, attr, "amods",    exact = TRUE)
    tmod     <- lapply(aa_masses_all, attr, "tmod",     exact = TRUE)

    # `amods-` and `fnl+` (must be vnl- since amods-)
    #
    # (5, 6) "amods- tmod+ vnl- fnl+", "amods- tmod- vnl- fnl+"
    if (FALSE) {
      n_cores <- detect_cores(32L) - 1L

      inds <- which(types %in% c("amods- tmod- vnl- fnl+",
                                 "amods- tmod+ vnl- fnl+"))

      if (length(inds)) {
        for (i in inds) {
          fmods_ps_i <- fmods_ps[[i]]
          vmods_ps_i <- vmods_ps[[i]]
          fmods_nl_i <- fmods_nl[[i]]
          vmods_nl_i <- vmods_nl[[i]]
          amods_i <- amods[[i]]
          tmod_i <- tmod[[i]]

          aa_masses_i <- aa_masses_all[[i]]
          ntmod_i <- attr(aa_masses_i, "ntmod", exact = TRUE)
          ctmod_i <- attr(aa_masses_i, "ctmod", exact = TRUE)

          fwd_peps_i <- fwd_peps[[i]]
          
          if (!length(fwd_peps_i))
            next
          
          fnl_combi_i <- expand_grid_rows(fmods_nl_i, use.names = TRUE)
          
          cl <- parallel::makeCluster(getOption("cl.cores", n_cores))
          
          parallel::clusterExport(
            cl,
            c("hms1_a0_vnl0_fnl1", 
              "ms1_a0_vnl0_fnl1", 
              "expand_grid_rows", 
              "delta_ms1_a0_fnl1"), 
            envir = environment(mzion::matchMS))
          
          fwd_peps[[i]] <- parallel::clusterApply(
            cl, 
            chunksplit(fwd_peps_i, n_cores, "list"), 
            hms1_a0_vnl0_fnl1, 
            fnl_combi = fnl_combi_i, 
            aa_masses = aa_masses_i,
            min_mass = min_mass, 
            max_mass = max_mass, 
            digits = digits
          )
          
          parallel::stopCluster(cl)
          
          fwd_peps[[i]] <- flatten_list(fwd_peps[[i]])
          fwd_peps[[i]] <- unlist(fwd_peps[[i]], recursive = FALSE, use.names = TRUE)
        }
      }
    }
    

    # `amods+`; (9-14) nested under (7-8)
    #
    # (7-8) "amods+ tmod- vnl- fnl-", "amods+ tmod+ vnl- fnl-"
    #   (9-10)  "amods+ tmod- vnl+ fnl-", "amods+ tmod+ vnl+ fnl-"
    #   (11-12) "amods+ tmod- vnl- fnl+", "amods+ tmod+ vnl- fnl+"
    #   (13-14) "amods+ tmod- vnl+ fnl+", "amods+ tmod+ vnl+ fnl+"
    
    # i = 4
    # 16L: 1.45542643 mins
    # 32L: 1.0508078 mins
    # 64L: 1.06206823 mins
    # 96L: 1.25min
    # 128L: 1.44mins
    
    # i = 7L
    # 16L: 16.572324 secs
    # 32L: 22.6
    # 64L: 39 

    n_cores <- detect_cores(15L)

    inds <- which(types %in% c("amods+ tmod- vnl- fnl-",
                               "amods+ tmod+ vnl- fnl-",
                               "amods+ tmod- vnl+ fnl-",
                               "amods+ tmod+ vnl+ fnl-",
                               "amods+ tmod- vnl- fnl+",
                               "amods+ tmod+ vnl- fnl+",
                               "amods+ tmod- vnl+ fnl+",
                               "amods+ tmod+ vnl+ fnl+"))

    if (length(inds)) {
      cl <- parallel::makeCluster(getOption("cl.cores", n_cores))
      
      parallel::clusterExport(
        cl,
        c("hms1_a1_vnl0_fnl0", 
          "ms1_a1_vnl0_fnl0", 
          "match_mvmods", 
          "expand_grid_rows", 
          "recur_flatten", 
          "delta_ms1_a0_fnl1"), 
        envir = environment(mzion::matchMS))

      for (i in inds) {
        amods_i <- amods[[i]]
        aa_masses_i <- aa_masses_all[[i]]
        ms1vmods_i <- ms1vmods_all[[i]]
        
        # at maxn_vmods_per_pep = 3, ms1vmods_i is empty at 
        #   Oxidation (M), Phospho (S), Phospho (T), Phospho (Y)
        if (!length(ms1vmods_i)) {
          fwd_peps[i] <- list(NULL)
          next
        }

        fwd_peps_i <- fwd_peps[[i]]
        
        if (!length(fwd_peps_i))
          next

        vmods_nl_i = vmods_nl[[i]]
        fmods_nl_i = fmods_nl[[i]]

        ansi <- parallel::clusterApply(
          cl, 
          chunksplit(fwd_peps_i, n_cores, "list"), 
          hms1_a1_vnl0_fnl0, 
          amods = amods_i, 
          aa_masses = aa_masses_i,
          vmods_nl = vmods_nl_i, 
          fmods_nl = fmods_nl_i,
          maxn_vmods_per_pep = maxn_vmods_per_pep,
          maxn_sites_per_vmod = maxn_sites_per_vmod,
          ms1vmods = ms1vmods_i, 
          min_mass = min_mass, 
          max_mass = max_mass, 
          digits = digits)
        
        ansi <- flatten_list(ansi)
        fwd_peps[[i]] <- unlist(ansi, recursive = FALSE, use.names = TRUE)

        message("\tCompleted peptide masses: ",
                paste(attributes(aa_masses_i)$fmods, "|", 
                      attributes(aa_masses_i)$vmods,
                      collapse = ", "))
      }
      
      parallel::stopCluster(cl)
    }

    suppressWarnings(
      rm(list = c("amods_i", "fmods_nl", "fmods_ps", "fwd_peps_i", 
                  "vmods_nl_i", "aa_masses_1", "aa_masses_i")))

    # fwd_peps <- lapply(fwd_peps, add_ms1_13c, n_13c, max_mass)
    # fwd_peps <- lapply(fwd_peps, add_ms1_notches, ms1_notches, max_mass)

    # === Outputs ===
    path_masses <- create_dir(file.path(.path_ms1masses, .time_stamp))

    fwd_peps <- mapply(function (x, y) {
      attr(x, "data") <- y
      x
    }, aa_masses_all, fwd_peps, SIMPLIFY = FALSE, USE.NAMES = FALSE)

    names(fwd_peps) <- seq_along(aa_masses_all)

    for (i in seq_along(fwd_peps))
      qs::qsave(fwd_peps[[i]], 
                file.path(path_masses, paste0("pepmasses_", i, ".rds")), 
                preset = "fast")

    .savecall <- TRUE
    message("\n=== Completed MS1 precursor masses. ===\n")
  }

  local({
    .cache_info <- list(
      .path_cache = .path_cache, 
      .path_fasta = .path_fasta, 
      .path_ms1masses = .path_ms1masses, 
      .time_stamp = .time_stamp
    )
    
    path <- create_dir(file.path(out_path, "Calls"))
    qs::qsave(.cache_info, file.path(path, ".cache_info.rds"), preset = "fast")
  })

  # fwd_peps may be NULL if matched with cached
  # attr(fwd_peps, ".time_stamp") <- .time_stamp
  invisible(fwd_peps)
}


#' Finds the existence of \code{aa_masses_all.rds}.
#'
#' @inheritParams calc_pepmasses2
find_aa_masses <- function(aa_masses = NULL, out_path = NULL, fixedmods = NULL, 
                           varmods = NULL, rm_dup_term_anywhere = TRUE, 
                           varlabs = NULL, mod_motifs = NULL, 
                           maxn_vmods_setscombi = 64L) 
{
  file <- file.path(out_path, "aa_masses_all.rds")
  
  if (file.exists(file))
    return(qs::qread(file))
  
  message("Computing the combinations of fixed and variable modifications.")
  
  dir.create(out_path, recursive = TRUE, showWarnings = FALSE)

  aa_masses_all <- calc_aamasses(fixedmods = fixedmods,
                                 varmods = varmods,
                                 rm_dup_term_anywhere = rm_dup_term_anywhere, 
                                 aa_masses = aa_masses, 
                                 varlabs = varlabs, 
                                 mod_motifs = mod_motifs, 
                                 maxn_vmods_setscombi = maxn_vmods_setscombi,
                                 out_path = out_path)

  invisible(aa_masses_all)
}


#' Finds the motifs of modifications.
#' 
#' @param aa_masses A list of amino acid lookups.
find_motif_pat <- function (aa_masses)
{
  mms <- attr(aa_masses, "mod_motifs", exact = TRUE)
  mms <- .Internal(unlist(mms, recursive = FALSE, use.names = FALSE))
  
  if (length(mms))
    .Internal(paste0(list(unique(mms)), collapse = "|", recycle0 = FALSE))
  else
    NULL
}


#' A lookup between prot_acc and pep_seqs.
#'
#' For targets peptides.
#'
#' Columns: \code{is_pnt}, is Protein N-term; \code{is_pct}, is Protein C-term.
#' For example, MEYEWKPDEQGLQQILQLLK: NP_002261, pep_start 9; NP_694858:
#' pep_start 1. Without the information of protein terminals, the peptide
#' sequence with the modification of Acetyl Protein N-term will match to both
#' protein accessions, with the match to NP_002261 being inconsistent.
#'
#' @param seqs Results from \link{distri_peps}.
#' @examples
#' \donttest{
#' # library(mzion)
#' # mzion:::simple_prots_peps(fwd_peps[[1]])
#' }
simple_prots_peps <- function (seqs) 
{
  nms <- lapply(seqs, names)
  pnt_idxes <- lapply(seqs, attr, "pnt_idxes", exact = TRUE)
  pct_idxes <- lapply(seqs, attr, "pct_idxes", exact = TRUE)
  
  # efficient to remove duplicated peptides within a protein by "sub_protpep"
  # on the contrary, not to remove duplicated sequences within proteins: 
  #   otherwise pnt_idxes, pct_idxes and dup_idxes will be different
  
  # dups <- lapply(nms, duplicated.default)
  # dups <- lapply(dups, which)
  
  mapply(function (nm, pnt, pct) {
    attr(nm, "pnt_idxes") <- pnt
    attr(nm, "pct_idxes") <- pct
    nm
  }, nms, pnt_idxes, pct_idxes, 
  SIMPLIFY = FALSE, USE.NAMES = TRUE)
}


#' Flattens pep_seqs with the removals of prot_accs.
#' 
#' @param x Lists of pep_seqs by prot_accs.
flat_pepseqs <- function (x) 
{
  x <- flatten_list(x)
  x <- .Internal(unlist(x, recursive = FALSE, use.names = TRUE))
  
  x[!duplicated.default(names(x))]
}


#' Finds the site of an AA residue.
#'
#' e.g. 'N-term' in `aa_masses`, not 'Q', for Gln-> pyro-Glu (N-term = Q).
#'
#' @param pos_site A named value. Position in name and site in value.
find_aa_site <- function (pos_site) 
{
  nms <- names(pos_site)
  
  site <- if (isTRUE(grepl("[NC]{1}-term", nms))) 
    gsub("(Protein|Any) ([NC]{1}-term)", "\\2", nms)
  else 
    pos_site
}


#' Calculates molecular weight of a polypeptide ([MH]+).
#'
#' @param fixedmods A character vector of fixed modifications. See also
#'   \link{parse_unimod} for grammars.
#' @param varmods A character vector of variable modifications.
#' @param maxn_vmods_setscombi Integer; the maximum number of combinatorial variable
#'   modifications and neutral losses.
#' @param out_path An output path.
#' @param aa_masses An amino-acid mass lookup.
#' @inheritParams matchMS
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' x <- calc_aamasses()
#' x_att <- lapply(x, attributes)
#' names(x_att[[1]])
#' x_vmods <- lapply(x_att, `[`, c("vmods"))
#' x_fmods <- lapply(x_att, `[`, c("fmods"))
#' 
#' x <- calc_aamasses(fixedmods = c("TMT6plex (N-term)", "TMT6plex (K)", "Carbamidomethyl (C)"), 
#'                    varmods   = c("Acetyl (N-term)", "Gln->pyro-Glu (N-term = Q)", "Oxidation (M)"))
#' 
#' stopifnot(length(x) == 6L)
#'
#' # Fixed N-term mod (no coercion to variable mod)
#' x <- calc_aamasses(fixedmods = "TMT6plex (N-term)", varmods = NULL)
#' x[[1]][["N-term"]]
#' 
#' # Fixed N-term mod (coerced to variable mod)
#' x <- calc_aamasses(fixedmods = "TMT6plex (N-term)", varmods = "Acetyl (Protein N-term)")
#' lapply(x, `[[`, "N-term")
#' x[[1]]["N-term"]
#' x[[2]][["Acetyl (Protein N-term)"]]
#' 
#' # No fixed mod
#' x <- calc_aamasses(fixedmods = NULL)
#' stopifnot(length(x) == 16L)
#' 
#' x <- calc_aamasses(fixedmods = NULL, varmods = NULL)
#' stopifnot(length(x) == 1L)
#'
#' # Fixed mod, no NL
#' x <- calc_aamasses(fixedmods = c("TMT6plex (N-term)", "TMT6plex (K)",
#'                                  "Carbamidomethyl (. = C)"), varmods = NULL)
#' 
#' stopifnot(length(x) == 1L)
#' 
#' # Fixed mod + NL
#' x <- calc_aamasses(fixedmods = c("TMT6plex (N-term)", "TMT6plex (K)",
#'                                  "Carbamidomethyl (. = M)"), varmods = NULL)
#' 
#' stopifnot(length(x) == 1L)
#' 
#' # Fixed mod, no NL; var mod, no NL
#' x <- calc_aamasses(fixedmods = c("TMT6plex (N-term)", "TMT6plex (K)",
#'                                  "Carbamidomethyl (. = C)"),
#'                    varmods = c("Acetyl (N-term)", "Gln->pyro-Glu (N-term = Q)"))
#' 
#' stopifnot(length(x) == 3L)
#' 
#' # Fixed mod + NL; var mod + NL
#' x <- calc_aamasses(fixedmods = c("TMT6plex (N-term)", "TMT6plex (K)",
#'                      "Carbamidomethyl (. = M)",
#'                      "Deamidated (. = R)"),
#'                    varmods = c("Acetyl (N-term)", "Gln->pyro-Glu (N-term = Q)",
#'                      "Hex(5)HexNAc(2) (N)"))
#' 
#' stopifnot(length(x) == 6L)
#' 
#' x <- calc_aamasses(c(fixedmods = "TMT6plex (N-term)", "TMT6plex (K)",
#'                      "Carbamidomethyl (. = M)", "Deamidated (. = R)"),
#'                    varmods = c("Acetyl (N-term)", "Carbamyl (. = M)",
#'                      "Gln->pyro-Glu (N-term = Q)", "Hex(5)HexNAc(2) (N)"))
#' 
#' stopifnot(length(x) == 18L)
#' 
#' ## Coercion       
#' # No fixed terminal or fixed anywhere coercion
#' x <- calc_aamasses(fixedmods = c("TMT6plex (N-term)", "TMT6plex (K)", 
#'                      "Carbamidomethyl (C)"),
#'                    varmods = c("Carbamidomethyl (M)"))
#' 
#' stopifnot(length(x) == 2L)
#' 
#' x <- calc_aamasses(fixedmods = c("TMT6plex (K)", "Carbamidomethyl (C)"), 
#'                    varmods = c("Acetyl (Protein N-term)", "TMT6plex (N-term)", 
#'                      "Oxidation (M)", "Carbamidomethyl (M)"))
#' 
#' stopifnot(length(x) == 12L)
#' 
#' # Fixed terminal coercion
#' x <- calc_aamasses(fixedmods = c("TMT6plex (N-term)", "TMT6plex (K)", 
#'                      "Carbamidomethyl (C)"),
#'                    varmods = c("Acetyl (Protein N-term)", "Oxidation (M)"))
#'                    
#' stopifnot(length(x) == 4L)
#' 
#' # Fixed anywhere coercion
#' x <- calc_aamasses(fixedmods = c("TMT6plex (N-term)", "TMT6plex (K)", 
#'                      "Carbamidomethyl (C)", "Carbamidomethyl (M)"),
#'                    varmods = c("Oxidation (M)"))
#'                    
#' stopifnot(length(x) == 3L)
#'                    
#' # Both fixed terminal and fixed anywhere coercion
#' x <- calc_aamasses(fixedmods = c("TMT6plex (N-term)", "TMT6plex (K)", 
#'                      "Carbamidomethyl (C)", "Carbamidomethyl (M)"),
#'                    varmods = c("Acetyl (Protein N-term)", "Oxidation (M)"))
#' 
#' stopifnot(length(x) == 6L)
#' 
#' }
#' \dontrun{
#' # conflicts
#' x <- calc_aamasses(fixedmods = c("Carbamidomethyl (N-term)", "TMT2plex (N-term)"), 
#'                    varmods = NULL)
#'
#' # need separate S and T
#' x <- calc_aamasses(fixedmods = NULL, varmods = "Phospho (ST)")
#' }
#' @export
calc_aamasses <- function (fixedmods = c("TMT6plex (K)",
                                         "Carbamidomethyl (. = C)"),
                           varmods = c("TMT6plex (N-term)",
                                       "Acetyl (Protein N-term)",
                                       "Oxidation (M)",
                                       "Deamidated (N)",
                                       "Gln->pyro-Glu (N-term = Q)"),
                           rm_dup_term_anywhere = TRUE, 
                           aa_masses = NULL, varlabs = NULL, mod_motifs = NULL, 
                           maxn_vmods_setscombi = 64L, out_path = NULL) 
{
  # title (position = site);
  # . stands for (a) anywhere in position or (b) any residue in site or both
  # Acetyl (Protein N-term) <-> Acetyl (Protein N-term = .)
  # Acetyl (N-term) <-> Acetyl (N-term = .)
  # Carbamidomethyl (C) <-> Carbamidomethyl (. = C)
  # Carbamidomethyl <-> Carbamidomethyl(. = .)
  # Gln->pyro-Glu (N-term Q) <-> Gln->pyro-Glu (N-term = Q)
  # anywhere, can be skipped: title (site)
  # N-term, C-term, Protein N-term, Protein C-term

  ## The same site but different mods
  #  (a) Among fixedmods; Failure (only 'one_of', prompt to devise of a joint Unimod)
  #      (a1) TMT6plex (N-term)
  #      (a2) Biotin (N-term)
  #  (b) Between fixedmods and varmods; Relaxation (from fixedmods to varmods)
  #      (b1) Fixed TMT (N-term) -> Variable TMT (N-term)
  #           Variable Acetyl (N-term)
  #      (b2) Fixed Oxidation (M) -> Variable Oxidation (M)
  #           variable Met->Ala (M)
  #  (c) Among varmods; OK if is 'one_of' in combination but not 'multiple'
  #      (c1) Oxidation (M)
  #      (c2) Met->Ala (M)
  #      excludes (c1) + (c2)
  #      OK if different mods to the same residue at different indexes of a peptide
  #      (c3) dHex(1)Hex(1) (S): VS(3)SALSPSK
  #      (c4) Phospho (S): VSS(4)ALSPSK

  options(digits = 9L)

  ## (0) Prep
  check_dupfvmods(fixedmods, varmods)
  
  fixedmods_orig <- fixedmods
  new_mods <- coerce_fvmods(fixedmods, varmods)
  fixedmods <- new_mods$fixedmods
  varmods <- new_mods$varmods
  f_to_v <- new_mods$f_to_v
  anywhere_coerce_sites <- new_mods$anywhere_coerce_sites
  nt_coerce_site <- new_mods$nt_coerce_site
  ct_coerce_site <- new_mods$ct_coerce_site
  rm(list = "new_mods")
  
  if (!is.null(mod_motifs)) check_mod_motifs(mod_motifs, c(fixedmods, varmods))
  fmod_motifs <- mod_motifs[names(mod_motifs) %in% fixedmods]
  vmod_motifs <- mod_motifs[names(mod_motifs) %in% varmods]
  
  if (is.null(aa_masses)) {
    aa_masses <- c(
      A = 71.037114, R = 156.101111, N = 114.042927, D = 115.026943,
      C = 103.009185, E = 129.042593, Q = 128.058578, G = 57.021464,
      H = 137.058912, I = 113.084064, L = 113.084064, K = 128.094963,
      M = 131.040485, F = 147.068414, P = 97.052764, S = 87.032028,
      T = 101.047679, W = 186.079313, Y = 163.063329, V = 99.068414,
      "N-term" = 1.007825, "C-term" = 17.002740,
      U = 150.953633, B = 114.534940, X = 111.000000, Z = 128.550590,
      "-" = 0)
  }

  # At the end, the mass delta from fixed [NC]-term will be added to 
  # each aa_masses["N-term"] and aa_masses["C-term"]
  # e.g. with a TMT N-term tag, aa_masses["N-term"] + aa_masses["C-term"] = 
  # TMT + H2O
  # 
  # Variable [NC]-term will be a parallel entry in an aa_masses
  # e.g., aa_masses["Acetyl (N-term)"]
  # 
  # In other words, masses of fixed modification will be reflected in residues,
  # including "N-term" and "C-term"; 
  # Masses of variable modifications will be additive to the base vector of list.
  # E.g., if "Oxidated (M)" is a fixed modification -> M = 147; otherwise if
  # it is a variable modification, M = 131 and there is a second entry of 
  # "Oxidated (M)" = 147.

  ## (1, 2) add fixed mods + NL, coerced fixed mods + NL
  aa_masses_fi <- add_fixed_masses(fixedmods_orig, aa_masses, fmod_motifs)
  
  aa_masses_fc <- if (is.null(f_to_v))
    aa_masses_fi
  else
    add_fixed_masses(fixedmods, aa_masses, fmod_motifs)
  
  attr(aa_masses_fc, "nt_coerce_site") <- nt_coerce_site
  attr(aa_masses_fc, "ct_coerce_site") <- ct_coerce_site
  attr(aa_masses_fc, "anywhere_coerce_sites") <- anywhere_coerce_sites

  ## (3) add variable mods + NL
  varmods_comb <- find_aamasses_vmodscombi(varmods, f_to_v, anywhere_coerce_sites)
  
  if (rm_dup_term_anywhere) {
    oks <- unlist(lapply(varmods_comb, check_dup_term_any))
    varmods_comb <- varmods_comb[oks]
  }

  aa_masses_var <- lapply(varmods_comb, add_var_masses, aa_masses = aa_masses_fc, 
                          varlabs = varlabs, mod_motifs = vmod_motifs, 
                          anywhere_coerce_sites = anywhere_coerce_sites, 
                          nt_coerce_site = nt_coerce_site, 
                          ct_coerce_site = ct_coerce_site)

  if (length(aa_masses_var) >= maxn_vmods_setscombi) {
    warning("The ways of combinatorial variable modifications are ",
            length(aa_masses_var), ".\n",
            "Dropping combinations at indexes greater than `maxn_vmods_setscombi = ", 
            maxn_vmods_setscombi, "`.",
            call. = FALSE)
    
    aa_masses_var <- aa_masses_var[1:maxn_vmods_setscombi]
  }
  
  aa_masses_ms1 <- lapply(c(list(aa_masses_fc), aa_masses_var), parse_aamasses)
  
  aa_masses_all <- lapply(c(list(aa_masses_fi), aa_masses_var), finalize_aamasses, 
                          aa_masses = aa_masses, varlabs = varlabs, 
                          mod_motifs = mod_motifs)

  if (!is.null(out_path)) {
    save_mod_indexes(out_path, fixedmods, varmods, f_to_v)
    qs::qsave(aa_masses_ms1, file.path(out_path, "aa_masses_ms1.rds"), preset = "fast")
    qs::qsave(aa_masses_all, file.path(out_path, "aa_masses_all.rds"), preset = "fast")
    
    fmods <- lapply(aa_masses_all, attr, "fmods", exact = TRUE)
    vmods <- lapply(aa_masses_all, attr, "vmods", exact = TRUE)
    
    readr::write_tsv(
      data.frame(pep_fmod = unlist(fmods, recursive = FALSE), 
                 pep_vmod = unlist(vmods, recursive = FALSE), 
                 pep_mod_group = seq_along(aa_masses_all)), 
      file.path(out_path, "summary_mod_groups.txt"))
  }
  
  invisible(aa_masses_all)
}


#' Finalizes \code{aa_masses_all}
#'
#' Replaces interim fixed and variable modifications with the finals. Results in
#' correct attributes in aa_masses_i. 
#'
#' @param aa_masses_i The i-th aa_masses_all.
#' @param aa_masses The original look-ups of AA masses.
#' @inheritParams matchMS
finalize_aamasses <- function (aa_masses_i, aa_masses, varlabs = NULL, 
                               mod_motifs = NULL)
{
  fixedmods <- names(attr(aa_masses_i, "fmods_ps", exact = TRUE))
  varmods <- names(attr(aa_masses_i, "vmods_ps", exact = TRUE))
  
  anywhere_excepts <- attr(aa_masses_i, "anywhere_excepts", exact = TRUE)
  nt_except <- attr(aa_masses_i, "nt_except", exact = TRUE)
  ct_except <- attr(aa_masses_i, "ct_except", exact = TRUE)
  excepts <- c(anywhere_excepts, nt_except, ct_except)
  cmods <- names(excepts)
  
  # coerced mods
  if (length(cmods)) {
    fixedmods <- c(fixedmods, cmods)
    varmods <- varmods[!varmods %in% cmods]
  }
  
  fmod_motifs <- mod_motifs[names(mod_motifs) %in% fixedmods]
  vmod_motifs <- mod_motifs[names(mod_motifs) %in% varmods]
  
  # may skip the mass updates if no coerced mods
  aa_masses_i <- add_fixed_masses(mods = fixedmods, aa_masses = aa_masses, 
                                  mod_motifs = fmod_motifs)
  
  aa_masses_i <- add_var_masses(mods = varmods, aa_masses = aa_masses_i, 
                                varlabs = varlabs, mod_motifs = vmod_motifs)
  
  aa_masses_i <- parse_aamasses(aa_masses_i)
}


#' Saves mod_indexes.txt
#'
#' @param out_path An output path
#' @param fixedmods Fixed modifications
#' @param varmods Variable modifications
#' @param f_to_v Coerced fixed to variable modifications
#' @param collapse Logical; if TRUE, collapses modification indexes at the same
#'   title.
save_mod_indexes <- function (out_path = NULL, fixedmods, varmods, f_to_v, 
                              collapse = FALSE)
{
  if (is.null(out_path))
    return(NULL)
  
  fvs <- c(fixedmods, varmods)
  mod_indexes <- seq_along(fvs)
  mod_indexes <- as.hexmode(mod_indexes)
  names(mod_indexes) <- fvs

  is_coerced <- if (length(f_to_v)) 
    names(mod_indexes) %in% f_to_v
  else 
    rep(FALSE, length(mod_indexes))
  
  Desc <- if (length(mod_indexes)) 
    names(mod_indexes)
  else 
    character()
  
  ## At NULL fixedmods and varmods: 
  # [1] Abbr    Desc    Type    Coerced
  # <0 rows> (or 0-length row.names)
  
  df_mods <- data.frame(Abbr = as.character(mod_indexes),
                        Desc = Desc, 
                        Type = c(rep("fixed", length(fixedmods)), 
                                 rep("variable", length(varmods))), 
                        Coerced = is_coerced) 
  
  # Not yet tested
  if (collapse) {
    df_mods$Title <- gsub("([^ ]) .*","\\1", df_mods$Desc)
    df_mods$Abbr <- 
      as.integer(factor(df_mods$Title, levels = unique(df_mods$Title)))
    df_mods$Title <- NULL
  }

  readr::write_tsv(df_mods, file.path(out_path, "mod_indexes.txt"))
}


#' Checks duplicated modifications between fixedmods and varmods
#' 
#' @inheritParams calc_aamasses
check_dupfvmods <- function (fixedmods, varmods)
{
  dup_mods <- intersect(fixedmods, varmods)
  
  if (length(dup_mods)) 
    stop("Modifications cannot be simultaneously 'fixed' and 'variable': \n",
         paste(dup_mods, collapse = ", "), "\n", 
         "Hint: the default \"fixedmods\" and \"varmods\" are not NULL.")
}


#' Coerces conflicting fixedmods to varmods
#' 
#' @inheritParams calc_aamasses
coerce_fvmods <- function (fixedmods, varmods)
{
  fmods_ps <- find_modps(fixedmods)
  vmods_ps <- find_modps(varmods)
  
  local({
    if (length((dup_fsites <- fmods_ps[duplicated(fmods_ps)])))
      stop("Multiple fixed modifications to the same site: \n",
           "'", paste(dup_fsites, collapse = ", "), "'")
  })
  
  coerce_sites <- find_f_to_v(fixedmods, fmods_ps, vmods_ps)
  fV_coercion <- (length(coerce_sites) > 0L)

  if (fV_coercion) {
    f_to_v <- names(coerce_sites)
    varmods <- c(f_to_v, varmods)
    fixedmods <- fixedmods[!fixedmods %in% f_to_v]
    
    warning("Coerce '",
            paste(f_to_v, collapse = ", "), "'",
            " to conditional variable modifications.",
            call. = FALSE)

    oks_a <- !grepl("[NC]-term", f_to_v)
    oks_n <- grepl("N-term", f_to_v)
    oks_c <- grepl("C-term", f_to_v)
    
    # ok since the parity between coerce_sites and f_to_v
    anywhere_coerce_sites <- coerce_sites[oks_a]
    nt_coerce_site <- coerce_sites[oks_n]
    ct_coerce_site <- coerce_sites[oks_c]
    if (!length(anywhere_coerce_sites)) anywhere_coerce_sites <- NULL
    if (!length(nt_coerce_site)) nt_coerce_site <- NULL
    if (!length(ct_coerce_site)) ct_coerce_site <- NULL
  } 
  else {
    fixedmods <- fixedmods
    varmods <- varmods
    f_to_v <- NULL
    anywhere_coerce_sites <- NULL
    nt_coerce_site <- NULL
    ct_coerce_site <- NULL
  }

  default_mods <- c("initiator methionine from protein N-terminus")
  
  if (any(grepl(default_mods, c(fixedmods, varmods)))) 
    warning("Modifications defaulted and no need to specify: `\n",
            default_mods, "`.\n",
            call. = FALSE)
  
  list(fixedmods = fixedmods, 
       varmods = varmods, 
       f_to_v = f_to_v, 
       anywhere_coerce_sites = anywhere_coerce_sites, 
       nt_coerce_site = nt_coerce_site, 
       ct_coerce_site = ct_coerce_site)
}


#' Helper of finding the coercion sites.
#'
#' @param fmods_ps Positions and sites of fixed modifications.
#' @param vmods_ps Positions and sites of variable modifications.
#' @inheritParams calc_aamasses
#' @return A named vector, e.g., \code{c("TMT6plex (K) = K", "TMT6plex
#'   (N-term)" = "N-term")}
find_f_to_v <- function (fixedmods, fmods_ps, vmods_ps)
{
  f_nms <- names(fmods_ps)
  v_nms <- names(vmods_ps)
  
  ok_ft <- grepl("[NC]-term", f_nms)
  ok_vt <- grepl("[NC]-term", v_nms)
  fmods_ps_any <- fmods_ps[!ok_ft]
  vmods_ps_any <- vmods_ps[!ok_vt]
  fmods_ps_term <- fmods_ps[ok_ft]
  vmods_ps_term <- vmods_ps[ok_vt]

  coerce_asites <- fmods_ps_any[fmods_ps_any %in% vmods_ps_any]
  coerce_tsites <- fmods_ps_term[fmods_ps_term %in% vmods_ps_term]
  
  # e.g. "N-term" can be matched by both site and position
  # (no guarantee in the order of coerce_sites; so match names one at a time)
  coerce_sites <- unique(c(coerce_asites, coerce_tsites))
  
  coerce_sites <- lapply(coerce_sites, function (x) {
    names(x) <- fixedmods[fmods_ps == x]
    x
  })

  unlist(coerce_sites)
}

#' Checks mod_motifs
#' 
#' @param mods A concatenated list of fixed and variable modifications.
#' @inheritParams calc_aamasses
check_mod_motifs <- function (mod_motifs, mods)
{
  if (length((bads <- mod_motifs[!names(mod_motifs) %in% mods])))
    stop("\"mod_motifs\" not found in \"varmods\" or \"fixedmods\": ", 
         paste(bads, collapse = ", "))
}


#' Finds the combination of varmods
#' 
#' @param f_to_v Coerced fixed to variable modifications
#' @param anywhere_coerce_sites \code{Anywhere} sites coerced from fixed to
#'   variable modifications.
#' @inheritParams calc_aamasses
find_aamasses_vmodscombi <- function (varmods = NULL, f_to_v = NULL, 
                                      anywhere_coerce_sites = NULL) 
{
  if (is.null(varmods))
    return(NULL)
  
  varmods_comb <- lapply(seq_along(varmods), function (x) sim_combn(varmods, x)) 
  varmods_comb <- unlist(varmods_comb, recursive = FALSE)
  vmods_ps <- find_modps(varmods)

  vmods_ps_combi <- seq_along(vmods_ps)
  vmods_ps_combi <- lapply(vmods_ps_combi, function (x) sim_combn(vmods_ps, x))
  vmods_ps_combi <- flatten_list(vmods_ps_combi)

  ## Remove the combinations without anywhere_coerce_sites
  # [x] e.g. "TMT6plex (K)" coerced from fixedmod to varmod, 
  #     the combination after coercion must contain "K"
  # [x] in the (less frequent) case of multiple varmod coercions, 
  #     apply a strong condition of "all" sites
  
  # if no K -> need everything else: TMT6plex (N-term), Acetyl (K), Deamidated (N)
  if ((len_a <- length(anywhere_coerce_sites)) > 1L) {
    warning("Multiple coercions from fixed to variable modifications: ", 
            paste(anywhere_coerce_sites, collapse = ", "), "\n", 
            "Suggest change (some of) them to variable modifications.")
  }

  if (len_a) {
    ok_coerced_sites <- 
      lapply(vmods_ps_combi, function (v) all(anywhere_coerce_sites %in% unlist(v)))
    ok_coerced_sites <- unlist(ok_coerced_sites)
  }
  else {
    ok_coerced_sites <- NULL
  }

  ## Remove the combinations with multiple terminal mods
  #  by names: Gln->pyro Glu (N-term = Q) and Acetyl (Protein N-term = N-term)
  #  have different sites but 'N-term' in names; and also need to be excluded
  dup_terms <-
    purrr::map_lgl(vmods_ps_combi, ~ sum(grepl("N-term", names(.x))) >= 2L) |
    purrr::map_lgl(vmods_ps_combi, ~ sum(grepl("C-term", names(.x))) >= 2L)
  
  # Allow entries with different Anywhere mods to the same site
  #   (1) dHex(1)Hex(1) (S) and (2) Phospho (S)
  #   VS(1)S(2)ALSPSK
  
  varmods_comb <- if (is.null(ok_coerced_sites))
    varmods_comb[!dup_terms]
  else 
    varmods_comb[!dup_terms & ok_coerced_sites]

  ## Remove the combinations without terminal mods
  # e.g., if `Fixed Anywhere N-term` by users 
  #   -> must have `N-term` in any realization of varmods
  fixednt_coercion <- any(grepl("N-term", f_to_v))
  fixedct_coercion <- any(grepl("C-term", f_to_v))

  if (fixednt_coercion && length(varmods_comb)) {
    ok_nts <- lapply(varmods_comb, function (x) any(grepl("N-term", x)))
    varmods_comb <- varmods_comb[unlist(ok_nts)]
    rm(list = c("ok_nts"))
  }
  
  if (fixedct_coercion && length(varmods_comb)) {
    ok_cts <- lapply(varmods_comb, function (x) any(grepl("C-term", x)))
    varmods_comb <- varmods_comb[unlist(ok_cts)]
    rm(list = c("ok_cts"))
  }

  if (length(f_to_v)) {
    is_base <- lapply(varmods_comb, function (x) all(x %in% f_to_v))
    is_base <- unlist(is_base)
    varmods_comb <- varmods_comb[!is_base]
  }
    
  varmods_comb
}


#' Helper to add modification masses to amino-acid residues.
#'
#' It adds the masses of fixed, variable, and neutral-loss modifications to
#' amino-acid residues.
#'
#' @param mods A list of modifications.
#' @param aa_masses A named list containing the (mono-isotopic) masses of amino
#'   acid residues.
#' @param anywhere_coerce_sites The sites of coerced Anywhere modifications; for
#'   example, \code{K}.
#' @param nt_coerce_site A N-terminal coerced site.
#' @param ct_coerce_site A C-terminal coerced site.
#' @inheritParams matchMS
#' @return Lists of of amino-acid residues with modified mono-isotopic masses
#'   being incorporated. Returns NULL if \code{is.null(varmods_comb)}.
add_var_masses <- function (mods, aa_masses, varlabs = NULL, mod_motifs = NULL, 
                            anywhere_coerce_sites = NULL, nt_coerce_site = NULL, 
                            ct_coerce_site = NULL) 
{
  mod_type <- "vmods"
  all_mods <- if (length(mods)) paste(mods, collapse = ", ") else ""
  
  res <- extract_umods(mods)
  mod_masses <- lapply(res, `[[`, "monomass")
  positions_sites <- lapply(res, `[[`, "position_site")
  neulosses <- lapply(res, `[[`, "nl")
  positions <- unlist(lapply(positions_sites, names), use.names = FALSE)
  sites <- unlist(lapply(positions_sites, find_aa_site), use.names = FALSE)
  rm(list = c("res"))

  if (!is.null(varlabs)) {
    # subsets positions_sites2 by positions_sites
    res2 <- extract_umods(varlabs)
    mod_masses2 <- lapply(res2, `[[`, "monomass")
    positions_sites2 <- lapply(res2, `[[`, "position_site")
    neulosses2 <- lapply(res2, `[[`, "nl")
    positions2 <- unlist(lapply(positions_sites2, names), use.names = FALSE)
    sites2 <- unlist(lapply(positions_sites2, find_aa_site), use.names = FALSE)
    rm(list = "res2")

    oks2 <- (positions2 %in% positions) & (sites2 %in% sites)
    positions_sites2 <- positions_sites2[oks2]
    mod_masses2 <- mod_masses2[oks2]
    neulosses2 <- neulosses2[oks2]
    positions2 <- positions2[oks2]
    sites2 <- sites2[oks2]
    rm(list = c("oks2"))

    # to ensure the same order
    ps <- paste(positions, sites, sep = ".")
    ps2 <- paste(positions2, sites2, sep = ".")
    idxes <- match(ps2, ps)
    rm(list = c("ps", "ps2"))
    
    # updates mass deltas and NLs
    mod_masses[idxes] <- mod_masses[idxes] %+% mod_masses2

    if (length(neulosses2))
      neulosses[idxes] <- mapply(function (x, y) x + y, neulosses[idxes], neulosses2, 
                                 USE.NAMES = TRUE, SIMPLIFY = FALSE)
    
    rm(list = c("mod_masses2", "positions_sites2", "neulosses2", "idxes", 
                "positions2", "sites2"))
  }

  anywhere_excepts <- find_except_sites(anywhere_coerce_sites, positions_sites)
  nt_except <- find_except_sites(nt_coerce_site, positions_sites)
  ct_except <- find_except_sites(ct_coerce_site, positions_sites)

  for (i in seq_along(positions_sites))
    aa_masses[names(positions_sites[i])] <- mod_masses[[i]]

  attr(aa_masses, mod_type) <- all_mods
  attr(aa_masses, paste0(mod_type, "_ps")) <- positions_sites
  attr(aa_masses, paste0(mod_type, "_mass")) <- mod_masses
  aa_masses <- add_aamasses_motifs(aa_masses, mod_motifs, positions_sites)
  aa_masses <- add_aamasses_neulosses(aa_masses, neulosses, mod_type)
  
  if (is.null(attr(aa_masses, "vmods"))) attr(aa_masses, "vmods") <- ""
  if (is.null(attr(aa_masses, "vmods_neuloss"))) attr(aa_masses, "vmods_neuloss") <- ""
  if (is.null(attr(aa_masses, "vmods_mass"))) attr(aa_masses, "vmods_mass") <- 0
  attr(aa_masses, "anywhere_excepts") <- anywhere_excepts
  attr(aa_masses, "nt_except") <- nt_except
  attr(aa_masses, "ct_except") <- ct_except

  ### 
  # Variable mods: need both the "original" and the "delta" forms
  # (in combinatorial some are modified and some are not) 
  # whereas fixed mods only has one form.
  # 
  # (1) 
  # fixedmods = c("Carbamidomethyl (C)"),
  # varmods = c("K8 (C-term)", "TMT6plex (N-term)"),
  # 
  # N-term      C-term      K8 (C-term)   TMT6plex (N-term) 
  # 1.007825    17.002740   8.014200      229.162932
  # 
  # (2)
  # fixedmods = c("Carbamidomethyl (C)"),
  # varmods = c("Oxidation (M)"), 
  # M           Oxidation (M) 
  # 131.040485  15.994915 
  ### 

  aa_masses
}


#' Adds fixed masses
#' 
#' @inheritParams add_var_masses
add_fixed_masses <- function (mods, aa_masses, mod_motifs = NULL) 
{
  mod_type <- "fmods"
  all_mods <- if (length(mods)) paste(mods, collapse = ", ") else ""
  
  res <- extract_umods(mods)
  mod_masses <- lapply(res, `[[`, "monomass")
  positions_sites <- lapply(res, `[[`, "position_site")
  neulosses <- lapply(res, `[[`, "nl")
  rm(list = c("res"))
  
  check_fmods_pos_site(positions_sites)
  
  for (i in seq_along(positions_sites)) {
    p <- positions_sites[[i]]
    s <- find_aa_site(p)
    aa_masses[s] <- aa_masses[s] + mod_masses[[i]]
  }

  attr(aa_masses, mod_type) <- all_mods
  attr(aa_masses, paste0(mod_type, "_ps")) <- positions_sites
  attr(aa_masses, paste0(mod_type, "_mass")) <- mod_masses
  aa_masses <- add_aamasses_motifs(aa_masses, mod_motifs, positions_sites)
  aa_masses <- add_aamasses_neulosses(aa_masses, neulosses, mod_type)
  
  if (is.null(attr(aa_masses, "fmods"))) attr(aa_masses, "fmods") <- ""
  if (is.null(attr(aa_masses, "fmods_neuloss"))) attr(aa_masses, "fmods_neuloss") <- ""
  if (is.null(attr(aa_masses, "fmods_mass"))) attr(aa_masses, "fmods_mass") <- 0
  if (is.null(attr(aa_masses, "vmods"))) attr(aa_masses, "vmods") <- ""
  if (is.null(attr(aa_masses, "vmods_neuloss"))) attr(aa_masses, "vmods_neuloss") <- ""
  if (is.null(attr(aa_masses, "vmods_ps"))) attr(aa_masses, "vmods_ps") <- ""
  if (is.null(attr(aa_masses, "vmods_mass"))) attr(aa_masses, "vmods_mass") <- 0

  aa_masses
}


#' Finds the coerced fixed sites that can be coerced back to fixed sites.
#'
#' @param positions_sites Lists of positions and sites.
#' @param fixed_sites Sites coerced from fixed to variable modifications.
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' mods <- c("TMT6plex (K)", "Carbamyl (M)", "Oxidation (M)", "Gln->pyro-Glu (N-term = Q)")
#' res <- mzion:::extract_umods(mods)
#' positions_sites <- lapply(res, `[[`, "position_site")
#' fixed_sites <- c("TMT6plex (K)" = "K", "Carbamyl (M)" = "M")
#' }
find_except_sites <- function (fixed_sites, positions_sites)
{
  fixed_mods <- names(fixed_sites)
  csites <- fixed_sites[fixed_sites %in% positions_sites]
  
  except_sites <- lapply(csites, function (csite) {
    vmods_at_csite <- names(positions_sites[positions_sites == csite])
    other_csites <- setdiff(vmods_at_csite, fixed_mods)
    if (length(other_csites)) NULL else csite
  })
  
  except_sites <- unlist(except_sites, recursive = FALSE)
  except_vmods <- fixed_mods[fixed_sites %in% except_sites]
  
  if (!is.null(except_sites)) 
    names(except_sites) <- except_vmods
  
  invisible(except_sites)
}


#' Finds the positions and sites of modifications.
#'
#' @param mods A vector of modifications, e.g., \code{c("TMT6plex (K)", "Acetyl
#'   (K)")}
find_modps <- function (mods)
{
  ans <- lapply(mods, find_unimod) 
  ps <- lapply(ans, `[[`, "position_site")
  flatten_list(ps)
}


#' Extracts Unimod results.
#' 
#' @param mods A vector of modifications. 
extract_umods <- function (mods)
{
  res <- lapply(mods, find_unimod)
  names(res) <- mods
  check_resunimod(res)
}


#' Checks the results from find_unimod
#' 
#' Shows warning if the same \code{site} with different fixedmods.
#' 
#' @param res Results from \link{find_unimod}
check_resunimod <- function (res)
{
  if (length(res)) {
    x <- res[[1]]
    
    nm_seqs <- c("title", "monomass", "position_site", "nl")
    ok <- identical(names(x), nm_seqs)
    
    if (!ok)
      stop("The structures from `find_unimod` is not in the order of: ", 
           paste(nm_seqs, collapse = ", "))
  }
  
  invisible(res)
}


#' Checks the positions_sites in fixedmods
#' 
#' @param positions_sites Lists of positions and sites.
check_fmods_pos_site <- function (positions_sites)
{
  if (length(positions_sites) > 1L) {
    dups <- purrr::reduce(positions_sites, `c`)
    dups <- dups[duplicated(dups)]

    if (length(dups)) {
      dups_in_each <- lapply(positions_sites, function (x) x == dups)
      dup_mods <- names(positions_sites[unlist(dups_in_each)])
      
      warning("Conflicts in fixed modifications: \n",
              paste(dup_mods, collapse = ", "), "\n",
              "May consider change from fixed to variable modifications(s); \n",
              "or create a new Unimod for joint modifications.")
    }
  }
}


#' Check duplicated variable terminal and anywhere modifications with the same
#' site.
#'
#' Combinations with variable sites occur on both terminal and anywhere will be
#' flagged as \code{FALSE} (for removals).
#'
#' @param mods A set of variable modifications.
#' @examples
#' mods <- c("Oxidation (M)", "Deamidated (N)", "Gln->pyro-Glu (N-term = Q)", "Deamidated (Q)")
#' mzion:::check_dup_term_any(mods)
#' 
#' mods <- c("TMT6plex (K)", "Acetyl (K)", "Carbamyl (K)")
check_dup_term_any <- function (mods)
{
  pss  <- find_modps(mods)
  bads <- grepl("[NC]-term", names(pss))
  
  if (!any(bads))
    return(TRUE)
  
  pss <- unlist(pss, recursive = FALSE)
  ts  <- unique(pss[bads]) # may be length > 1: both N-term and C-term
  
  !any(pss[!bads] == ts)
}


#' Adds the attribute of neuloss.
#' 
#' @param aa_masses A named list containing the (mono-isotopic) masses of amino
#'   acid residues.
#' @param neulosses Neutral losses
#' @param mod_type The type of modification
add_aamasses_neulosses <- function (aa_masses, neulosses, mod_type) 
{
  no_nls <- neulosses %>%
    purrr::map_lgl(~ all(.x == 0)) %>%
    all()
  
  if (no_nls) 
    return(aa_masses)
  
  attr(aa_masses, paste0(mod_type, "_neuloss")) <- neulosses
  
  aa_masses
}


#' Adds the motifs attribute to aa_masses
#'
#' @param aa_masses A named list containing the (mono-isotopic) masses of amino
#'   acid residues.
#' @param positions_sites Named list of positions (in names) and sites (in
#'   values).
#' @inheritParams matchMS
add_aamasses_motifs <- function (aa_masses, mod_motifs, positions_sites)
{
  # Need to update subset_by_prps and subset_anysite if changed from NULL to ""
  nms <- names(positions_sites)
  pmod_motifs <- mod_motifs[nms]
  
  if (!is.null(pmod_motifs)) 
    names(pmod_motifs) <- nms
  
  attr(aa_masses, "mod_motifs") <- pmod_motifs
  
  aa_masses
}


#' Parses \code{aa_masses}.
#'
#' @inheritParams add_var_masses
parse_aamasses <- function (aa_masses) 
{
  fmods_ps <- attr(aa_masses, "fmods_ps", exact = TRUE)
  vmods_ps <- attr(aa_masses, "vmods_ps", exact = TRUE)

  fmods_nl <- local({
    neulosses <- attr(aa_masses, "fmods_neuloss", exact = TRUE)

    if (all(neulosses == "")) 
      return(character())

    # add `0` if absent
    no_zero <- which(purrr::map_lgl(neulosses, ~ !any(.x == 0)))

    if (length(no_zero)) 
      neulosses[[no_zero]] <- c(0, neulosses[[no_zero]])

    # Entries with NL = 0 also kept (beneficial when expand.grid).
    # In fixedmods: `M` instead of `Oxidation (M)`.

    names(neulosses) <- fmods_ps
    neulosses
  })

  vmods_nl <- local({
    neulosses <- attr(aa_masses, "vmods_neuloss", exact = TRUE)

    if (all(neulosses == "")) 
      return(character())

    no_zero <- which(purrr::map_lgl(neulosses, ~ !any(.x == 0)))

    if (length(no_zero)) 
      neulosses[[no_zero]] <- c(0, neulosses[[no_zero]])

    neulosses
  })

  ## variable mods
  # multiple mods to [NC]-term already excluded from aa_masses

  amods <- local({
    sites <- purrr::map(vmods_ps, ~ .x[grepl("Anywhere", names(.x))])
    empties <- purrr::map_lgl(sites, purrr::is_empty)
    sites[!empties]
  })
  
  min_n_res <- local({
    anywhere_backs <- attr(aa_masses, "anywhere_backs", exact = TRUE)
    amods2 <- if (is.null(anywhere_backs)) amods else amods[!names(amods) %in% anywhere_backs]
    count_elements(unlist(amods2, recursive = FALSE, use.names = FALSE))
  })

  # Is "same Anywhere mod existed"
  is_same <- any(length(min_n_res) > 1L)

  # `TMT6plex (N-term)` and `Amidated (Protein C-term)`
  tmod <- vmods_ps[!vmods_ps %in% amods]
  tmod <- if (!length(tmod)) NULL else if (all(tmod == "")) NULL else tmod

  # variable N-term, C-term
  #
  # $`Gln->pyro-Glu (N-term = Q)`
  # Any N-term
  # "Q"
  #
  # `tmod` is a length(1) list; R `==` and `grepl` works too
  # (OK to use either tmod or tmod[[1]])

  if (length(tmod) <= 1L) {
    ntmod <- tmod %>% .[. == "N-term" || grepl("N-term", names(.))]
    ctmod <- tmod %>% .[. == "C-term" || grepl("C-term", names(.))]
  } 
  else if (length(tmod) == 2L) {
    # e.g., `TMT6plex (N-term)` + `Amidated (Protein C-term)`
    ntmod <- local({
      x <- purrr::map(tmod, ~ .x %>% .[. == "N-term" || grepl("N-term", names(.))])
      rows <- purrr::map_lgl(x, purrr::is_empty)
      x[!rows]
    })

    ctmod <- local({
      x <- purrr::map(tmod, ~ .x %>% .[. == "C-term" || grepl("C-term", names(.))])
      rows <- purrr::map_lgl(x, purrr::is_empty)
      x[!rows]
    })
  } 
  else
    stop("cannot have more than two terminal modifications.")

  ## fixed mods
  famods <- local({
    sites <- lapply(fmods_ps, function (x) x[grepl("Anywhere", names(x))])
    empties <- purrr::map_lgl(sites, purrr::is_empty)
    sites[!empties]
  })

  # length(ftmod) > 1L: `TMT6plex (N-term)` and `K8 (C-term)`
  ftmod <- fmods_ps %>% .[! . %in% famods]
  ftmod <- if (!length(ftmod)) NULL else if (all(ftmod == "")) NULL
  
  # fixed N-term, C-term
  fntmod <- ftmod %>% .[. == "N-term" || grepl("N-term", names(.))]
  fctmod <- ftmod %>% .[. == "C-term" || grepl("C-term", names(.))]

  # "amods- tmod- vnl- fnl-"
  if (!length(fmods_nl)) {
    type <- "fnl-"
    
    if (!length(vmods_nl)) {
      type <- paste("vnl-", type)
      
      if (!length(tmod)) {
        type <- paste("tmod-", type)
        
        type <- if (!length(amods)) 
          paste("amods-", type) # 1
        else 
          paste("amods+", type) # 2
      } else {
        type <- paste("tmod+", type)
        
        type <- if (!length(amods)) 
          paste("amods-", type) # 3
        else 
          paste("amods+", type) # 4
      }
    } else {
      type <- paste("vnl+", type)
      
      if (!length(tmod)) {
        type <- paste("tmod-", type)
        
        type <- if (!length(amods)) 
          paste("amods-", type) # 5
        else 
          paste("amods+", type) # 6
      } else {
        type <- paste("tmod+", type)

        type <- if (!length(amods)) 
          paste("amods-", type) # 7
        else 
          paste("amods+", type) # 8
      }
    }
  } else {
    type <- "fnl+"
    
    if (!length(vmods_nl)) {
      type <- paste("vnl-", type)
      
      if (!length(tmod)) {
        type <- paste("tmod-", type)
        
        type <- if (!length(amods)) 
          paste("amods-", type) # 1
        else 
          paste("amods+", type) # 2
      } else {
        type <- paste("tmod+", type)

        type <- if (!length(amods)) 
          paste("amods-", type) # 3
        else 
          paste("amods+", type) # 4
      }
    } else {
      type <- paste("vnl+", type)
      
      if (!length(tmod)) {
        type <- paste("tmod-", type)
        
        type <- if (!length(amods)) 
          paste("amods-", type) # 5
        else 
          paste("amods+", type) # 6
      } else {
        type <- paste("tmod+", type)

        type <- if (!length(amods)) 
          paste("amods-", type) # 7
        else 
          paste("amods+", type) # 8
      }
    }
  }

  attr(aa_masses, "type") <- type

  attr(aa_masses, "fmods_nl") <- fmods_nl
  attr(aa_masses, "famods") <- famods
  attr(aa_masses, "ftmod") <- ftmod
  attr(aa_masses, "fntmod") <- fntmod
  attr(aa_masses, "fctmod") <- fctmod

  attr(aa_masses, "vmods_nl") <- vmods_nl
  attr(aa_masses, "amods") <- amods
  attr(aa_masses, "tmod") <- tmod
  attr(aa_masses, "ntmod") <- ntmod
  attr(aa_masses, "ctmod") <- ctmod
  
  attr(aa_masses, "min_n_res") <- min_n_res
  attr(aa_masses, "is_same") <- is_same

  invisible(aa_masses)
}


#' Helper of \link{calc_pepmasses2}.
#'
#' Prior to the calculation of peptide masses; for the base with fixed
#' modification only.
#' 
#' Each entry in the outputs contains two lists: 1. terminal sequences without
#' N-term methionine; 2. all sequences without methionine clipping.
#'
#' @inheritParams calc_pepmasses2
#' @importFrom stringi stri_reverse
#' @return Two named list of "fwds" and "revs". List "fwds" contains peptide
#'   sequences split from forward fasta and "revs" from reversed fasta.
#' @examples 
#' if (FALSE) {
#'   x <- split_fastaseqs("~/mzion/dbs/fasta/uniprot/uniprot_mm_2020_11.fasta")
#' }
split_fastaseqs <- function (fasta = NULL, enzyme = "trypsin_p", 
                             custom_enzyme = c(Cterm = NULL, Nterm = NULL), 
                             acc_type = "uniprot_acc", acc_pattern = NULL, 
                             maxn_fasta_seqs = 200000L, max_miss = 2L) 
{
  message("Loading fasta databases.")

  fasta_db <- load_fasta2(fasta, acc_type, acc_pattern)

  if (length(fasta_db) > maxn_fasta_seqs) 
    stop("More than `", maxn_fasta_seqs, "` sequences in fasta files.\n",
         "  May consider a higher `maxn_fasta_seqs`.")
  
  # slower with more cores
  n_cores <- detect_cores(16L)

  cl <- parallel::makeCluster(getOption("cl.cores", n_cores))

  parallel::clusterExport(
    cl,
    c("make_fastapeps0", 
      "keep_n_misses"), 
    envir = environment(mzion::matchMS))

  # ---
  message("Splitting fasta sequences.")

  peps <- parallel::clusterApply(cl, chunksplit(fasta_db, n_cores), 
                                 make_fastapeps0, 
                                 enzyme, custom_enzyme, max_miss)
  
  parallel::stopCluster(cl)
  
  # each peps has two lists
  peps <- flatten_list(peps)

  invisible(peps)
}


#' Makes peptide sequences from FASTA databases.
#'
#' A step before concatenating peptides by the number of mis-cleavages.
#'
#' The uses of "@" tags is faster than lookahead and lookbehind
#' (https://www.r-bloggers.com/2018/04/strsplit-but-keeping-the-delimiter/).
#'
#' @param fasta_db Fasta database(s).
#' @inheritParams calc_pepmasses2
make_fastapeps0 <- function (fasta_db, enzyme = "trypsin_p", custom_enzyme = NULL, 
                             max_miss = 2L) 
{
  inds_m <- grep("^M", fasta_db)

  if (is.null(enzyme)) {
    # already checked custom_enzyme names in matchMS
    if ((len_enz <- length(custom_enzyme)) == 2L) {
      patc <- custom_enzyme[["Cterm"]]
      patn <- custom_enzyme[["Nterm"]]
    }
    else if (len_enz == 1L) {
      if ((tm_enz <- names(custom_enzyme)) == "Cterm") {
        patc <- custom_enzyme[["Cterm"]]
        patn <- NULL
      }
      else if (tm_enz == "Nterm") {
        patc <- NULL
        patn <- custom_enzyme[["Nterm"]] 
      }
      else {
        stop("Custom enzyme terminal is not `Cterm` or `Nterm`.")
      }
    }

    if (!is.null(patc)) {
      if (grepl("\\^", patc)) {
        fasta_db <- lapply(fasta_db, function (x) 
          .Internal(gsub(patc, paste0("\\1", "@", "\\2"), x, 
                         ignore.case = FALSE, perl = FALSE, 
                         fixed = FALSE, useBytes = FALSE)))
      }
      else {
        fasta_db <- lapply(fasta_db, function (x) 
          .Internal(gsub(patc, paste0("\\1", "@"), x, 
                         ignore.case = FALSE, perl = FALSE, 
                         fixed = FALSE, useBytes = FALSE)))
      }
    }
    
    if (!is.null(patn)) {
      if (grepl("\\^", patn)) {
        fasta_db <- lapply(fasta_db, function (x) 
          .Internal(gsub(patn, paste0("\\1", "@", "\\2"), x, 
                         ignore.case = FALSE, perl = FALSE, 
                         fixed = FALSE, useBytes = FALSE)))
      }
      else {
        fasta_db <- lapply(fasta_db, function (x) 
          .Internal(gsub(patn, paste0("@", "\\1"), x, 
                         ignore.case = FALSE, perl = FALSE, 
                         fixed = FALSE, useBytes = FALSE)))
      }
    }
    
    fasta_db <- lapply(fasta_db, function (x) gsub("@+", "@", x))
    
    fasta_db <- lapply(fasta_db, function (x) paste0("-", x, "-"))
  }
  else if (enzyme == "trypsin_p" || enzyme == "semitrypsin_p") {
    fasta_db <- lapply(fasta_db, function (x) 
      paste0("-", 
             .Internal(gsub("([KR]{1})", paste0("\\1", "@"), x, 
                            ignore.case = FALSE, perl = FALSE, 
                            fixed = FALSE, useBytes = FALSE)), 
             "-"))
  }
  else if (enzyme == "trypsin" || enzyme == "semitrypsin") {
    fasta_db <- lapply(fasta_db, function (x) 
      paste0("-", 
             .Internal(gsub("([KR]{1})([^P]{1})", paste0("\\1", "@", "\\2"), x, 
                            ignore.case = FALSE, perl = FALSE, 
                            fixed = FALSE, useBytes = FALSE)), 
             "-"))
  }
  else if (enzyme == "lysc" || enzyme == "semilysc") {
    fasta_db <- lapply(fasta_db, function (x) 
      paste0("-", 
             .Internal(gsub("([K]{1})", paste0("\\1", "@"), x, 
                            ignore.case = FALSE, perl = FALSE, 
                            fixed = FALSE, useBytes = FALSE)), 
             "-"))
  }
  else if (enzyme == "lysn" || enzyme == "semilysn") {
    fasta_db <- lapply(fasta_db, function (x) 
      paste0("-", 
             .Internal(gsub("([K]{1})", paste0("@", "\\1"), x, 
                            ignore.case = FALSE, perl = FALSE, 
                            fixed = FALSE, useBytes = FALSE)), 
             "-"))
  }
  else if (enzyme == "argc" || enzyme == "semiargc") {
    fasta_db <- lapply(fasta_db, function (x) 
      paste0("-", 
             .Internal(gsub("([R]{1})", paste0("\\1", "@"), x, 
                            ignore.case = FALSE, perl = FALSE, 
                            fixed = FALSE, useBytes = FALSE)), 
             "-"))
  }
  else if (enzyme == "lysc_p" || enzyme == "semilysc_p") {
    fasta_db <- lapply(fasta_db, function (x) 
      paste0("-", 
             .Internal(gsub("([K]{1})([^P]{1})", paste0("\\1", "@", "\\2"), x, 
                            ignore.case = FALSE, perl = FALSE, 
                            fixed = FALSE, useBytes = FALSE)), 
             "-"))
  }
  else if (enzyme == "chymotrypsin" || enzyme == "semichymotrypsin") {
    fasta_db <- lapply(fasta_db, function (x) 
      paste0("-", 
             .Internal(gsub("([FWY]{1})", paste0("\\1", "@"), x, 
                            ignore.case = FALSE, perl = FALSE, 
                            fixed = FALSE, useBytes = FALSE)), 
             "-"))
  }
  else if (enzyme == "gluc" || enzyme == "semigluc") {
    fasta_db <- lapply(fasta_db, function (x) 
      paste0("-", 
             .Internal(gsub("([E]{1})", paste0("\\1", "@"), x, 
                            ignore.case = FALSE, perl = FALSE, 
                            fixed = FALSE, useBytes = FALSE)), 
             "-"))
  }
  else if (enzyme == "glun" || enzyme == "semiglun") {
    fasta_db <- lapply(fasta_db, function (x) 
      paste0("-", 
             .Internal(gsub("([E]{1})", paste0("@", "\\1"), x, 
                            ignore.case = FALSE, perl = FALSE, 
                            fixed = FALSE, useBytes = FALSE)), 
             "-"))
  }
  else if (enzyme == "aspc" || enzyme == "semiaspc") {
    fasta_db <- lapply(fasta_db, function (x) 
      paste0("-", 
             .Internal(gsub("([D]{1})", paste0("\\1", "@"), x, 
                            ignore.case = FALSE, perl = FALSE, 
                            fixed = FALSE, useBytes = FALSE)), 
             "-"))
  }
  else if (enzyme == "aspn" || enzyme == "semiaspn") {
    fasta_db <- lapply(fasta_db, function (x) 
      paste0("-", 
             .Internal(gsub("([D]{1})", paste0("@", "\\1"), x, 
                            ignore.case = FALSE, perl = FALSE, 
                            fixed = FALSE, useBytes = FALSE)), 
             "-"))
  }
  else if (enzyme == "nodigest") {
    fasta_db <- lapply(fasta_db, function (x) paste0("-", x, "-"))
  }
  else {
    stop("Unknown enzyme.")
  }

  fasta_dbm <- lapply(fasta_db[inds_m], function (x) gsub("^-M", "-", x))
  
  # --- with protein N-term (initiator) methionine ---
  peps <- lapply(fasta_db, function (x) {
    s <- .Internal(strsplit(x, "@", fixed = FALSE, perl = FALSE, useBytes = FALSE))
    s <- .Internal(unlist(s, recursive = FALSE, use.names = FALSE))
  })
  
  # --- without protein N-term (initiator) methionine ---
  peps_m <- lapply(fasta_dbm, function (x) {
    s <- .Internal(strsplit(x, "@", fixed = FALSE, perl = FALSE, useBytes = FALSE))
    s <- .Internal(unlist(s, recursive = FALSE, use.names = FALSE))
    keep_n_misses(s, max_miss)
  })
  
  # Note: NA sequences -> NULL during mass calculations
  # (USE.NAMEs as they are prot_acc)
  if (length(inds_m)) {
    peps[inds_m] <- mapply(list, peps_m, peps[inds_m], SIMPLIFY = FALSE)
    peps[-inds_m] <- lapply(peps[-inds_m], function (x) list(NA, x))
  }
  else {
    peps <- lapply(peps, function (x) list(NA, x))
  }

  invisible(peps)
}


#' Splits fasta sequences by proteins.
#' 
#' For \code{no enzyme} searches.
#' 
#' @param aa_masses A lookup table of the masses of amino-acid residues.
#' @param ftmass The sum of masses of \code{fixed} N-term and C-term
#'   modifications.
#' @inheritParams calc_pepmasses2
split_fastaseqs_noenz <- function (fasta = NULL, acc_type = "uniprot_acc", 
                                   acc_pattern = NULL, maxn_fasta_seqs = 200000L, 
                                   min_len = 7L, max_len = 40L, aa_masses = NULL, 
                                   ftmass = 18.010565) 
{
  message("Loading fasta databases.")
  
  fasta_db <- load_fasta2(fasta, acc_type, acc_pattern)
  
  if (length(fasta_db) > maxn_fasta_seqs) 
    stop("More than `", maxn_fasta_seqs, "` sequences in fasta files.\n",
         "  Consider a higher `maxn_fasta_seqs`.")
  
  message("Splitting fasta sequences.")
  
  # n_cores <= 64L, n_chunks = n_cores^2, LB = F: time = 15'22
  # n_cores <= 16L, n_chunks = n_cores^2, LB = F: time = 16'33
  # n_cores <= 64L, n_chunks = n_cores^2, LB = T: time = 15'08
  # n_cores <= 64L, n_chunks = n_cores  , LB = T: time = 16'49

  n_cores <- detect_cores(64L)
  
  cl <- parallel::makeCluster(getOption("cl.cores", n_cores))
  
  parallel::clusterExport(
    cl,
    c("make_noenzpeps", 
      "mmake_noenzpeps", 
      "hmake_noenzpeps", 
      "ms1masses_bare_noenz"), 
    envir = environment(mzion::matchMS))
  
  peps <- parallel::clusterApply(cl, chunksplit(fasta_db, n_cores), 
                                 mmake_noenzpeps, 
                                 min_len = min_len, 
                                 max_len = max_len, 
                                 aa_masses = aa_masses, 
                                 ftmass = ftmass) 
  
  parallel::stopCluster(cl)

  peps <- flatten_list(peps)
  
  message("Completed at: ", Sys.time())
  
  invisible(peps)
}


#' Helper: multiple applications of \link{make_noenzpeps}.
#' 
#' For \code{no enzyme} searches.
#' 
#' @param fasta_db Fasta database(s).
#' @param aa_masses A lookup table of the masses of amino-acid residues.
#' @param ftmass The sum of masses of \code{fixed} N-term and C-term
#'   modifications.
#' @inheritParams calc_pepmasses2
mmake_noenzpeps <- function (fasta_db = NULL, min_len = 7L, max_len = 40L, 
                             aa_masses = NULL, ftmass = 18.010565) 
{
  lapply(fasta_db, make_noenzpeps, min_len = min_len, max_len = max_len, 
         aa_masses = aa_masses, ftmass = ftmass)
}


#' Makes peptides and masses for a protein.
#'
#' For \code{no enzyme} searches.
#'
#' @param prot A FASTA entry of protein.
#' @param aa_masses A lookup table of the masses of amino-acid residues.
#' @param ftmass The sum of masses of \code{fixed} N-term and C-term
#'   modifications.
#' @inheritParams calc_pepmasses2
#' @examples 
#' \donttest{
#' library(mzion)
#' 
#' prot <- paste0(
#'   "MSSKQHCVKLNDGHLIPALGFGTYKPKEVPKSKSLEAACLA", 
#'   "LDVGYRHVDTAYAYQVEEEIGQAIQSKIKAGVVKREDLFIT", 
#'   "TKLWCTCFRPELVKPALEKSLKKLQLDYVDLYIMHYPVPMK", 
#'   "SGDNDFPVNEQGKSLLDTVDFCDTWERLEECKDAGLVKSIG", 
#'   "VSNFNHRQLERILNKPGLKYKPVCNQVECHLYLNQRKLLDY",
#'   "CESKDIVLVAYGALGTQRYKEWVDQNSPVLLNDPVLCDVAK", 
#'   "KNKRSPALIALRYLIQRGIVPLAQSFKENEMRENLQVFGFQ", 
#'   "LSPEDMKTLDGLNKNFRYLPAEFLVDHPEYPFVEEY")
#' 
#' fixedmods = c("TMT6plex (N-term)", "TMT6plex (K)", 
#'               "Carbamidomethyl (C)")
#' 
#' varmods = c("Acetyl (Protein N-term)", "Oxidation (M)", 
#'             "Deamidated (N)","Gln->pyro-Glu (N-term = Q)")
#' 
#' aa_masses_all <- calc_aamasses(fixedmods = fixedmods, varmods = varmods)
#' aa_masses <- aa_masses_all[[1]]
#' 
#' ans <- mzion:::make_noenzpeps(prot, 7, 40, aa_masses)
#' 
#' # short FASTA (both N-term and C-term on a sequence)
#' prot <- substring(prot, 1, 10)
#' ans <- mzion:::make_noenzpeps(prot, 7, 40, aa_masses)
#' }
make_noenzpeps <- function (prot = NULL, min_len = 7L, max_len = 40L, 
                            aa_masses = NULL, ftmass = 18.010565) 
{
  len <- nchar(prot)
  
  if (len < min_len)
    return(NULL)
  
  if (len == min_len)
    return(prot[[1]])
  
  max_len <- min(max_len, len)
  starts <- 1:(len - min_len + 1L)
  
  # (1) Finds sub-sequence with a `start` value
  # (2) Calculates masses
  # (3) Adds C-term tag "-" after (2); no effect on masses
  ans <- lapply(starts, hmake_noenzpeps, prot, min_len, max_len, len, 
                aa_masses, ftmass)

  # N-term peptides
  nms_1 <- names(ans[[1]])
  names(ans[[1]]) <- paste0("-", nms_1)

  if (grepl("^M", nms_1[[1]]))
    names(ans[[2]]) <- paste0("-", names(ans[[2]]))
  
  .Internal(unlist(ans, recursive = FALSE, use.names = TRUE))
}


#' Helper of \link{make_noenzpeps} (one start positions).
#'
#' For \code{no enzyme} searches.
#' 
#' C-term tagged with "-" after the mass calculations (but not yet N-term).
#'
#' @param prot A FASTA entry of protein.
#' @param start The staring position of an amino-acid in a \code{prot}.
#' @param len The number of amino-acid residues in a \code{prot}.
#' @param aa_masses A lookup table of the masses of amino-acid residues.
#' @param ftmass The sum of masses of \code{fixed} N-term and C-term
#'   modifications.
#' @inheritParams calc_pepmasses2
#' 
#' @examples 
#' \donttest{
#' library(mzion)
#' 
#' fixedmods <- c("TMT6plex (N-term)", "TMT6plex (K)", 
#'                "Carbamidomethyl (C)")
#' 
#' varmods <- c("Acetyl (Protein N-term)", "Oxidation (M)", 
#'              "Deamidated (N)","Gln->pyro-Glu (N-term = Q)")
#' 
#' aa_masses_all <- calc_aamasses(fixedmods = fixedmods, varmods = varmods)
#' aa_masses <- aa_masses_all[[1]]
#' 
#' aas <- LETTERS[LETTERS %in% names(aa_masses)]
#' prot <- paste0(aas, collapse = "")
#' len <- nchar(prot)
#' masses <- mzion:::hmake_noenzpeps(1L, prot, 7L, 40L, len, aa_masses)
#' }
hmake_noenzpeps <- function (start = 1L, prot = NULL, min_len = 7L, max_len = 40L, 
                             len = NULL, aa_masses = NULL, ftmass = 18.010565) 
{
  end_fi <- min_len + start  - 1L
  end_la <- min(max_len + start - 1L, len)
  ends <- end_fi:end_la
  
  peps <- .Internal(substr(rep_len(prot, length.out = length(ends)), start, ends))
  masses <- ms1masses_bare_noenz(peps, aa_masses, ftmass)
  
  if (end_la == len) {
    len_a <- length(peps)
    names(masses)[len_a] <- 
      .Internal(paste0(list(peps[len_a], "-"), collapse = NULL, recycle0 = FALSE))
  }
  
  masses
}


#' Calculates masses of peptides.
#' 
#' For no enzyme workflow.
#' 
#' @param x A vector of peptide sequences.
#' @param aa_masses A lookup table of the masses of amino-acid residues.
#' @param ftmass The sum of masses of \code{fixed} N-term and C-term
#'   modifications.
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' fixedmods <- c("TMT6plex (N-term)", "TMT6plex (K)", 
#'                "Carbamidomethyl (C)")
#' 
#' varmods <- c("Acetyl (Protein N-term)", "Oxidation (M)", 
#'              "Deamidated (N)","Gln->pyro-Glu (N-term = Q)")
#' 
#' aa_masses_all <- calc_aamasses(fixedmods = fixedmods, varmods = varmods)
#' aa_masses <- aa_masses_all[[1]]
#' 
#' x <- c("MSSKQHC", "MSSKQHCV", "MSSKQHCVK", "MSSKQHCVKL")
#' masses1 <- mzion:::ms1masses_bare_noenz(x, aa_masses)
#' 
#' ## input peptides should contain neither N- or C-term "-" tag
#' # y <- c("MSSKQHC", "MSSKQHCV", "MSSKQHCVK", "MSSKQHCVKL-")
#' # masses2 <- mzion:::ms1masses_bare_noenz(y, aa_masses)
#' # stopifnot(identical(unname(masses1), unname(masses2)))
#' }
ms1masses_bare_noenz <- function (x, aa_masses, ftmass = 18.010565) 
{
  len <- length(x)
  aas <- .Internal(strsplit(x[len], "", fixed = FALSE, perl = FALSE, useBytes = FALSE))
  aas <- .Internal(unlist(aas, recursive = FALSE, use.names = FALSE))
  len_a <- length(aas)
  
  masses <- cumsum(aa_masses[aas])
  len_m <- length(masses)
  masses <- masses[(len_m - len + 1L):len_m] + ftmass
  names(masses) <- x
  
  masses
}


#' Finds mis-cleavages in a vector.
#'
#' A convenience utility may be used to extract the first \eqn{n+1} peptides
#' from 0 to n mis-cleavages. It also assumes that the data were already sorted
#' in a desirable way.
#'
#' @param x A vector of data.
#' @param n Integer. The number of mis-cleavages.
keep_n_misses <- function (x, n) 
{
  len <- length(x)
  
  if (n < 0L) 
    stop("`n` cannot be nagative integers: ", n)
  
  if (!len) 
    stop("Length of `x` cannot be zero.")
  
  x[1:min(n + 1, len)]
}


#' Excludes mis-cleavages in a vector.
#'
#' @inheritParams keep_n_misses
#' @seealso keep_n_misses
exclude_n_misses <- function (x, n) 
{
  len <- length(x)
  
  if (n < 0L) 
    stop("`n` cannot be nagative integers: ", n)
  
  if (!len) 
    stop("Length of `x` cannot be zero.")
  
  x[-(1:min(n + 1, len))]
}


#' Excludes a character in string counting
#'
#' @param x A character string
#' @param char A character to be excluded for counting.
#' @importFrom stringi stri_length stri_count_fixed
str_exclude_count <- function (x, char = "-") 
{
  stringi::stri_length(x) - stringi::stri_count_fixed(x, char)
}


#' Removes a starting character from the first \code{n} entries.
#'
#' @param x A list of character strings. Peptide sequences in names and masses
#'   in values.
#' @param char A starting character to be removed.
#' @param n The number of beginning entries to be considered.Should be \code{n =
#'   (max_miss + 1L) * 2L}.
#' @inheritParams matchMS
rm_char_in_nfirst <- function (x, char = "-", n = 6L, max_len = 40L) 
{
  nms <- names(x)
  len <- length(nms)
  n <- min(len, n)
  seqs <- seq_len(n)
  
  # the possible space
  nms2 <- nms[seqs]
  idxes <- which(stringi::stri_startswith_fixed(nms2, char))
  
  # the exact space
  nms3 <- nms2[idxes]
  nms3 <- substr(nms3, 2L, max_len)
  
  # update the possible space
  nms2[idxes] <- nms3
  
  # update the full space
  nms[seqs] <- nms2
  names(x) <- nms
  
  attr(x, "pnt_idxes") <- idxes
  
  x
}


#' Removes a trailing character from the last \code{n} entries.
#' 
#' The default value of \code{n} is for full-enzymatic peptides.
#' 
#' @param char A trailing character to be removed.
#' @inheritParams rm_char_in_nfirst
rm_char_in_nlast <- function (x, char = "-", n = 6L) 
{
  nms <- names(x)
  len <- length(nms)
  n <- min(len, n)
  seqs <- (len - n + 1L):len
  
  # possible space
  nms2 <- nms[seqs]
  idxes <- which(stringi::stri_endswith_fixed(nms2, char))
  
  # exact space
  nms3 <- nms2[idxes]
  stops <- nchar(nms3) - 1L
  nms3 <- substr(nms3, 1L, stops)
  
  # update possible space
  nms2[idxes] <- nms3
  
  # update full space
  nms[seqs] <- nms2
  names(x) <- nms
  
  attr(x, "pct_idxes") <- len - length(seqs) + idxes
  
  x
}


#' Adjusts the masses for the all-fixed mode
#' 
#' The \code{fwd_peps_1} was at first based on the coerced aa_masses_0;
#'
#' @param fwd_peps_1 The first list of forward peptides with masses.
#' @param aa_masses_0 The amino-acid masses look-up table with the coercion of
#'   fixed to variable modification.
#' @param aa_masses_1 The amino-acid masses look-up table without the coercion
#'   of fixed to variable modification.
#' @inheritParams matchMS
adj_base_masses <- function (fwd_peps_1, aa_masses_0, aa_masses_1, 
                             min_mass = 200L, max_mass = 4500L, digits = 4L)
{
  nt_coerce_site <- attr(aa_masses_0, "nt_coerce_site", exact = TRUE)
  ct_coerce_site <- attr(aa_masses_0, "ct_coerce_site", exact = TRUE)
  anywhere_coerce_sites <- attr(aa_masses_0, "anywhere_coerce_sites", exact = TRUE)
  
  if (length(nt_coerce_site) > 1L)
    stop("Cannot have more than one N-term site coercion.")
  
  if (length(ct_coerce_site) > 1L)
    stop("Cannot have more than one C-term site coercion.")
  
  ok <- is.null(nt_coerce_site) && 
    is.null(ct_coerce_site) && 
    is.null(anywhere_coerce_sites)
  
  if (ok)
    return(fwd_peps_1[fwd_peps_1 <= max_mass])

  delta_nt <- if (length(nt_coerce_site))
    aa_masses_1[[nt_coerce_site]] - aa_masses_0[[nt_coerce_site]]
  else
    0
  
  delta_ct <- if (length(ct_coerce_site))
    aa_masses_1[[ct_coerce_site]] - aa_masses_0[[ct_coerce_site]]
  else 
    0
  
  len_a <- length(anywhere_coerce_sites)

  if (len_a) {
    ds <- lapply(anywhere_coerce_sites, function (s) {
      aa_masses_1[s] - aa_masses_0[s]
    })
    
    ns <- lapply(anywhere_coerce_sites, function (s) {
      .Call(stringi:::C_stri_count_fixed, str = names(fwd_peps_1), 
            pattern = s, opts_fixed = NULL)
    })
    
    dns <- mapply(function (d, n) {
      d * n
    }, ds, ns, SIMPLIFY = FALSE, USE.NAMES = FALSE)
    
    delta_anywhere <- dns[[1]]
    
    if (len_a > 1L)
      for (i in 2:len_a) delta_anywhere <- delta_anywhere + dns[[i]]
  }
  else {
    delta_anywhere <- 0
  }

  delta <- delta_nt + delta_ct + delta_anywhere
  fwd_peps_1 <- fwd_peps_1 + delta
  fwd_peps_1 <- fwd_peps_1[fwd_peps_1 >= min_mass & fwd_peps_1 <= max_mass]
  
  round(fwd_peps_1, digits = digits)
}


#' Adjusts the masses for \code{Anywhere} coerced sites
#' 
#' @param peps The list of forward peptides with masses.
#' @param aa_masses A (coerced) amino-acid masses look-up table.
adj_anywhere_masses <- function (peps, aa_masses)
{
  anywhere_excepts <- attr(aa_masses, "anywhere_excepts", exact = TRUE)
  len_a <- length(anywhere_excepts)
  
  if (!len_a)
    return(peps)
  
  ds <- aa_masses[names(anywhere_excepts)]
  
  ns <- lapply(anywhere_excepts, function (s) {
    .Call(stringi:::C_stri_count_fixed, str = names(peps), 
          pattern = s, opts_fixed = NULL)
  })
  
  dns <- mapply(function (d, n) {
    d * n
  }, ds, ns, SIMPLIFY = FALSE, USE.NAMES = FALSE)
  
  for (i in seq_along(dns))
    peps <- peps + dns[[i]]

  invisible(peps)
}


#' Helper in calculating peptide masses.
#'
#' (2) "amods- tmod+ vnl- fnl-".
#' 
#' No needs of checking \code{is_empty(ntmod) && is_empty(ctmod)}. 
#' \code{aa_masses} is one of \code{aa_masses_ms1} (coerced). 
#' 
#' @param peps A list of peptide sequences.
#' @inheritParams add_var_masses
#' @inheritParams distri_peps
#' @inheritParams matchMS
add_term_mass <- function (peps, aa_masses, min_mass = 200L, max_mass = 4500L) 
{
  type <- attr(aa_masses, "type", exact = TRUE)
  
  if (!grepl("tmod+", type, fixed = TRUE))
    return(peps)
  
  ntmod <- attr(aa_masses, "ntmod", exact = TRUE)
  ctmod <- attr(aa_masses, "ctmod", exact = TRUE)
  
  delta <- if (length(ntmod) && length(ctmod)) 
    aa_masses[names(ntmod)] + aa_masses[names(ctmod)]
  else if (length(ntmod)) 
    aa_masses[names(ntmod)]
  else if (length(ctmod)) 
    aa_masses[names(ctmod)]

  ans <- peps + delta
  
  ans[ans >= min_mass & ans <= max_mass]
}


#' Calculates mono-isotopic masses of peptide sequences.
#' 
#' Also subset by min_len and max_len.
#'
#' @param seqs Sequences of peptides from FASTAs by protein accessions. Each
#'   list contains two lists of sequences: (1) without and (2) with N-terminal
#'   methionine.
#' @param ftmass The sum of masses of \code{fixed} N-term and C-term
#'   modifications.
#' @inheritParams calc_pepmasses2
#' @inheritParams add_var_masses
#' @inheritParams distri_fpeps
ms1masses_bare <- function (seqs = NULL, aa_masses = NULL, ftmass = NULL,
                            max_miss = 2L, min_len = 7L, max_len = 40L,
                            maxn_vmods_per_pep = 5L, maxn_sites_per_vmod = 3L,
                            is_fixed_protnt = FALSE, is_fixed_protct = FALSE) 
{
  # (1) before rolling sum (not yet terminal H2O)
  # (1.1) without N-term methionine
  data_1 <- lapply(seqs, `[[`, 1)
  data_1 <- ms1masses_noterm(data_1, aa_masses = aa_masses,
                             maxn_vmods_per_pep = maxn_vmods_per_pep,
                             maxn_sites_per_vmod = maxn_sites_per_vmod)
  data_1 <- attr(data_1, "data")

  # (1.2) with N-term methionine
  data_2 <- lapply(seqs, `[[`, 2)
  data_2 <- ms1masses_noterm(data_2, aa_masses = aa_masses,
                             maxn_vmods_per_pep = maxn_vmods_per_pep,
                             maxn_sites_per_vmod = maxn_sites_per_vmod)
  data_2 <- attr(data_2, "data")

  # (2) rolling sum (not yet terminal masses, e.g, H2O)
  n_cores <- detect_cores(64L)
  
  cl <- parallel::makeCluster(getOption("cl.cores", n_cores))

  parallel::clusterExport(cl, c("roll_sum", "accumulate_char"), 
                          envir = environment(mzion::matchMS))

  ms_1 <- parallel::clusterApply(
    cl = cl, 
    x = chunksplit(data_1, n_cores, "list"), 
    fun = lapply, 
    FUN = "roll_sum", 
    n = max_miss, 
    include_cts = FALSE
  ) 
  
  ms_1 <- flatten_list(ms_1)

  if (is_fixed_protnt) {
    ms_2 <- parallel::clusterApply(
      cl = cl, 
      x = chunksplit(data_2, n_cores, "list"), 
      fun = lapply, 
      FUN = "roll_sum", 
      n = max_miss, 
      include_cts = FALSE
    ) 
    
    ms_2 <- flatten_list(ms_2)
  } 
  else {
    ms_2 <- parallel::clusterApply(
      cl = cl, 
      x = chunksplit(data_2, n_cores, "list"), 
      fun = lapply, 
      FUN = "roll_sum", 
      n = max_miss, 
      include_cts = TRUE
    ) 
    
    ms_2 <- flatten_list(ms_2)
  }
  
  parallel::stopCluster(cl)

  # (3) putting together (+ terminal masses)
  # (USE.NAMES of prot_acc)
  ms <- mapply(`c`, ms_1, ms_2, SIMPLIFY = FALSE, USE.NAMES = TRUE)

  if (min_len > 1L && !is.infinite(max_len)) {
    ms <- lapply(ms, function (x) {
      cts <- str_exclude_count(names(x), "-")
      x[cts >= min_len & cts <= max_len]
    })
  }

  # "HD101_HUMAN" etc. has no tryptic peptides
  lens <- unlist(lapply(ms, length), recursive = FALSE, use.names = FALSE)

  # adding H2O or fixed N/C-term masses
  ms <- ms[lens > 0L]
  ms <- lapply(ms, function (x) x[!duplicated.default(names(x))] + ftmass)

  invisible(ms)
}


#' Adds Carbon-13 masses.
#' 
#' Not currently used.
#' 
#' @param peps A named vector of peptide sequences. Sequences in names and
#'   masses in values.
#' @inheritParams matchMS
add_ms1_13c <- function (peps, n_13c = 0L, max_mass = 4500L) 
{
  len <- length(n_13c)
  
  if (!len)
    return(peps)
  
  if (len == 1L && n_13c == 0L)
    return(peps)

  mass_13c <- 1.00335483
  ns <- if (len == 1L) if (n_13c < 0L) n_13c:0L else 0:n_13c else n_13c
  len2 <- length(ns)
  out <- vector("list", len2)
  
  for (i in 1:len2) {
    ni <- ns[[i]]
    out[[i]] <- if (ni == 0L) peps else peps + mass_13c * ni
  }
  
  out <- .Internal(unlist(out, recursive = FALSE, use.names = TRUE))
  
  out[out <= max_mass]
}


#' Adds offsets of MS1 masses.
#' 
#' Not currently used.
#' 
#' @param peps A named vector of peptide sequences. Sequences in names and
#'   masses in values.
#' @param masses The masses of notches.
#' @inheritParams matchMS
add_ms1_notches <- function (peps, masses = 0, max_mass = 4500L) 
{
  if (!length(masses))
    return(peps)
  
  masses <- c(0, masses[abs(masses) > 1e-4])

  if ((len <- length(masses)) == 1L)
    return(peps)
  
  out <- vector("list", len)
  out[[1]] <- peps
  
  for (i in 2:len)
    out[[i]] <- peps + masses[[i]]

  out <- .Internal(unlist(out, recursive = FALSE, use.names = TRUE))
  
  out[out <= max_mass]
}


#' Helper of \link{ms1masses_bare}.
#'
#' For either forward or reversed sequences.
#' 
#' @param aa_seqs Character string; a vector of peptide sequences with
#'   one-letter representation of amino acids.
#' @inheritParams matchMS
#' @inheritParams add_var_masses
#' @inheritParams distri_peps
ms1masses_noterm <- function (aa_seqs, aa_masses, maxn_vmods_per_pep = 5L,
                              maxn_sites_per_vmod = 3L) 
{
  options(digits = 9L)

  n_cores <- detect_cores(16L)

  aa_seqs <- suppressWarnings(split(aa_seqs, seq_len(n_cores)))

  cl <- parallel::makeCluster(getOption("cl.cores", n_cores))

  parallel::clusterExport(
    cl,
    c("calcms1mass_noterm", 
      "calcms1mass_noterm_byprot", 
      "calcms1mass_noterm_bypep"), 
    envir = environment(mzion::matchMS))

  out <- parallel::clusterApply(cl, aa_seqs, calcms1mass_noterm,
                                aa_masses = aa_masses,
                                maxn_vmods_per_pep = maxn_vmods_per_pep,
                                maxn_sites_per_vmod = maxn_sites_per_vmod) 
  
  parallel::stopCluster(cl)
  
  out <- flatten_list(out)

  attr(aa_masses, "data") <- out

  invisible(aa_masses)
}


#' Helper function for parallel calculations peptide masses by proteins.
#'
#' For each split of multiple proteins; no terminal masses.
#'
#' @inheritParams ms1masses_noterm
calcms1mass_noterm <- function (aa_seqs, aa_masses, maxn_vmods_per_pep = 5L, 
                                maxn_sites_per_vmod = 3L) 
{
  lapply(aa_seqs, function (x) 
    calcms1mass_noterm_byprot(prot_peps = x,
                              aa_masses = aa_masses,
                              maxn_vmods_per_pep = maxn_vmods_per_pep,
                              maxn_sites_per_vmod = maxn_sites_per_vmod))
}


#' Helper of \link{calcms1mass_noterm}.
#'
#' For single protein.
#'
#' @param prot_peps Lists of peptides under a proteins.
#' @inheritParams ms1masses_noterm
calcms1mass_noterm_byprot <- function (prot_peps, aa_masses, 
                                       maxn_vmods_per_pep = 5L,
                                       maxn_sites_per_vmod = 3L) 
{
  # by peptides
  ans <- lapply(prot_peps, calcms1mass_noterm_bypep,
                aa_masses = aa_masses,
                maxn_vmods_per_pep = maxn_vmods_per_pep,
                maxn_sites_per_vmod = maxn_sites_per_vmod)
  
  .Internal(unlist(ans, recursive = FALSE, use.names = TRUE))
}


#' Helper of \link{calcms1mass_noterm_byprot}.
#'
#' For single protein.
#'
#' @param aa_seq Character string; a peptide sequence with one-letter
#'   representation of amino acids.
#' @inheritParams ms1masses_noterm
#' @importFrom stringr str_split
calcms1mass_noterm_bypep <- function (aa_seq, aa_masses, maxn_vmods_per_pep = 5L,
                                      maxn_sites_per_vmod = 3L) 
{
  if (is.na(aa_seq))
    return(NULL)
  
  aas <- .Internal(strsplit(aa_seq, "", fixed = TRUE, perl = FALSE, 
                            useBytes = FALSE))
  aas <- .Internal(unlist(aas, recursive = FALSE, use.names = FALSE))

  aas <- aa_masses[aas]
  aas <- sum(aas)
  names(aas) <- aa_seq

  invisible(aas)
}


#' Distributes peptides by variable modifications.
#'
#' @param prps Lists of peptide sequences with a one-letter representation of
#'   amino acid residues. Each list is named by protein accession.
#' @param aa_masses_all All the amino acid look-up tables.
#' @param motifs_all Lists of motifs of modifications.
#' @inheritParams calc_pepmasses2
#' @param enzyme A character string of enzyme. The information is used for
#'   faster replacement of "-" in peptide sequences from protein C-terminals.
distri_peps <- function (prps, aa_masses_all, motifs_all, max_miss = 2L, 
                         max_len = 40L, enzyme = "trypsin_p") 
{
  # proteins without applicable peptide sequences
  # bads <- lapply(prps, is.null)
  # bads <- .Internal(unlist(bads, use.names = FALSE, recursive = FALSE))
  # prps <- prps[!bads]
  # rm(list = "bads")
  
  nms <- lapply(prps, names)
  
  out <- mapply(function (aa_masses, motifs) {
    nms_sub <- subpeps_by_vmods(aa_masses, nms, motifs = motifs)
    
    # USE.NAMEs of prot_acc
    idxes <- mapply(fastmatch::fmatch, nms_sub, nms, 
                    SIMPLIFY = FALSE, USE.NAMES = TRUE)
    
    mapply(function (x, y) x[y], prps, idxes, 
           SIMPLIFY = FALSE, USE.NAMES = TRUE)
  }, aa_masses_all, motifs_all, SIMPLIFY = FALSE, USE.NAMES = FALSE)
  
  # semi enzymes: don't know the maximum number of 
  # C-term peptides that can end with "-"
  # (N-term remains the same)
  
  if (is.null(enzyme)) {
    n1 <- (max_miss + 1L) * 2L
    n2 <- ct_counts(max_miss)
  }
  else {
    n1 <- if (enzyme == "noenzyme")
      Inf
    else 
      (max_miss + 1L) * 2L
    
    n2 <- if (grepl("^semi", enzyme) || enzyme == "noenzyme")
      Inf
    else
      ct_counts(max_miss)
  }

  # ZN207_HUMAN: MGRKKKK (no N-term pep_seq at 2 misses and min_len >= 7L)
  
  out <- lapply(out, function(xs) {
    len <- .Internal(unlist(lapply(xs, length), recursive = FALSE, use.names = FALSE))
    xs <- xs[len > 0L]
    xs <- lapply(xs, rm_char_in_nfirst, char = "-", n = n1, max_len = max_len)
    xs <- lapply(xs, rm_char_in_nlast, char = "-", n = n2)
  })
}


#' Counts the number of trailing residues from C-term for the replacment of "-".
#'
#' For full-enzymes: n(i+1) = n(i) + (i+1). Not applicable for semi-enzymes.
#'
#' @param max_miss The maximum number of cleavages.
ct_counts <- function (max_miss = 2L) 
{
  ct <- integer(max_miss)

  if (max_miss) {
    ct[1] <- 2L

    for (i in 1:max_miss) {
      j <- i + 1L
      ct[j] <- ct[i] + j
    }
  } 
  else
    return(1L)

  ct[max_miss]
}


#' Distributes peptides by fixed modifications.
#'
#' @inheritParams calc_pepmasses2
#' @inheritParams matchMS
#' @param is_fixed_protnt Logical; is protein N-terminal modification fixed.
#' @param is_fixed_protct Logical; is protein C-terminal modification fixed.
#' @param data Lists of peptides by prot_accs.
distri_fpeps <- function (data = NULL, max_miss = 2L, is_fixed_protnt = FALSE, 
                          is_fixed_protct = FALSE) 
{
  if (is_fixed_protnt) {
    warning("At fixed `Protein N-term`, ",
            "non N-term peptides are removed.\n",
            "!!! Consider variable `Protein N-term` modifications. !!!")

    # peps: List of 2
    data <- lapply(data, function (peps) { 
      b <- peps[[2]]
      len <- min(max_miss + 1L, length(b))
      peps[[2]] <- b[1:len]

      peps
    })
  }

  if (is_fixed_protct) {
    warning("At fixed `Protein C-term`, ",
            "non C-term peptides are removed.\n",
            "!!! Consider variable `Protein C-term` modifications. !!!")

    data <- lapply(data, function (peps) {
      
      # Without N-term methionine
      a <- peps[[1]]
      end <- length(a)

      if (end > 0L && grepl("-$", a[end])) {
        start <- max(1L, end - max_miss)
        peps[[1]] <- a[start:end]
      }

      # With N-term methonine
      b <- peps[[2]]
      end <- length(b)

      if (end > 0L) {
        start <- max(1L, end - max_miss)
        peps[[2]] <- b[start:end]
      }

      peps
    })
  }

  invisible(data)
}


#' Concatenates adjacent peptides in a list (with mass).
#' 
#' @param peps A list of peptide sequences with a one-letter representation of
#'   amino acid residues.
#' @param n The number of mis-cleavages for consideration.
#' @param include_cts Logical; the list, \code{peps}, includes the protein
#'   C-terminal sequence or not. At the default of TRUE, mis-cleaved peptides at
#'   the end of the protein C-terms will be added as they should. The arguments
#'   would be typically at FALSE, for example, when used for generating
#'   mis-cleaved peptides from the N-terminal of peptides with the removal of a
#'   starting residue \code{M}.
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' peps <- 1:26
#' names(peps) <- LETTERS
#' res1 <- mzion:::roll_sum(peps, 2)
#' res2 <- mzion:::roll_sum(peps, 2, FALSE)
#' 
#' # length shorter than n
#' peps <- c(a = 1)
#' res1 <- mzion:::roll_sum(peps, 2)
#' res2 <- mzion:::roll_sum(peps, 2, FALSE)
#' 
#' peps <- c(a = 1, b = 2, c = 3)
#' res1 <- mzion:::roll_sum(peps, 4)
#' res2 <- mzion:::roll_sum(peps, 4, FALSE)
#' }
roll_sum <- function (peps = NULL, n = 2L, include_cts = TRUE) 
{
  len <- length(peps)
  
  if (!len) 
    return(NULL)
  
  if (n >= len) 
    n <- len - 1L
  
  res <- lapply(seq_len(len - n), function (x) {
    psub <- peps[x:(x + n)]
    
    vals <- cumsum(psub)
    nms <- accumulate_char(names(psub), paste0)
    names(vals) <- nms
    
    vals
  }) 
  
  res <- .Internal(unlist(res, recursive = FALSE, use.names = TRUE))
  
  if (include_cts && n >= 1L) {
    ends <- peps[(len - n + 1L):len]
    
    res2 <- lapply(n:1L, function (x) {
      psub <- tail(ends, x)
      
      vals <- cumsum(psub)
      nms <- accumulate_char(names(psub), paste0)
      names(vals)  <- nms
      
      vals
    })
    
    res2 <- .Internal(unlist(res2, recursive = FALSE, use.names = TRUE))
    ans <- c(res, res2)
  } 
  else
    ans <- res
  
  invisible(ans)
}


#' Helper of \link{semipeps_byprots}.
#'
#' @param prots Lists of proteins with full-enzymatic sequences. For each entry
#'   under a protein, the value is a mass and the name is a peptide sequence.
#' @param min_len The minimum length of peptide sequences for consideration.
#' @inheritParams add_var_masses
#' @inheritParams matchMS
hsemipeps_byprots <- function (prots, min_len = 7L, max_len = 40L, aa_masses) 
{
  lapply(prots, semipeps_byprots, min_len, max_len, aa_masses)
}


#' Finds the semi-enzymatic peptides for a proteins.
#'
#' Redundancy such as peptides from N-term methionine cleavage or semi-tryptic
#' ladders are handled.
#'
#' @param vals A list of full-enzymatic peptides under a protein.
#' @inheritParams matchMS
#' @inheritParams add_var_masses
#' @return A vector of full- and semi-enzymatic peptides. Sequences in names and
#'   masses in values.
semipeps_byprots <- function (vals, min_len = 7L, max_len = 40L, aa_masses) 
{
  peps <- names(vals)
  peps <- gsub("^-", "", peps)
  len <- length(peps)
  
  cts <- grepl("-$", peps)
  ots <- !cts
  peps_ct <- peps[cts]
  peps_ot <- peps[ots]
  vals_ct <- vals[cts]
  vals_ot <- vals[ots]
  
  semis_ot <- mapply(calc_semipepmasses, vals_ot, peps_ot, 
                     MoreArgs = list(min_len = min_len, 
                                     max_len = max_len, 
                                     aa_masses = aa_masses, 
                                     ct_offset = 0L), 
                     SIMPLIFY = FALSE, USE.NAMES = FALSE)
  semis_ot <- .Internal(unlist(semis_ot, recursive = FALSE, use.names = TRUE))
  
  semis_ct <- mapply(calc_semipepmasses, vals_ct, peps_ct, 
                     MoreArgs = list(min_len = min_len, 
                                     max_len = max_len, 
                                     aa_masses = aa_masses, 
                                     ct_offset = 1L), 
                     SIMPLIFY = FALSE, USE.NAMES = FALSE)
  semis_ct <- .Internal(unlist(semis_ct, recursive = FALSE, use.names = TRUE))
  
  ans <- c(vals, semis_ot, semis_ct)
  ans <- ans[!duplicated.default(ans)]
  
  invisible(ans)
}


#' Finds and calculates the masses of semi-enzymatic sequences.
#'
#' Semi-enzymatic sequences are built on full-enzymatic where the N-term
#' residues are removed sequentially.
#'
#' N-term "-" has no effect on the semi-enzymatic generation since
#' semi-enzymatic sequences are always NONE N-term (original enzymatic sequences
#' keep separately and concatenated later). Thus, the N-term tag of "-" was
#' removed from \code{pep} in \link{semipeps_byprots}, before calling this
#' function.
#'
#' @param val A mass of a peptide.
#' @param pep A character string of peptide.
#' @param ct_offset Zero or one to account for the "-" in the C-term of pep.
#' @param aa_masses An amino-acid mass lookup.
#' @inheritParams matchMS
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' fixedmods <- c("TMT6plex (N-term)", "TMT6plex (K)",
#'                "Carbamidomethyl (C)")
#'
#' varmods <- c("Acetyl (Protein N-term)", "Oxidation (M)",
#'              "Deamidated (N)","Gln->pyro-Glu (N-term = Q)")
#'
#' aa_masses_all <- calc_aamasses(fixedmods = fixedmods, varmods = varmods)
#' aa_masses <- aa_masses_all[[1]]
#'
#' val <- 4237.89756
#' pep <- "ALELNQSAEYYYEENEMNYTHDYSQYEVICIK"
#' ans <- mzion:::calc_semipepmasses(val, pep, min_len = 7, max_len = 40, aa_masses)
#'
#' val <- 2423.1017
#' pep <- "QNVEEIPFDSEGPTEPTSSFTI-"
#' ans <- mzion:::calc_semipepmasses(val, pep, min_len = 7, max_len = 40, aa_masses, 1L)
#' }
calc_semipepmasses <- function (val, pep, min_len = 7L, max_len = 40L, aa_masses, 
                                ct_offset = 0L) 
{
  options(digits = 9L)
  
  len <- nchar(pep)
  len2 <- len - ct_offset
  
  if (len2 <= min_len) 
    return(NULL)
  
  span <- len2 - min_len
  
  semipeps <- substring(pep, 2:(span + 1L), len)
  aas <- .Internal(strsplit(pep, "", fixed = TRUE, perl = FALSE, useBytes = FALSE))
  aas <- .Internal(unlist(aas, recursive = FALSE, use.names = FALSE))
  aas <- aas[1:span]
  aas2 <- aa_masses[aas]
  delta <- cumsum(aas2)
  
  ans <- val - delta
  names(ans) <- semipeps
  
  invisible(ans)
}


#' Helper of peptide-mass calculation..
#'
#' (5) "amods- tmod+ vnl- fnl+"; (6) "amods- tmod- vnl- fnl+".
#'
#' The calculation goes through the rows in \code{fnl_combi}.
#' 
#' @param aas \code{aa_seq} split in a sequence of LETTERS.
#' @inheritParams hms1_a0_vnl0_fnl1
#' @return A numeric vector
delta_ms1_a0_fnl1 <- function (fnl_combi, aas, aa_masses) 
{
  nms <- lapply(fnl_combi, names)
  nms <- .Internal(unlist(nms, recursive = FALSE, use.names = FALSE))
  oks <- aas[aas %in% nms]

  if (!length(oks)) 
    return (0L)

  len <- length(fnl_combi)
  out <- vector("numeric", len)
  out[[1]] <- 0L

  for (i in 2:len) {
    row <- fnl_combi[[i]]
    aa_masses[nms] <- .Internal(unlist(row, recursive = FALSE, use.names = FALSE))
    oks <- aas[aas %in% nms]
    out[[i]] <- sum(aa_masses[oks])
  }

  out[!duplicated.default(out)]
}


#' Helper of \link{ms1_a0_vnl0_fnl1}.
#' 
#' @param masses A named list of peptide masses.
#' @param fnl_combi A data.frame of combinations of neutral losses for fixed
#'   modifications. Each row corresponds to a set of neutral loss. The first row
#'   corresponds to the combination without NLs (all zeros).
#' @inheritParams matchMS
#' @inheritParams add_var_masses
hms1_a0_vnl0_fnl1 <- function (masses, fnl_combi, aa_masses, 
                               min_mass = 200L, max_mass = 4500L, digits = 4L) 
{
  mapply(ms1_a0_vnl0_fnl1, 
         masses, names(masses), 
         MoreArgs = list (
           fnl_combi = fnl_combi, 
           aa_masses = aa_masses,
           min_mass = min_mass, 
           max_mass = max_mass, 
           digits = digits
         ), SIMPLIFY = FALSE, USE.NAMES = FALSE)
}


#' Helper by individual peptides. 
#'
#' (5, 6) "amods- tmod+ vnl- fnl+", "amods- tmod- vnl- fnl+"
#'
#' @param mass The mass of a peptide.
#' @param aa_seq Character string; a peptide sequence with one-letter
#'   representation of amino acids.
#' @inheritParams hms1_a0_vnl0_fnl1
#' @importFrom stringr str_split
ms1_a0_vnl0_fnl1 <- function (mass, aa_seq, fnl_combi, aa_masses, 
                              min_mass = 200L, max_mass = 4500L,digits = 4L) 
{
  aas <- .Internal(strsplit(aa_seq, "", fixed = TRUE, perl = FALSE, 
                            useBytes = FALSE))
  aas <- .Internal(unlist(aas, recursive = FALSE, use.names = FALSE))

  delta <- delta_ms1_a0_fnl1(fnl_combi, aas, aa_masses)
  out <- round(mass - delta, digits = digits)
  
  out <- out[out >= min_mass & out <= max_mass]
  # out <- unique(out) # maybe useful
  names(out) <- rep_len(aa_seq, length(out))
  
  invisible(out)
}


#' Helper of \link{ms1_a1_vnl0_fnl0}.
#' 
#' @param masses A named list of peptide masses.
#' @param amods \code{Anywhere} variable modifications.
#' @param fmods_nl The attribute of \code{fmods_nl} from an \code{aa_masses}.
#' @param vmods_nl The attribute of \code{vmods_nl} from an \code{aa_masses}.
#' @param ms1vmods The set of all possible MS1 vmod labels at a given aa_masses.
#' @inheritParams matchMS
#' @inheritParams add_var_masses
hms1_a1_vnl0_fnl0 <- function (masses, amods, aa_masses,
                               vmods_nl = NULL, fmods_nl = NULL,
                               maxn_vmods_per_pep = 5L, maxn_sites_per_vmod = 3L,
                               ms1vmods = NULL, min_mass = 200L, max_mass = 4500L, 
                               digits = 4L) 
{
  mapply(ms1_a1_vnl0_fnl0, 
         masses, names(masses), 
         MoreArgs = list (
           amods = amods, 
           aa_masses = aa_masses,
           vmods_nl = vmods_nl, 
           fmods_nl = fmods_nl,
           maxn_vmods_per_pep = maxn_vmods_per_pep,
           maxn_sites_per_vmod = maxn_sites_per_vmod,
           ms1vmods = ms1vmods, 
           min_mass = min_mass, 
           max_mass = max_mass, 
           digits = digits
         ), SIMPLIFY = FALSE, USE.NAMES = FALSE)
}


#' Helper by individual peptides.
#'
#' (7) "amods+ tmod- vnl- fnl-"; (8) "amods+ tmod+ vnl- fnl-".
#'
#' @param mass The mass of a peptide.
#' @param aa_seq Character string; a peptide sequence with one-letter
#'   representation of amino acids.
#' @inheritParams hms1_a1_vnl0_fnl0
#' @importFrom stringr str_split
#' 
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' m0 <- calc_monopeptide("HQGVMCNVGMGQKMNSC", NULL, NULL)
#' stopifnot(unlist(m0$mass, use.names = FALSE) - 1822.7405 < 1e-4)
#'
#' m1 <- calc_monopeptide("HQGVMCNVGMGQKMNSC", "TMT6plex (N-term)", NULL)
#' stopifnot(unlist(m1$mass, use.names = FALSE) - 2051.9035 < 1e-4)
#'
#' # (7) "amods+ tmod- vnl- fnl-"
#' aa_masses_all <- calc_aamasses(fixedmods = c("TMT6plex (N-term)"),
#'                                varmods = c("Deamidated (N)",
#'                                            "Carbamidomethyl (C)"))
#'
#' pep <- c("HQGVMCNVGMGQKMNSC" = 2051.90346)
#' amods <- list(`Deamidated (N)` = c("Anywhere" = "N"),
#'               `Carbamidomethyl (C)` = c("Anywhere" = "C"))
#'
#' x <- mzion:::ms1_a1_vnl0_fnl0(pep, names(pep), amods, aa_masses_all[[4]])
#'
#' stopifnot(x[[1]] - 2109.9089 < 1e-4,
#'           x[[2]] - 2166.9304 < 1e-4,
#'           x[[3]] - 2110.8930 < 1e-4,
#'           x[[4]] - 2167.9144 < 1e-4)
#'
#'
#' # (8) "amods+ tmod+ vnl- fnl-"
#' aa_masses_all <- calc_aamasses(fixedmods = "TMT6plex (K)",
#'                                varmods = c("Deamidated (N)",
#'                                            "Carbamidomethyl (S)",
#'                                            "Acetyl (Protein N-term)"))
#'
#' pep <- c("HQGVMNVGMGQKSMNS" = 1932.9171) # + TMT6plex (K)
#' amods <- list(`Deamidated (N)` = c("Anywhere" = "N"),
#'               `Carbamidomethyl (S)` = c("Anywhere" = "S"))
#'
#' x <- mzion:::ms1_a1_vnl0_fnl0(pep, names(pep), amods, aa_masses_all[[8]])
#'
#' stopifnot(x[[1]] - 1990.9226 < 1e-4,
#'           x[[2]] - 1991.9066 < 1e-4,
#'           x[[3]] - 2047.9440 < 1e-4,
#'           x[[4]] - 2048.9281 < 1e-4)
#' 
#' 
#' # (8-b)
#' .ms1_vmodsets <- mzion:::make_ms1_vmodsets(aa_masses_all = aa_masses_all, 
#'                                    maxn_vmods_per_pep = 5L, 
#'                                    maxn_sites_per_vmod = 3L)
#' .base_ent <- lapply(.ms1_vmodsets, `[[`, 1)
#' 
#'  x <- mzion:::ms1_a1_vnl0_fnl0(pep, names(pep), amods, aa_masses_all[[8]], 
#'                       # .ms1_vmodsets = .ms1_vmodsets, 
#'                       # .base_ent = .base_ent
#'                       )
#' 
#' # (8-c)
#' fixedmods <- c("TMT6plex (N-term)", "TMT6plex (K)", "Carbamidomethyl (C)")
#' 
#' varmods <- c("Acetyl (Protein N-term)", "Oxidation (M)", "Deamidated (N)",
#'              "Gln->pyro-Glu (N-term = Q)")
#' 
#' aa_masses_all <- calc_aamasses(fixedmods = fixedmods,
#'                                varmods = varmods,
#'                                maxn_vmods_setscombi = 64,
#'                                out_path = NULL)
#'
#' ms1vmods_all <- lapply(aa_masses_all, mzion:::make_ms1vmod_i)
#' 
#' i <- 10
#' aa_masses <- aa_masses_all[[i]]
#' ms1vmods <- ms1vmods_all[[i]]
#' 
#' pep <- c("HQGVMCNVGMGQKMNSC" = 2051.90346)
#' amods <- attr(aa_masses, "amods")
#' 
#' x <- mzion:::ms1_a1_vnl0_fnl0(pep, names(pep), amods, aa_masses_all[[i]], 
#'                       ms1vmods = ms1vmods)
#' 
#' # y <- mzion:::ms1_a1_vnl0_fnl0(pep, names(pep), amods, aa_masses_all[[i]], 
#' #                       ms1vmods = NULL)
#' 
#' # identical(x, y)
#' }
ms1_a1_vnl0_fnl0 <- function (mass, aa_seq, amods, aa_masses,
                              vmods_nl = NULL, fmods_nl = NULL,
                              maxn_vmods_per_pep = 5L,
                              maxn_sites_per_vmod = 3L,
                              ms1vmods = NULL, 
                              min_mass = 200L, max_mass = 4500L, 
                              digits = 4L) 
{
  aas <- .Internal(strsplit(aa_seq, "", fixed = TRUE, perl = FALSE, useBytes = FALSE))
  aas <- .Internal(unlist(aas, recursive = FALSE, use.names = FALSE))
  
  vmods_combi <- match_mvmods(aas = aas, ms1vmods = ms1vmods, amods = amods)$ms1
  
  # "Carbamidomethyl (M)", "Carbamyl (M)" requires two "M"s
  # aas may only have one "M"
  if (!length(vmods_combi)) 
    return(NULL)

  deltas <- lapply(vmods_combi, function (x) sum(aa_masses[x]))
  # rounding needed for removals of duplicated entries
  masses <- lapply(deltas, function (x) round(mass + x, digits = digits))
  out <- .Internal(unlist(masses, recursive = FALSE, use.names = FALSE))
  out <- out[out >= min_mass & out <= max_mass]
  # different combinations can have the same mass
  out <- unique(out)
  names(out) <- rep_len(aa_seq, length(out))
  
  invisible(out)
}


#' Calculates the masses of MS2 ion series.
#'
#' (1) "amods- tmod- vnl- fnl-", (2) "amods- tmod+ vnl- fnl-"
#' 
#' @param aa_seq Character string; a peptide sequences with one-letter
#'   representation of amino acids.
#' @param ms1_mass The mass of a theoretical MS1 (for subsetting).
#' @param ms1vmods The set of all possible MS1 vmod labels at a given aa_masses.
#' @param ms2vmods Matrices of labels of variable modifications. Each
#'   permutation in a row for each matrix.
#' @param ntmass The mass of N-terminal.
#' @param ctmass The mass of C-terminal.
#' @param fmods_nl The attribute of \code{fmods_nl} from an \code{aa_masses}.
#' @param vmods_nl The attribute of \code{vmods_nl} from an \code{aa_masses}.
#' @inheritParams matchMS
#' @inheritParams ms2match
#' 
#' @seealso \link{bions_base}, \link{yions_base}.
#' 
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' # (2) "amods- tmod+ vnl- fnl-"
#' fixedmods <- c("TMT6plex (K)", "Carbamidomethyl (C)")
#' varmods <- c("TMT6plex (N-term)", "Acetyl (Protein N-term)", "Oxidation (M)",
#'              "Deamidated (N)", "Gln->pyro-Glu (N-term = Q)")
#'
#' mod_indexes <- seq_along(c(fixedmods, varmods)) |>
#'   as.hexmode() |>
#'   `names<-`(c(fixedmods, varmods))
#'
#' aa_masses_all <- calc_aamasses(fixedmods, varmods)
#'
#' aa_masses = aa_masses_all[[2]]
#'
#' ntmod <- attr(aa_masses, "ntmod", exact = TRUE)
#' ctmod <- attr(aa_masses, "ctmod", exact = TRUE)
#'
#' if (!length(ntmod)) {
#'   ntmass <- aa_masses["N-term"] - 0.000549 # - electron
#' } else {
#'   ntmass <- aa_masses[names(ntmod)] + 1.00727647 # + proton
#' }
#'
#' if (!length(ctmod)) {
#'   ctmass <- aa_masses["C-term"] + 2.01510147 # + (H) + (H+)
#' } else {
#'   ctmass <- aa_masses[names(ctmod)] + 2.01510147
#' }
#'
#' aa_seq <- "MHQGVMNVGMGQKMNS"
#'
#' out <- mzion:::gen_ms2ions_base(aa_seq = aa_seq, ms1_mass = ms1_mass, 
#'                         aa_masses = aa_masses, ntmod = NULL, ctmod = NULL, 
#'                         ntmass = ntmass, ctmass = ctmass, 
#'                         amods = NULL, vmods_nl = NULL, fmods_nl = NULL, 
#'                         mod_indexes = mod_indexes)
#'                         
#' # (1) "amods- tmod- vnl- fnl-"
#' fixedmods <- c("TMT6plex (N-term)", "TMT6plex (K)", "Carbamidomethyl (C)")
#' varmods <- c("Oxidation (M)", "Deamidated (N)")
#'
#' mod_indexes <- seq_along(c(fixedmods, varmods)) |>
#'   as.hexmode() |>
#'   `names<-`(c(fixedmods, varmods))
#'
#' aa_masses_all <- calc_aamasses(fixedmods, varmods)
#'
#' aa_masses <- aa_masses_all[[1]]
#'
#' ntmod <- attr(aa_masses, "ntmod", exact = TRUE)
#' ctmod <- attr(aa_masses, "ctmod", exact = TRUE)
#'
#' if (!length(ntmod)) {
#'   ntmass <- aa_masses["N-term"] - 0.000549
#' } else {
#'   ntmass <- aa_masses[names(ntmod)] + 1.00727647
#' }
#'
#' if (!length(ctmod)) {
#'   ctmass <- aa_masses["C-term"] + 2.01510147
#' } else {
#'   ctmass <- aa_masses[names(ctmod)] + 2.01510147
#' }
#'
#' aa_seq <- "MHQGVMNVGMGQKMNS"
#'
#' out <- mzion:::gen_ms2ions_base(aa_seq = aa_seq, ms1_mass = ms1_mass, 
#'                         aa_masses = aa_masses, ntmod = NULL, ctmod = NULL, 
#'                         ntmass = ntmass, ctmass = ctmass, 
#'                         amods = NULL, vmods_nl = NULL, fmods_nl = NULL, 
#'                         mod_indexes = mod_indexes)
#' }
gen_ms2ions_base <- function (aa_seq = NULL, ms1_mass = NULL, 
                              aa_masses = NULL, ms1vmods = NULL, ms2vmods = NULL, 
                              ntmod = NULL, ctmod = NULL, 
                              ntmass = NULL, ctmass = NULL, 
                              amods = NULL, vmods_nl = NULL, fmods_nl = NULL, 
                              mod_indexes = NULL, 
                              type_ms2ions = "by", maxn_vmods_per_pep = 5L, 
                              maxn_sites_per_vmod = 3L, 
                              maxn_fnl_per_seq = 3L, maxn_vnl_per_seq = 3L, 
                              maxn_vmods_sitescombi_per_pep = 64L) 
{
  aas <- .Internal(strsplit(aa_seq, "", fixed = TRUE, perl = FALSE, useBytes = FALSE))
  aas <- .Internal(unlist(aas, recursive = FALSE, use.names = FALSE))
  aam <- aa_masses[aas]
  naa <- length(aas)
  
  nm <- .Internal(paste0(list(rep_len("0", naa)), collapse = "", recycle0 = FALSE))
  af <- ms2ions_by_type(aam, ntmass, ctmass, type_ms2ions)
  
  av <- list(calc_rev_ms2(af, aas))
  names(av) <- NA_character_
  af <- list(af)
  names(af) <- nm
  c(af, av)
}


#' Calculates the masses of MS2 ion series.
#'
#' (5) "amods- tmod- vnl- fnl+", (6) "amods- tmod+ vnl- fnl+"
#' 
#' @rdname gen_ms2ions_base
#' 
#' @examples 
#' \donttest{
#' library(mzion)
#' 
#' # (5) "amods- tmod+ vnl- fnl+"
#' fixedmods <- c("TMT6plex (N-term)", "Oxidation (M)", "dHex (S)")
#' varmods <- c("Acetyl (Protein N-term)")
#' 
#' mod_indexes <- seq_along(c(fixedmods, varmods)) |>
#'   as.hexmode() |>
#'   `names<-`(c(fixedmods, varmods))
#'   
#' aa_masses_all <- calc_aamasses(fixedmods, varmods)
#' 
#' aa_masses <- aa_masses_all[[2]]
#' 
#' ntmod <- attr(aa_masses, "ntmod", exact = TRUE)
#' ctmod <- attr(aa_masses, "ctmod", exact = TRUE)
#' 
#' if (!length(ntmod)) {
#'   ntmass <- aa_masses["N-term"] - 0.000549 # - electron
#' } else {
#'   ntmass <- aa_masses[names(ntmod)] - 0.000549
#' }
#' 
#' if (!length(ctmod)) {
#'   ctmass <- aa_masses["C-term"] + 2.01510147 # + (H) + (H+)
#' } else {
#'   ctmass <- aa_masses[names(ctmod)] + 2.01510147
#' }
#' 
#' fmods_nl <- attr(aa_masses, "fmods_nl", exact = TRUE)
#' 
#' aa_seq <- "MHQGVMNVGMGQKMNS"
#' 
#' # variable `TMT6plex (N-term)` + `fixed Oxidation (M)`
#' # (additive varmod on top of fixedmod allowed)
#' 
#' out <- mzion:::gen_ms2ions_a0_vnl0_fnl1(
#'    aa_seq = aa_seq, ms1_mass = NULL, 
#'    aa_masses = aa_masses, ntmod = NULL, ctmod = NULL, 
#'    ntmass = ntmass, ctmass = ctmass, 
#'    amods = NULL, vmods_nl = NULL, fmods_nl = fmods_nl, 
#'    mod_indexes = mod_indexes)
#' }
gen_ms2ions_a0_vnl0_fnl1 <- function (aa_seq, ms1_mass = NULL, 
                                      aa_masses = NULL, ms1vmods = NULL, ms2vmods = NULL, 
                                      ntmod = NULL, ctmod = NULL, # not used
                                      ntmass = NULL, ctmass = NULL, 
                                      amods = NULL, vmods_nl = NULL, # not used
                                      fmods_nl = NULL, 
                                      mod_indexes = NULL, type_ms2ions = "by", 
                                      maxn_vmods_per_pep = 5L, 
                                      maxn_sites_per_vmod = 3L, 
                                      maxn_fnl_per_seq = 3L, 
                                      maxn_vnl_per_seq = 3L, 
                                      maxn_vmods_sitescombi_per_pep = 64L) 
{
  # cannot distinguish a neutral loss is in-source or in-MS2: 
  # "+ms1_offset and +ms2_nl" versus "-ms1_offset and -ms2_nl" 
  # if (ms1_offset != 0) maxn_vnl_per_seq = 1L

  if (maxn_fnl_per_seq < 2L)
    return(
      gen_ms2ions_base(aa_seq = aa_seq, ms1_mass = ms1_mass, 
                       aa_masses = aa_masses, ms1vmods = NULL, ms2vmods = NULL, 
                       ntmod = NULL, ctmod = NULL, 
                       ntmass = ntmass, ctmass = ctmass, 
                       amods = NULL, vmods_nl = NULL, fmods_nl = NULL, 
                       mod_indexes = mod_indexes, 
                       type_ms2ions = type_ms2ions, 
                       maxn_vmods_per_pep = maxn_vmods_per_pep, 
                       maxn_sites_per_vmod = maxn_sites_per_vmod, 
                       maxn_vmods_sitescombi_per_pep = 
                         maxn_vmods_sitescombi_per_pep))

  # (1, 2) "amods- tmod+ vnl- fnl-", "amods- tmod- vnl- fnl-" 
  # (no pep_seq dispatching by Anywhere fmod residues -> possible no matched sites)
  
  sites <- names(fmods_nl)
  
  pattern <- if (length(sites) > 1L)
    .Internal(paste0(list(sites), collapse = "|", recycle0 = FALSE))
  else
    sites

  if (!grepl(pattern, aa_seq)) 
    return(
      gen_ms2ions_base(aa_seq = aa_seq, ms1_mass = ms1_mass, 
                       aa_masses = aa_masses, ms1vmods = NULL, ms2vmods = NULL, 
                       ntmod = NULL, ctmod = NULL, 
                       ntmass = ntmass, ctmass = ctmass, 
                       amods = NULL, vmods_nl = NULL, fmods_nl = NULL, 
                       mod_indexes = mod_indexes, 
                       type_ms2ions = type_ms2ions, 
                       maxn_vmods_per_pep = maxn_vmods_per_pep, 
                       maxn_sites_per_vmod = maxn_sites_per_vmod, 
                       maxn_vmods_sitescombi_per_pep = 
                         maxn_vmods_sitescombi_per_pep))
  
  # (5, 6) "amods- tmod+ vnl- fnl+", "amods- tmod- vnl- fnl+" 
  aas <- .Internal(strsplit(aa_seq, "", fixed = TRUE, perl = FALSE, useBytes = FALSE))
  aas <- .Internal(unlist(aas, recursive = FALSE, use.names = FALSE))
  naa <- length(aas)
  
  # At varmods "Oxidation (M)", pep_seq(s) must contain "M" 
  #   (with an additional entry of "Oxidation (M)" in aa_masses)
  # 
  # At fixedmods "Oxidation (M)", pep_seq(s) may not contain "M"; 
  #   (as `distri_peps` does not filter pep_seq by fixedmods)
  
  idxes <- .Internal(which(aas %fin% names(fmods_nl)))
  
  if (length(idxes) > maxn_vmods_per_pep)
    idxes <- idxes[1:maxn_vmods_per_pep]
  
  # ---
  fmods_combi <- aas[idxes]

  if (length(fmods_combi) == 1L) {
    fnls <- fmods_nl[[fmods_combi]]
    len <- length(fnls)
    ans <- vector("list", len)
    
    for (i in 1:len) {
      ans[[i]] <- fnls[[i]]
      names(ans[[i]]) <- fmods_combi
    }
  }
  else {
    ans <- expand_grid_rows(fmods_nl[fmods_combi], nmax = maxn_fnl_per_seq, 
                            use.names = FALSE)
    len <- length(ans)
  }

  av <- af <- vector("list", len)
  aam <- aa_masses[aas]
  af[[1]] <- af1 <- ms2ions_by_type(aam, ntmass, ctmass, type_ms2ions)
  av[[1]] <- av1 <- calc_rev_ms2(af1, aas)
  
  if (len > 1L) {
    aami <- aam
    aamii <- aami[idxes]
    
    for (i in 2:len) {
      fnl_combi_i <- ans[[i]]
      aami[idxes] <- aamii - fnl_combi_i
      af[[i]] <- afi <- ms2ions_by_type(aami, ntmass, ctmass, type_ms2ions)
      av[[i]] <- calc_rev_ms2(afi, aas)
    }
  }
  
  nm <- .Internal(paste0(list(rep_len("0", naa)), collapse = "", recycle0 = FALSE))
  nm <- .Internal(paste0(list(nm, " [", as.character(seq_len(len)), "]"), 
                         collapse = NULL, recycle0 = FALSE))
  names(af) <- nm
  names(av) <- NA_character_
  c(af, av)
}


#' Calculates the masses of MS2 ion series.
#'
#' (7) "amods+ tmod- vnl- fnl-", (8) "amods+ tmod+ vnl- fnl-"
#' 
#' @rdname gen_ms2ions_base
#' 
#' @param amods The attribute \code{amods} from a \code{aa_masses}.
#' @param ntmod The attribute \code{ntmod} from a \code{aa_masses} (for MS1
#'   calculations).
#' @param ctmod The attribute \code{ctmod} from a \code{aa_masses} (for MS1
#'   calculations).
#'  @rdname gen_ms2ions_base
#'
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' # (8a) "amods+ tmod+ vnl- fnl-"
#' fixedmods <- c("TMT6plex (K)")
#' varmods <- c("Deamidated (N)", "Carbamidomethyl (S)",
#'              "Acetyl (Protein N-term)")
#'
#' mod_indexes <- seq_along(c(fixedmods, varmods)) |>
#'   as.hexmode() |>
#'   `names<-`(c(fixedmods, varmods))
#'
#' aa_masses_all <- calc_aamasses(fixedmods, varmods)
#' 
#' maxn_vmods_per_pep <- 5L
#' maxn_sites_per_vmod <- 3L
#' 
#' ms1vmods_all <- lapply(aa_masses_all, mzion:::make_ms1vmod_i,
#'                        maxn_vmods_per_pep = maxn_vmods_per_pep,
#'                        maxn_sites_per_vmod = maxn_sites_per_vmod)
#'                        
#' ms2vmods_all <- lapply(ms1vmods_all, function (x) lapply(x, mzion:::make_ms2vmods))
#' 
#' i <- 8L
#' aa_masses <- aa_masses_all[[i]]
#' ms1vmods <- ms1vmods_all[[i]]
#' ms2vmods <- ms2vmods_all[[i]]
#'
#' ntmod <- attr(aa_masses, "ntmod", exact = TRUE)
#' ctmod <- attr(aa_masses, "ctmod", exact = TRUE)
#'
#' if (!length(ntmod)) {
#'   ntmass <- aa_masses["N-term"] - 0.000549 # - electron
#' } else {
#'   ntmass <- aa_masses[names(ntmod)] - 0.000549
#' }
#'
#' if (!length(ctmod)) {
#'   ctmass <- aa_masses["C-term"] + 2.01510147 # + (H) + (H+)
#' } else {
#'   ctmass <- aa_masses[names(ctmod)] + 2.01510147
#' }
#'
#' amods <- attr(aa_masses, "amods", exact = TRUE)
#'
#' aa_seq <- "MHQGVMNVGMGQKMNS"
#' ms1_masses <- calc_monopeptide("MHQGVMNVGMGQKMNS",
#'                                fixedmods, varmods)
#' ms1_mass <- ms1_masses$mass[[8]][2] # 2077.9256
#' 
#' # 144 us
#' out <- mzion:::gen_ms2ions_a1_vnl0_fnl0(aa_seq = aa_seq, ms1_mass = ms1_mass, 
#'                                 aa_masses = aa_masses, 
#'                                 ms1vmods = ms1vmods, ms2vmods = ms2vmods, 
#'                                 ntmod = ntmod, ctmod = ctmod,
#'                                 ntmass = ntmass, ctmass = ctmass, amods = amods, 
#'                                 vmods_nl = NULL, fmods_nl = NULL, 
#'                                 mod_indexes = mod_indexes)
#' 
#' # (8b)
#' fixedmods <- c("TMT6plex (N-term)", "TMT6plex (K)", "Carbamidomethyl (C)")
#' varmods <- c("Acetyl (Protein N-term)", "Oxidation (M)", "Deamidated (N)",
#'             "Gln->pyro-Glu (N-term = Q)")
#' 
#' fixedmods <- sort(fixedmods)
#' varmods <- sort(varmods)
#' 
#' mod_indexes <- seq_along(c(fixedmods, varmods)) |>
#'   as.hexmode() |>
#'   `names<-`(c(fixedmods, varmods))
#'
#' aa_masses_all <- calc_aamasses(fixedmods, varmods)
#' 
#' maxn_vmods_per_pep <- 5L
#' maxn_sites_per_vmod <- 3L
#' 
#' ms1vmods_all <- lapply(aa_masses_all, mzion:::make_ms1vmod_i,
#'                        maxn_vmods_per_pep = maxn_vmods_per_pep,
#'                        maxn_sites_per_vmod = maxn_sites_per_vmod)
#'                        
#' ms2vmods_all <- lapply(ms1vmods_all, function (x) lapply(x, mzion:::make_ms2vmods))
#' 
#' i <- 4L
#' aa_masses <- aa_masses_all[[i]]
#' ms1vmods <- ms1vmods_all[[i]]
#' ms2vmods <- ms2vmods_all[[i]]
#' 
#' ntmod <- attr(aa_masses, "ntmod", exact = TRUE)
#' ctmod <- attr(aa_masses, "ctmod", exact = TRUE)
#' 
#' if (!length(ntmod)) {
#'   ntmass <- aa_masses["N-term"] - 0.000549 # - electron
#' } else {
#'   ntmass <- aa_masses[names(ntmod)] - 0.000549
#' }
#' 
#' if (!length(ctmod)) {
#'   ctmass <- aa_masses["C-term"] + 2.01510147 # + (H) + (H+)
#' } else {
#'   ctmass <- aa_masses[names(ctmod)] + 2.01510147
#' }
#' 
#' amods <- attr(aa_masses, "amods", exact = TRUE)
#' 
#' aa_seq <- "EKNALVNEADSADVLQVANTDDEGGPENHRENFNNNNNNSVAVSSLNNGR"
#' ms1_masses <- calc_monopeptide(aa_seq, fixedmods, varmods)
#' ms1_mass <- ms1_masses$mass[[3]][1] # 5824.7551
#' 
#' out <- mzion:::gen_ms2ions_a1_vnl0_fnl0(aa_seq = aa_seq, ms1_mass = ms1_mass, 
#'                                 aa_masses = aa_masses, 
#'                                 ms1vmods = ms1vmods, ms2vmods = ms2vmods, 
#'                                 ntmod = ntmod, ctmod = ctmod,
#'                                 ntmass = ntmass, ctmass = ctmass, 
#'                                 amods = amods, 
#'                                 vmods_nl = NULL, fmods_nl = NULL, 
#'                                 mod_indexes = mod_indexes)
#' 
#' ## same site at multiple variable modifications
#' fixedmods <- c("TMT6plex (N-term)", "Carbamidomethyl (C)")
#' varmods   <- c("Acetyl (K)", "TMT6plex (K)", "Gln->pyro-Glu (N-term = Q)")
#' mod_indexes <- seq_along(c(fixedmods, varmods)) |>
#'   as.hexmode() |>
#'   `names<-`(c(fixedmods, varmods))
#' 
#' aa_masses_all <- calc_aamasses(fixedmods, varmods)
#' 
#' maxn_vmods_per_pep  <- 5L
#' maxn_sites_per_vmod <- 3L
#' 
#' ms1vmods_all <- lapply(aa_masses_all, mzion:::make_ms1vmod_i,
#'                        maxn_vmods_per_pep = maxn_vmods_per_pep,
#'                        maxn_sites_per_vmod = maxn_sites_per_vmod)
#' ms2vmods_all <- lapply(ms1vmods_all, function (x) lapply(x, mzion:::make_ms2vmods))
#' 
#' i <- 5L
#' aa_masses <- aa_masses_all[[i]]
#' amods <- attr(aa_masses, "amods")
#' ntmod <- attr(aa_masses, "ntmod")
#' ctmod <- attr(aa_masses, "ctmod")
#' ms1vmods <- ms1vmods_all[[i]]
#' ms2vmods <- ms2vmods_all[[i]]
#' 
#' if (!length(ntmod)) {
#'   ntmass <- aa_masses["N-term"] - 0.000549 # - electron
#' } else {
#'   ntmass <- aa_masses[names(ntmod)] - 0.000549
#' }
#' 
#' if (!length(ctmod)) {
#'   ctmass <- aa_masses["C-term"] + 2.01510147 # + (H) + (H+)
#' } else {
#'   ctmass <- aa_masses[names(ctmod)] + 2.01510147
#' }
#' 
#' vmods_nl <- attr(aa_masses, "vmods_nl", exact = TRUE)
#' 
#' aa_seq <- "HQGVMKVGMGQKMNK"
#' ms1_masses <- calc_monopeptide(aa_seq, fixedmods, varmods)
#' ms1_mass <- ms1_masses$mass[[4]][3]
#' 
#' out <- mzion:::gen_ms2ions_a1_vnl0_fnl0(aa_seq = aa_seq, ms1_mass = ms1_mass, 
#'                                         aa_masses = aa_masses, 
#'                                         ms1vmods = ms1vmods, ms2vmods = ms2vmods, 
#'                                         ntmod = ntmod, ctmod = ctmod, 
#'                                         ntmass = ntmass, ctmass = ctmass, 
#'                                         amods = amods, 
#'                                         vmods_nl = vmods_nl, fmods_nl = NULL, 
#'                                         mod_indexes = mod_indexes)
#' }
gen_ms2ions_a1_vnl0_fnl0 <- function (aa_seq, ms1_mass = NULL, aa_masses = NULL, 
                                      ms1vmods = NULL, ms2vmods = NULL, 
                                      ntmod = NULL, ctmod = NULL, 
                                      ntmass = NULL, ctmass = NULL, 
                                      amods = NULL, 
                                      vmods_nl = NULL, fmods_nl = NULL, # not used
                                      mod_indexes = NULL, type_ms2ions = "by", 
                                      maxn_vmods_per_pep = 5L, 
                                      maxn_sites_per_vmod = 3L, 
                                      maxn_fnl_per_seq = 3L, 
                                      maxn_vnl_per_seq = 3L, 
                                      maxn_vmods_sitescombi_per_pep = 64L) 
{
  aas <- .Internal(strsplit(aa_seq, "", fixed = TRUE, perl = FALSE, useBytes = FALSE))
  aas <- .Internal(unlist(aas, recursive = FALSE, use.names = FALSE))
  aam <- aa_masses[aas]
  
  ms1vmods <- match_mvmods(aas = aas, ms1vmods = ms1vmods, amods = amods)
  oks <- ms1vmods[["inds"]]
  ms2vmods <- ms2vmods[oks]
  
  # filtered by `ms1_mass`; may be no match as
  # `idxes` may be beyond `maxn_vmods_sitescombi_per_pep`
  idxes <- check_ms1_mass_vmods(ms2vmods = ms2vmods, aam = aam, 
                                aa_masses = aa_masses, 
                                ntmod = ntmod, ctmod = ctmod, 
                                ms1_mass = ms1_mass)
  ms2vmods <- ms2vmods[idxes]
  
  if (!length(ms2vmods)) 
    return(NULL)
  
  # most likely a list-one
  # `[1]` in the rare case of multiple combinations have the same `ms1_mass`
  ms2vmods <- ms2vmods[[1]]

  if (attr(ms2vmods, "single")) {
    P <- find_vmodposU(M = ms2vmods, aas = aas, nmax = maxn_vmods_sitescombi_per_pep)
    M <- attr(P, "mods", exact = TRUE)
    
    af <- calc_ms2ions_a1_vnl0_fnl0(
      M = M, P = P, aam = aam, aa_masses = aa_masses, 
      ntmass = ntmass, ctmass = ctmass, type_ms2ions = type_ms2ions, 
      mod_indexes = mod_indexes)
  }
  else {
    P <- find_vmodposM(M = ms2vmods, aas = aas, nmax = maxn_vmods_sitescombi_per_pep)
    M <- attr(P, "mods", exact = TRUE)

    af <- lapply(split_matrix(M, by = "row"), calc_ms2ions_a1_vnl0_fnl0, 
                 P = P, aam = aam, aa_masses = aa_masses, 
                 ntmass = ntmass, ctmass = ctmass, type_ms2ions = type_ms2ions, 
                 mod_indexes = mod_indexes)
    af <- .Internal(unlist(af, recursive = FALSE, use.names = TRUE))
  }

  av <- lapply(af, calc_rev_ms2, aas)
  names(av) <- NA_character_
  c(af, av)
}


#' Helper for the calculation of MS2 ion series.
#' 
#' @param M A modification matrix or vector.
#' @param P A matrix of position permutations.
#' @param mod_indexes Modification indexes.
#' @inheritParams ms2ions_by_type
#' @inheritParams add_var_masses
calc_ms2ions_a1_vnl0_fnl0 <- function (M, P, aam, aa_masses, ntmass, ctmass, 
                                       type_ms2ions = "by", mod_indexes) 
{
  ds  <- aa_masses[M]
  nvm <- nrow(P)
  out <- vector("list", nvm)
  
  naa <- length(aam)
  hx0 <- rep_len("0", naa)

  for (i in 1:nvm) {
    vi <- P[i, ]
    aam_i <- aam
    aam_i[vi] <- aam_i[vi] + ds
    out[[i]] <- ms2ions_by_type(aam_i, ntmass, ctmass, type_ms2ions)
    
    h <- hx0
    h[vi] <- mod_indexes[M]
    names(out)[i] <- .Internal(paste0(list(h), collapse = "", recycle0 = FALSE))
  }

  out
}


#' Checks the MS1 mass for proceeding with MS2 matches.
#'
#' Maybe missed if a "match" is beyond `maxn_vmods_sitescombi_per_pep`.
#'
#' 'bare + fixed terminals (aa_masses["N-term"] + aa_masses["C-term"]) +
#' variable terminals + anywhere'.
#' 
#' @param ms2vmods Lists of variable modifications. 
#' @param ms1_mass The mass of a theoretical MS1 (for subsetting).
#' @param ntmod The attribute \code{ntmod} from a \code{aa_masses} (for MS1
#'   calculations).
#' @param ctmod The attribute \code{ctmod} from a \code{aa_masses} (for MS1
#'   calculations).
#' @param tol The tolerance in mass.
#' @inheritParams calc_ms2ions_a1_vnl0_fnl0
#' @return A logical vector.
check_ms1_mass_vmods <- function (ms2vmods, aam, aa_masses, ntmod, ctmod, 
                                  ms1_mass = NULL, tol = 1e-3) 
{
  if (is.null(ms1_mass))
    return(FALSE)

  bare <- sum(aam) + aa_masses["N-term"] + aa_masses["C-term"]
  ok_n <- length(ntmod)
  ok_c <- length(ctmod)

  # No need of is_empty(ntmod) && is_empty(ctmod)
  delta <- if (!(ok_n || ok_c))
    0
  else if (ok_n && ok_c)
    aa_masses[names(ntmod)] + aa_masses[names(ctmod)]
  else if (ok_n)
    aa_masses[names(ntmod)]
  else if (ok_c)
    aa_masses[names(ctmod)]
  
  bd  <- bare + delta
  ans <- vector("logical", (len <- length(ms2vmods)))
  
  for (i in 1:len) {
    vi <- ms2vmods[[i]]
    
    if (length(vi)) {
      mi <- bd + sum(aa_masses[vi])
      ans[i] <- abs(mi - ms1_mass) <= tol
      
      # ans[i] <- if (length(ms1_offsets) == 1L && ms1_offsets == 0) 
      #   abs(mi - ms1_mass) <= tol
      # else
      #   any(abs(mi - ms1_mass + ms1_offsets) <= tol)
    }
    else
      ans[i] <- FALSE
  }

  ans
}


#' Calculates the masses of MS2 ion series.
#'
#' (11) "amods+ tmod- vnl- fnl+", (12) "amods+ tmod+ vnl- fnl+"
#' 
#' @rdname gen_ms2ions_base
#' 
#' @param aa_masses An amino-acid mass lookup.
#' @param amods The attribute \code{amods} from a \code{aa_masses}.
#' @param ntmod The attribute \code{ntmod} from a \code{aa_masses} (for MS1
#'   calculations).
#' @param ctmod The attribute \code{ctmod} from a \code{aa_masses} (for MS1
#'   calculations).
#'  @rdname gen_ms2ions_base
#'
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' # (12) "amods+ tmod+ vnl- fnl+"
#' fixedmods <- c("TMT6plex (K)", "Oxidation (M)", "dHex (S)")
#' varmods <- c("Deamidated (N)", "Acetyl (Protein N-term)")
#'
#' mod_indexes <- seq_along(c(fixedmods, varmods)) |>
#'   as.hexmode() |>
#'   `names<-`(c(fixedmods, varmods))
#'
#' aa_masses_all <- calc_aamasses(fixedmods, varmods)
#' 
#' maxn_vmods_per_pep <- 5L
#' maxn_sites_per_vmod <- 3L
#' ms1vmods_all <- lapply(aa_masses_all, mzion:::make_ms1vmod_i,
#'                        maxn_vmods_per_pep = maxn_vmods_per_pep,
#'                        maxn_sites_per_vmod = maxn_sites_per_vmod)
#' 
#' ms2vmods_all <- lapply(ms1vmods_all, function (x) lapply(x, mzion:::make_ms2vmods))
#' 
#' i <- 2L
#' aa_masses <- aa_masses_all[[i]]
#' ms1vmods <- ms1vmods_all[[i]]
#' ms2vmods <- ms2vmods_all[[i]]
#'
#' ntmod <- attr(aa_masses, "ntmod", exact = TRUE)
#' ctmod <- attr(aa_masses, "ctmod", exact = TRUE)
#'
#' if (!length(ntmod)) {
#'   ntmass <- aa_masses["N-term"] - 0.000549 # - electron
#' } else {
#'   ntmass <- aa_masses[names(ntmod)] - 0.000549
#' }
#'
#' if (!length(ctmod)) {
#'   ctmass <- aa_masses["C-term"] + 2.01510147 # + (H) + (H+)
#' } else {
#'   ctmass <- aa_masses[names(ctmod)] + 2.01510147
#' }
#'
#' amods <- attr(aa_masses, "amods", exact = TRUE)
#' fmods_nl <- attr(aa_masses, "fmods_nl", exact = TRUE)
#'
#' aa_seq <- "HQGVMNVGMGQKMNS"
#' ms1_masses <- calc_monopeptide(aa_seq, fixedmods, varmods)
#' 
#' ms1_mass <- ms1_masses$mass[[2]][2] # 2041.8958
#'
#' out <- mzion:::gen_ms2ions_a1_vnl0_fnl1(aa_seq = aa_seq, ms1_mass = ms1_mass, 
#'                                 aa_masses = aa_masses, 
#'                                 ms1vmods = ms1vmods, ms2vmods = ms2vmods, 
#'                                 ntmod = ntmod, ctmod = ctmod,
#'                                 ntmass = ntmass, ctmass = ctmass, 
#'                                 amods = amods, 
#'                                 vmods_nl = NULL, fmods_nl = fmods_nl, 
#'                                 mod_indexes = mod_indexes)
#' 
#' # No "M", no "S"
#' aa_seq <- "HQGVNVGGQKN"
#' ms1_masses <- calc_monopeptide(aa_seq, fixedmods, varmods)
#' ms1_mass <- ms1_masses$mass[[2]][2] # 1367.6996
#' 
#' ## same site at multiple variable modifications
#' fixedmods <- c("Oxidation (M)", "dHex (S)")
#' varmods <- c("Acetyl (K)", "TMT6plex (K)", "Deamidated (N)")
#' 
#' mod_indexes <- seq_along(c(fixedmods, varmods)) |>
#'   as.hexmode() |>
#'   `names<-`(c(fixedmods, varmods))
#' 
#' aa_masses_all <- calc_aamasses(fixedmods, varmods)
#' 
#' maxn_vmods_per_pep <- 5L
#' maxn_sites_per_vmod <- 3L
#' ms1vmods_all <- lapply(aa_masses_all, mzion:::make_ms1vmod_i,
#'                        maxn_vmods_per_pep = maxn_vmods_per_pep,
#'                        maxn_sites_per_vmod = maxn_sites_per_vmod)
#' 
#' ms2vmods_all <- lapply(ms1vmods_all, function (x) lapply(x, mzion:::make_ms2vmods))
#' 
#' i <- 5L
#' aa_masses <- aa_masses_all[[i]]
#' ms1vmods <- ms1vmods_all[[i]]
#' ms2vmods <- ms2vmods_all[[i]]
#' 
#' ntmod <- attr(aa_masses, "ntmod", exact = TRUE)
#' ctmod <- attr(aa_masses, "ctmod", exact = TRUE)
#' 
#' if (!length(ntmod)) {
#'   ntmass <- aa_masses["N-term"] - 0.000549 # - electron
#' } else {
#'   ntmass <- aa_masses[names(ntmod)] - 0.000549
#' }
#' 
#' if (!length(ctmod)) {
#'   ctmass <- aa_masses["C-term"] + 2.01510147 # + (H) + (H+)
#' } else {
#'   ctmass <- aa_masses[names(ctmod)] + 2.01510147
#' }
#' 
#' amods <- attr(aa_masses, "amods", exact = TRUE)
#' fmods_nl <- attr(aa_masses, "fmods_nl", exact = TRUE)
#' 
#' aa_seq <- "HQGVMKVGMGQKMNSK"
#' ms1_masses <- calc_monopeptide(aa_seq, fixedmods, varmods)
#' 
#' ms1_mass <- ms1_masses$mass[[5]][2] # 2041.8958
#' 
#' out <- mzion:::gen_ms2ions_a1_vnl0_fnl1(aa_seq = aa_seq, ms1_mass = ms1_mass, 
#'                                         aa_masses = aa_masses, 
#'                                         ms1vmods = ms1vmods, ms2vmods = ms2vmods, 
#'                                         ntmod = ntmod, ctmod = ctmod,
#'                                         ntmass = ntmass, ctmass = ctmass, 
#'                                         amods = amods, 
#'                                         vmods_nl = NULL, fmods_nl = fmods_nl, 
#'                                         mod_indexes = mod_indexes)
#' }
gen_ms2ions_a1_vnl0_fnl1 <- function (aa_seq = NULL, ms1_mass = NULL, 
                                      aa_masses = NULL, 
                                      ms1vmods = NULL, ms2vmods = NULL, 
                                      ntmod = NULL, ctmod = NULL, 
                                      ntmass = NULL, ctmass = NULL, 
                                      amods = NULL, 
                                      vmods_nl = NULL, # not used
                                      fmods_nl = NULL, 
                                      mod_indexes = NULL, type_ms2ions = "by", 
                                      maxn_vmods_per_pep = 5L, 
                                      maxn_sites_per_vmod = 3L, 
                                      maxn_vmods_sitescombi_per_pep = 64L, 
                                      maxn_fnl_per_seq = 3L, 
                                      maxn_vnl_per_seq = 3L) 
{
  if (maxn_fnl_per_seq < 2L)
    return(
      gen_ms2ions_a1_vnl0_fnl0(aa_seq = aa_seq, ms1_mass = ms1_mass, 
                               aa_masses = aa_masses, 
                               ms1vmods = ms1vmods, ms2vmods = ms2vmods, 
                               ntmod = ntmod, ctmod = ctmod, 
                               ntmass = ntmass, ctmass = ctmass, 
                               amods = amods, mod_indexes = mod_indexes, 
                               type_ms2ions = type_ms2ions, 
                               maxn_vmods_per_pep = maxn_vmods_per_pep, 
                               maxn_sites_per_vmod = maxn_sites_per_vmod, 
                               maxn_vmods_sitescombi_per_pep = 
                                 maxn_vmods_sitescombi_per_pep))

  # (7, 8) "amods+ tmod- vnl- fnl-", "amods+ tmod+ vnl- fnl-"
  # (no pep_seq dispatching by fmod residues -> possible no matched sites)
  sites <- names(fmods_nl)
  # pattern <- .Internal(paste(list(sites), sep = " ", collapse = "|", recycle0 = FALSE))
  pattern <- if (length(sites) > 1L)
    .Internal(paste0(list(sites), collapse = "|", recycle0 = FALSE))
  else
    sites
  
  if (!grepl(pattern, aa_seq)) 
    return(
      gen_ms2ions_a1_vnl0_fnl0(aa_seq = aa_seq, ms1_mass = ms1_mass, 
                               aa_masses = aa_masses, 
                               ms1vmods = ms1vmods, ms2vmods = ms2vmods, 
                               ntmod = ntmod, ctmod = ctmod, 
                               ntmass = ntmass, ctmass = ctmass, 
                               amods = amods, mod_indexes = mod_indexes, 
                               type_ms2ions = type_ms2ions, 
                               maxn_vmods_per_pep = maxn_vmods_per_pep, 
                               maxn_sites_per_vmod = maxn_sites_per_vmod, 
                               maxn_vmods_sitescombi_per_pep = 
                                 maxn_vmods_sitescombi_per_pep))
  
  # (11, 12) "amods+ tmod- vnl- fnl+", "amods+ tmod+ vnl- fnl+"
  aas <- .Internal(strsplit(aa_seq, "", fixed = TRUE, perl = FALSE, useBytes = FALSE))
  aas <- .Internal(unlist(aas, recursive = FALSE, use.names = FALSE))
  aam <- aa_masses[aas]
  
  ms1vmods <- match_mvmods(aas = aas, ms1vmods = ms1vmods, amods = amods)
  oks <- ms1vmods[["inds"]]
  ms2vmods <- ms2vmods[oks]
  
  idxes <- check_ms1_mass_vmods(ms2vmods = ms2vmods, aam = aam, 
                                aa_masses = aa_masses, 
                                ntmod = ntmod, ctmod = ctmod, 
                                ms1_mass = ms1_mass)
  ms2vmods <- ms2vmods[idxes]
  
  if (!length(ms2vmods)) 
    return(NULL)
  
  fnl_idxes <- .Internal(which(aas %fin% names(fmods_nl)))
  fmods_combi <- aas[fnl_idxes]
  
  if (length(fmods_combi) == 1L) {
    fnls <- fmods_nl[[fmods_combi]]
    len <- length(fnls)
    fnl_combi <- vector("list", len)
    
    for (i in 1:len) {
      fnl_combi[[i]] <- fnls[[i]]
      names(fnl_combi[[i]]) <- fmods_combi
    }
  }
  else {
    fnl_combi <- expand_grid_rows(fmods_nl[fmods_combi], nmax = maxn_fnl_per_seq, 
                                  use.names = FALSE)
  }
  
  # most likely a list-one
  # `[1]` in case of multiple combinations have the same `ms1_mass`
  ms2vmods <- ms2vmods[[1]]

  if (attr(ms2vmods, "single")) {
    P <- find_vmodposU(M = ms2vmods, aas = aas, nmax = maxn_vmods_sitescombi_per_pep)
    M <- attr(P, "mods", exact = TRUE)
    
    af <- calc_ms2ions_a1_vnl0_fnl1(
      M = M, P = P, fnl_combi = fnl_combi, 
      fnl_idxes = fnl_idxes, aam = aam, aa_masses = aa_masses, ntmass = ntmass, 
      ctmass = ctmass, type_ms2ions = type_ms2ions, mod_indexes = mod_indexes)
  }
  else {
    P <- find_vmodposM(M = ms2vmods, aas = aas, nmax = maxn_vmods_sitescombi_per_pep)
    M <- attr(P, "mods", exact = TRUE)

    af <- lapply(split_matrix(M, by = "row"), calc_ms2ions_a1_vnl0_fnl1, 
                 P = P, fnl_combi = fnl_combi, 
                 fnl_idxes = fnl_idxes, aam = aam, aa_masses = aa_masses, 
                 ntmass = ntmass, ctmass = ctmass, type_ms2ions = type_ms2ions, 
                 mod_indexes = mod_indexes)
    
    af <- .Internal(unlist(af, recursive = FALSE, use.names = TRUE))
  }

  av <- lapply(af, calc_rev_ms2, aas)
  names(av) <- NA_character_
  c(af, av)
}


#' Calculates
#'
#' @param M A modification matrix or vector.
#' @param fnl_idxes The position indexes of amino acids containing fixed neutral
#'   losses.
#' @param mod_indexes Modification indexes.
#' @inheritParams calc_ms2ions_a1_vnl0_fnl0
#' @inheritParams hms1_a0_vnl0_fnl1
calc_ms2ions_a1_vnl0_fnl1 <- function (M, P, fnl_combi, fnl_idxes, 
                                       aam, aa_masses, ntmass, ctmass, 
                                       type_ms2ions = "by", mod_indexes) 
{
  ds  <- aa_masses[M]
  nvm <- nrow(P)
  nnl <- length(fnl_combi)
  len <- nvm * nnl
  out <- vector("list", len)
  r <- 1L
  
  naa <- length(aam)
  hx0 <- rep_len("0", naa)
  
  for (i in 1:nvm) {
    vi <- P[i, ]
    aam_i <- aam
    aam_i[vi] <- aam_i[vi] + ds
    
    # the first fnl are all 0's
    out[[r]] <- ms2ions_by_type(aam_i, ntmass, ctmass, type_ms2ions)
    r <- r + 1L
    
    if (nnl > 1L) {
      for (j in 2:nnl) {
        aam_j <- aam_i
        delta_nl <- .Internal(unlist(fnl_combi[[j]], recursive = FALSE, use.names = FALSE))
        aam_j[fnl_idxes] <- aam_j[fnl_idxes] - delta_nl
        out[[r]] <- ms2ions_by_type(aam_j, ntmass, ctmass, type_ms2ions)
        r <- r + 1L
      }
    }

    h <- hx0
    h[vi] <- mod_indexes[M]
    h <- .Internal(paste0(list(h), collapse = "", recycle0 = FALSE))
    
    # Syntax: `(` for `vnl` and `[` for fnl
    names(out)[((i-1)*j+1L):(i*j)] <- 
      .Internal(paste0(list(h, 
                            " [", 
                            as.character(1:j), 
                            "]"), 
                       collapse = NULL, recycle0 = FALSE))
  }

  out
}


#' Calculates the masses of MS2 ion series.
#'
#' (9) "amods+ tmod- vnl+ fnl-", (10) "amods+ tmod+ vnl+ fnl-"
#' 
#' @rdname gen_ms2ions_base
#' 
#' 
#' @param amods The attribute \code{amods} from a \code{aa_masses}.
#' @param ntmod The attribute \code{ntmod} from a \code{aa_masses} (for MS1
#'   calculations).
#' @param ctmod The attribute \code{ctmod} from a \code{aa_masses} (for MS1
#'   calculations).
#'  @rdname gen_ms2ions_base
#'
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' # (10) "amods+ tmod+ vnl+ fnl-"
#' fixedmods <- c("TMT6plex (K)")
#' varmods <- c("dHex (S)", "Oxidation (M)", "Deamidated (N)", 
#'              "Acetyl (Protein N-term)")
#'
#' mod_indexes <- seq_along(c(fixedmods, varmods)) |>
#'   as.hexmode() |>
#'   `names<-`(c(fixedmods, varmods))
#'
#' aa_masses_all <- calc_aamasses(fixedmods, varmods)
#' 
#' maxn_vmods_per_pep <- 5L
#' maxn_sites_per_vmod <- 3L
#'
#' ms1vmods_all <- lapply(aa_masses_all, mzion:::make_ms1vmod_i,
#'                        maxn_vmods_per_pep = maxn_vmods_per_pep,
#'                        maxn_sites_per_vmod = maxn_sites_per_vmod)
#' ms2vmods_all <- lapply(ms1vmods_all, function (x) lapply(x, mzion:::make_ms2vmods))
#'
#' i <- 16L
#' aa_masses <- aa_masses_all[[i]]
#' amods <- attr(aa_masses, "amods")
#'
#' ms1vmods <- ms1vmods_all[[i]]
#' ms2vmods <- ms2vmods_all[[i]]
#'
#' ntmod <- attr(aa_masses, "ntmod", exact = TRUE)
#' ctmod <- attr(aa_masses, "ctmod", exact = TRUE)
#'
#' if (!length(ntmod)) {
#'   ntmass <- aa_masses["N-term"] - 0.000549 # - electron
#' } else {
#'   ntmass <- aa_masses[names(ntmod)] - 0.000549
#' }
#'
#' if (!length(ctmod)) {
#'   ctmass <- aa_masses["C-term"] + 2.01510147 # + (H) + (H+)
#' } else {
#'   ctmass <- aa_masses[names(ctmod)] + 2.01510147
#' }
#'
#' amods <- attr(aa_masses, "amods", exact = TRUE)
#' vmods_nl <- attr(aa_masses, "vmods_nl", exact = TRUE)
#'
#' aa_seq <- "HQGVMNVGMGQKMNS"
#' ms1_masses <- calc_monopeptide("HQGVMNVGMGQKMNS",
#'                                fixedmods, varmods)
#' ms1_mass <- ms1_masses$mass[[16]][2] # 2197.9679
#'
#' out <- mzion:::gen_ms2ions_a1_vnl1_fnl0(aa_seq = aa_seq, ms1_mass = ms1_mass, 
#'                                 aa_masses = aa_masses, 
#'                                 ms1vmods = ms1vmods, ms2vmods = ms2vmods, 
#'                                 ntmod = ntmod, ctmod = ctmod, 
#'                                 ntmass = ntmass, ctmass = ctmass, 
#'                                 amods = amods, 
#'                                 vmods_nl = vmods_nl, fmods_nl = NULL, 
#'                                 mod_indexes = mod_indexes)
#' 
#' # Not in the category; 
#' # should be at least one `amod` with vnl+ 
#' # (aa_seq <- "HQGVVGGQK")
#' # (aa_seq <- "HQNGVVGGQK")
#' 
#' # Mismatches between `vmods_nl` and `aa_seq`
#' #  All of M, N, S should be present after pep_seq dispatching 
#' #    -> "correct" vmods_nl with all and only M, N, S (+/- tmods)
#' # (aa_seq <- "HQNGVVGGQKM") # no "S"
#' 
#' 
#' # (10) "amods+ tmod+ vnl+ fnl-"
#' fixedmods <- c("TMT6plex (N-term)", "TMT6plex (K)", 
#'                "Carbamidomethyl (C)")
#' varmods <- c("Acetyl (Protein N-term)", "Oxidation (M)", 
#'              "Carbamidomethyl (M)")
#' 
#' mod_indexes <- seq_along(c(fixedmods, varmods)) |>
#'   as.hexmode() |>
#'   `names<-`(c(fixedmods, varmods))
#' 
#' aa_masses_all <- calc_aamasses(fixedmods, varmods)
#' 
#' maxn_vmods_per_pep <- 5L
#' maxn_sites_per_vmod <- 3L
#'
#' ms1vmods_all <- lapply(aa_masses_all, mzion:::make_ms1vmod_i,
#'                        maxn_vmods_per_pep = maxn_vmods_per_pep,
#'                        maxn_sites_per_vmod = maxn_sites_per_vmod)
#' ms2vmods_all <- lapply(ms1vmods_all, function (x) lapply(x, mzion:::make_ms2vmods))
#'
#' i <- 8L
#' aa_masses <- aa_masses_all[[i]]
#' amods <- attr(aa_masses, "amods")
#'
#' ms1vmods <- ms1vmods_all[[i]]
#' ms2vmods <- ms2vmods_all[[i]]
#' 
#' ntmod <- attr(aa_masses, "ntmod", exact = TRUE)
#' ctmod <- attr(aa_masses, "ctmod", exact = TRUE)
#' 
#' if (!length(ntmod)) {
#'   ntmass <- aa_masses["N-term"] - 0.000549 # - electron
#' } else {
#'   ntmass <- aa_masses[names(ntmod)] - 0.000549
#' }
#' 
#' if (!length(ctmod)) {
#'   ctmass <- aa_masses["C-term"] + 2.01510147 # + (H) + (H+)
#' } else {
#'   ctmass <- aa_masses[names(ctmod)] + 2.01510147
#' }
#' 
#' amods <- attr(aa_masses, "amods", exact = TRUE)
#' vmods_nl <- attr(aa_masses, "vmods_nl", exact = TRUE)
#' 
#' aa_seq <- "MHQGVMNVGMGQKMNS"
#' 
#' # No-matches at `ms1_mass = 2123.9424` as the matching index 
#' # exceeds "maxn_vmods_sitescombi_per_pep"
#' out <- mzion:::gen_ms2ions_a1_vnl1_fnl0(aa_seq = aa_seq, ms1_mass = 2123.9424, 
#'                                 aa_masses = aa_masses, 
#'                                 ms1vmods = ms1vmods, ms2vmods = ms2vmods, 
#'                                 ntmod = ntmod, ctmod = ctmod, 
#'                                 ntmass = ntmass, ctmass = ctmass, 
#'                                 amods = amods, 
#'                                 vmods_nl = vmods_nl, fmods_nl = NULL,
#'                                 mod_indexes = mod_indexes)
#' 
#' ## same site at multiple variable modifications
#' fixedmods <- c("TMT6plex (K)", "dHex (S)")
#' varmods   <- c("Carbamidomethyl (M)", "Carbamyl (M)",
#'                "Deamidated (N)", "Acetyl (Protein N-term)")
#' mod_indexes <- seq_along(c(fixedmods, varmods)) |>
#'   as.hexmode() |>
#'   `names<-`(c(fixedmods, varmods))
#' 
#' aa_masses_all <- calc_aamasses(fixedmods, varmods)
#' 
#' maxn_vmods_per_pep  <- 5L
#' maxn_sites_per_vmod <- 3L
#' 
#' ms1vmods_all <- lapply(aa_masses_all, mzion:::make_ms1vmod_i,
#'                        maxn_vmods_per_pep = maxn_vmods_per_pep,
#'                        maxn_sites_per_vmod = maxn_sites_per_vmod)
#' ms2vmods_all <- lapply(ms1vmods_all, function (x) lapply(x, mzion:::make_ms2vmods))
#' 
#' i <- 12L
#' aa_masses <- aa_masses_all[[i]]
#' amods <- attr(aa_masses, "amods")
#' ntmod <- attr(aa_masses, "ntmod")
#' ctmod <- attr(aa_masses, "ctmod")
#' ms1vmods <- ms1vmods_all[[i]]
#' ms2vmods <- ms2vmods_all[[i]]
#' 
#' if (!length(ntmod)) {
#'   ntmass <- aa_masses["N-term"] - 0.000549 # - electron
#' } else {
#'   ntmass <- aa_masses[names(ntmod)] - 0.000549
#' }
#' 
#' if (!length(ctmod)) {
#'   ctmass <- aa_masses["C-term"] + 2.01510147 # + (H) + (H+)
#' } else {
#'   ctmass <- aa_masses[names(ctmod)] + 2.01510147
#' }
#' 
#' vmods_nl <- attr(aa_masses, "vmods_nl", exact = TRUE)
#' 
#' aa_seq <- "HQGVMNVGMGQKMNS"
#' ms1_masses <- calc_monopeptide(aa_seq, fixedmods, varmods)
#' ms1_mass <- ms1_masses$mass[[i]][3] # 2135.9601
#' 
#' out <- mzion:::gen_ms2ions_a1_vnl1_fnl0(aa_seq = aa_seq, ms1_mass = ms1_mass, 
#'                                         aa_masses = aa_masses, 
#'                                         ms1vmods = ms1vmods, ms2vmods = ms2vmods, 
#'                                         ntmod = ntmod, ctmod = ctmod, 
#'                                         ntmass = ntmass, ctmass = ctmass, 
#'                                         amods = amods, 
#'                                         vmods_nl = vmods_nl, fmods_nl = NULL, 
#'                                         mod_indexes = mod_indexes)
#' }
gen_ms2ions_a1_vnl1_fnl0 <- function (aa_seq = NULL, ms1_mass = NULL, 
                                      aa_masses = NULL, 
                                      ms1vmods = NULL, ms2vmods = NULL, 
                                      ntmod = NULL, ctmod = NULL, 
                                      ntmass = NULL, ctmass = NULL, 
                                      amods = NULL, vmods_nl = NULL, 
                                      fmods_nl = NULL, # not used
                                      mod_indexes = NULL, type_ms2ions = "by", 
                                      maxn_vmods_per_pep = 5L, 
                                      maxn_sites_per_vmod = 3L, 
                                      maxn_vmods_sitescombi_per_pep = 64L, 
                                      maxn_fnl_per_seq = 3L, 
                                      maxn_vnl_per_seq = 3L) 
{
  if (maxn_vnl_per_seq < 2L)
    return(gen_ms2ions_a1_vnl0_fnl0(aa_seq = aa_seq, ms1_mass = ms1_mass, 
                                    aa_masses = aa_masses, 
                                    ms1vmods = ms1vmods, ms2vmods = ms2vmods, 
                                    ntmod = ntmod, ctmod = ctmod, 
                                    ntmass = ntmass, ctmass = ctmass, 
                                    amods = amods, mod_indexes = mod_indexes, 
                                    type_ms2ions = type_ms2ions, 
                                    maxn_vmods_per_pep = maxn_vmods_per_pep, 
                                    maxn_sites_per_vmod = maxn_sites_per_vmod, 
                                    maxn_vmods_sitescombi_per_pep = 
                                      maxn_vmods_sitescombi_per_pep))

  aas <- .Internal(strsplit(aa_seq, "", fixed = TRUE, perl = FALSE, useBytes = FALSE))
  aas <- .Internal(unlist(aas, recursive = FALSE, use.names = FALSE))
  aam <- aa_masses[aas]
  
  ms1vmods <- match_mvmods(aas = aas, ms1vmods = ms1vmods, amods = amods)
  oks <- ms1vmods[["inds"]]
  ms2vmods <- ms2vmods[oks]
  
  idxes <- check_ms1_mass_vmods(ms2vmods = ms2vmods, aam = aam, 
                                aa_masses = aa_masses, 
                                ntmod = ntmod, ctmod = ctmod, 
                                ms1_mass = ms1_mass)
  ms2vmods <- ms2vmods[idxes]
  
  if (!length(ms2vmods)) 
    return(NULL)
  
  # most likely a list-one
  # `[1]` in case of multiple combinations have the same `ms1_mass`
  ms2vmods <- ms2vmods[[1]]

  if (attr(ms2vmods, "single")) {
    P  <- find_vmodposU(M = ms2vmods, aas = aas, nmax = maxn_vmods_sitescombi_per_pep)
    M  <- attr(P, "mods", exact = TRUE)
    nP <- nrow(P)
    
    if (nP >= maxn_vmods_sitescombi_per_pep)
      af <- calc_ms2ions_a1_vnl0_fnl0(
        M = M, P = P, aam = aam, aa_masses = aa_masses, 
        ntmass = ntmass, ctmass = ctmass, type_ms2ions = type_ms2ions, 
        mod_indexes = mod_indexes)
    else {
      nnl <- min(maxn_vmods_sitescombi_per_pep %/% nP, maxn_vnl_per_seq)
      
      if (nnl <= 1L)
        af <- calc_ms2ions_a1_vnl0_fnl0(
          M = M, P = P, aam = aam, aa_masses = aa_masses, 
          ntmass = ntmass, ctmass = ctmass, type_ms2ions = type_ms2ions, 
          mod_indexes = mod_indexes)
      else
        af <- calc_ms2ions_a1_vnl1_fnl0(
          N = expand_grid_rows(vmods_nl[ms2vmods], nmax = nnl, use.names = FALSE), 
          M = M, 
          P = P, 
          aam = aam, 
          aa_masses = aa_masses, 
          ntmass = ntmass, 
          ctmass = ctmass, 
          type_ms2ions = type_ms2ions, 
          mod_indexes = mod_indexes)
    }
  }
  else {
    P  <- find_vmodposM(M = ms2vmods, aas = aas, nmax = maxn_vmods_sitescombi_per_pep)
    M  <- attr(P, "mods", exact = TRUE)
    nP <- nrow(P)
    nM <- nrow(M)
    n1 <- nP * nM

    if (n1 > maxn_vmods_sitescombi_per_pep) {
      l <- maxn_vmods_sitescombi_per_pep %/% nP
      M <- M[1:l, ] # l >= 1L

      if (l == 1L) {
        af <- calc_ms2ions_a1_vnl0_fnl0(
          M = M, P = P, aam = aam, aa_masses = aa_masses, 
          ntmass = ntmass, ctmass = ctmass, type_ms2ions = type_ms2ions, 
          mod_indexes = mod_indexes)
      }
      else {
        af <- lapply(split_matrix(M, by = "row"), calc_ms2ions_a1_vnl0_fnl0, 
                     P = P, aam = aam, aa_masses = aa_masses, 
                     ntmass = ntmass, ctmass = ctmass, type_ms2ions = type_ms2ions, 
                     mod_indexes = mod_indexes)
        af <- .Internal(unlist(af, recursive = FALSE, use.names = TRUE))
      }
    }
    else {
      M <- split_matrix(M, by = "row")
      l <- maxn_vmods_sitescombi_per_pep  %/% n1
      
      if (l <= 1L) {
        af <- lapply(M, calc_ms2ions_a1_vnl0_fnl0, 
                     P = P, aam = aam, aa_masses = aa_masses, 
                     ntmass = ntmass, ctmass = ctmass, type_ms2ions = type_ms2ions, 
                     mod_indexes = mod_indexes)
        af <- .Internal(unlist(af, recursive = FALSE, use.names = TRUE))
      }
      else {
        n2 <- n1 * prod(lengths(vmods_nl))
        
        N <- if (n2 > maxn_vmods_sitescombi_per_pep)
          lapply(M, function (x) 
            expand_grid_rows(vmods_nl[x], nmax = 2L, use.names = FALSE))
        else
          lapply(M, function (x) 
            expand_grid_rows(vmods_nl[x], nmax = maxn_vnl_per_seq, use.names = FALSE))
        
        af <- mapply(
          calc_ms2ions_a1_vnl1_fnl0, 
          N, M, 
          MoreArgs = list(
            P = P, 
            aam = aam, 
            aa_masses = aa_masses, 
            ntmass = ntmass, 
            ctmass = ctmass, 
            type_ms2ions = type_ms2ions, 
            mod_indexes = mod_indexes
          ), 
          SIMPLIFY = FALSE, 
          USE.NAMES = FALSE)
        
        af <- .Internal(unlist(af, recursive = FALSE, use.names = TRUE))
      }
    }
  }

  # hexcodes of the reversed entries are not yet reversed; 
  #   they are not used and for time efficiency just leave them as they are
  # names are `pep_ivmod`; NA is the indicator for reversed entries
  av <- lapply(af, calc_rev_ms2, aas)
  names(av) <- NA_character_
  c(af, av)
}


#' Calculates MS2 ions.
#'
#' @param M A vector of modifications.
#' @param P A matrix of positions.
#' @param N Lists of combinations of neutral losses for corresponding \code{P}.
#'   Each list contains a table where each column corresponds to a set of
#'   neutral loss. The first column corresponds to the combination without NLs.
#' @param mod_indexes Modification indexes.
#' @inheritParams ms2ions_by_type
#' @inheritParams add_var_masses
#' @inheritParams matchMS
calc_ms2ions_a1_vnl1_fnl0 <- function (N, M, P, aam, aa_masses, 
                                       ntmass, ctmass, 
                                       type_ms2ions = "by", mod_indexes) 
{
  ds  <- aa_masses[M]
  nnl <- length(N)
  nvm <- nrow(P)
  len <- nvm * nnl
  out <- vector("list", len)
  naa <- length(aam)
  hx0 <- rep_len("0", naa)
  r <- 1L

  for (i in 1:nvm) {
    vi <- P[i, ]
    aam_i <- aam
    aam_i[vi] <- aam_i[vi] + ds
    
    for (j in 1:nnl) {
      aam_j <- aam_i
      delta_nl <- .Internal(unlist(N[[j]], recursive = FALSE, use.names = FALSE))
      aam_j[vi] <- aam_j[vi] - delta_nl
      out[[r]] <- ms2ions_by_type(aam_j, ntmass, ctmass, type_ms2ions)
      r <- r + 1L
    }

    # both i and j must exist
    h <- hx0
    h[vi] <- mod_indexes[M]
    h <- .Internal(paste0(list(h), collapse = "", recycle0 = FALSE))
    
    # Syntax: `(` for `vnl` and `[` for fnl
    names(out)[((i-1)*j+1L):(i*j)] <- 
      .Internal(paste0(list(h, 
                            " (", 
                            as.character(1:j), 
                            ")"), 
                       collapse = NULL, recycle0 = FALSE))
  }
  
  out
}


#' Pairs MGF queries to theoretical MS1 masses and peptide sequences.
#'
#' @param mgf_path The path to MGF files
#' @param n_modules The number of modules (\code{length(aa_masses_all)}) or one
#' @param ms1_offsets Off-sets in precursor masses (in relative to the values in
#'   the original MGFs).
#' @param .path_bin The path to binned theoretical masses
#' @param ppm_ms1_bin The tolerance in precursor mass error after mass binning.
#' @inheritParams ms2match
#' @inheritParams matchMS
pair_mgftheos <- function (mgf_path, n_modules, ms1_offsets = 0, quant = "none", 
                           min_mass = 200L, max_mass = 4500L, 
                           ppm_ms1_bin = 10L, .path_bin, reframe_mgfs = FALSE, 
                           first_search = FALSE)
{
  message("Pairing experimental and theoretical data.")
  
  tempfiles <- list.files(mgf_path, pattern = "^expt|^theo", full.names = TRUE)
  
  if (length(tempfiles))
    unlink(tempfiles)
  
  mgf_files <- list.files(mgf_path, pattern = "^mgf_queries_.*\\.rds$", 
                          full.names = TRUE)
  mgfs <- lapply(mgf_files, qs::qread)
  
  # data thinning for MGF calibrations
  if (first_search) {
    mgfs <- lapply(mgfs, function (x) {
      if ((fct <- ceiling(nrow(x)/50000L)) == 1L)
        return(x)
      
      min_mgfmass <- min(x$ms1_mass, na.rm = TRUE)
      max_mgfmass <- max(x$ms1_mass, na.rm = TRUE)
      oks_min <- with(x, ms1_mass <= min_mgfmass + 10L)
      oks_max <- with(x, ms1_mass >= max_mgfmass - 10L)
      
      mgfa <- x[oks_max, ]
      mgfb <- x[oks_min, ]
      mgfc <- x[!(oks_max | oks_min), ]
      rows <- (1:nrow(mgfc)) %% fct == 1L
      dplyr::bind_rows(mgfa, mgfc[rows, ], mgfb)
    })
  }
  
  mgfs <- dplyr::bind_rows(mgfs)
  notches <- seq_along(ms1_offsets)
  
  # need additional handling of mzML with list(NULL) entries
  # setting the default to "mzML" to reinforce list(NULL) handling
  data_type <- if (file.exists(fi <- file.path(mgf_path, "data_type.rds")))
    qs::qread(fi)
  else
    "mzML"

  mapply(hpair_mgths, ms1_offsets, notches, 
         MoreArgs = list(
           mgfs = mgfs, n_modules = n_modules, 
           mgf_path = mgf_path, quant = quant, min_mass = min_mass, 
           max_mass = max_mass, ppm_ms1_bin = ppm_ms1_bin, 
           .path_bin = .path_bin, data_type = data_type), 
         SIMPLIFY = FALSE, USE.NAMES = FALSE)
  
  qs::qsave(data.frame(ms1_offset = ms1_offsets, notch = notches), 
            file.path(mgf_path, "notches.rds"))

  invisible(NULL)
}


#' Helper of \link{pair_mgftheos}.
#'
#' @param ms1_offset The ms1 offset.
#' @param notch The index assigned to an ms1_offset.
#' @param mgfs MGF data.
#' @param data_type The type of peak lists in one of raw, mzML or mgf. The
#'   argument is used to handle list(NULL) at an mzML format.
#' @inheritParams pair_mgftheos
hpair_mgths <- function (ms1_offset = 0, notch = NULL, mgfs, n_modules, 
                         mgf_path, quant = "none", 
                         min_mass = 200L, max_mass = 4500L, ppm_ms1_bin = 10L, 
                         .path_bin, data_type = "mzML")
{
  if (abs(ms1_offset) > 1e-4) {
    mgfs <- if (ms1_offset > 0)
      mgfs[with(mgfs, ms1_mass <= max_mass - ms1_offset), ]
    else
      mgfs[with(mgfs, ms1_mass >= min_mass - ms1_offset), ]

    mgfs[["ms1_mass"]] <- mgfs[["ms1_mass"]] - ms1_offset
  }
  
  mgfs[["pep_ms1_offset"]] <- ms1_offset
  
  if (is.atomic(mgfs[1, "ms1_charge", drop = TRUE])) {
    ms1_bins <- ceiling(log(mgfs[["ms1_mass"]]/min_mass)/log(1+ppm_ms1_bin/1e6))
    ms1_bins <- as.integer(ms1_bins)
    mgfs <- split(mgfs, ms1_bins)
  }
  else {
    # temporarily drop apex_scan_num...
    mgfs <- make_dia_mgfs(mgfs = mgfs, mgf_path = mgf_path, quant = quant, 
                          min_mass = min_mass, ppm_ms1_bin = ppm_ms1_bin, 
                          data_type = data_type)
    mgfs <- mgfs[names(mgfs) != "-Inf"] # unknown precursors
  }

  # to chunks: each chunk has multiple frames: each frame multiple precursors
  ranges <- seq_along(mgfs)
  
  n_chunks <- if (n_modules == 1L)
    min(detect_cores(96L)^2, 1024L)
  else if (n_modules >= 96L)
    min(length(ranges), length(mgf_files) * n_modules * 2L)
  else
    min(length(ranges), length(mgf_files) * n_modules)
  
  labs <- levels(cut(ranges, n_chunks))
  lwrs <- floor(as.numeric( sub("\\((.+),.*", "\\1", labs)))
  grps <- findInterval(ranges, lwrs)
  mgfs <- split(mgfs, grps)
  rm(list = c("ranges", "labs", "lwrs", "grps"))

  # (1) splits `theos` in accordance to `mgfs` with
  #     preceding and following frames: (o)|range of mgfs[[1]]|(o)
  mfrs <- lapply(mgfs, function (x) as.integer(names(x)))
  mins <- lapply(mfrs, function (x) if (length(x)) min(x, na.rm = TRUE) else 0L)
  mins <- .Internal(unlist(mins, recursive = FALSE, use.names = FALSE))
  maxs <- lapply(mfrs, function (x) if (length(x)) max(x, na.rm = TRUE) else 0L)
  maxs <- .Internal(unlist(maxs, recursive = FALSE, use.names = FALSE))
  
  anstheo <- vector("list", n_modules)
  
  for (i in seq_len(n_modules)) {
    theos <- 
      qs::qread(file.path(.path_bin, paste0("binned_theopeps_", i, ".rds")))
    
    if (is.null(theos))
      next
    
    thfrs <- as.integer(names(theos))
    
    # separates into intervals (intersecting mgfs)
    anstheo[[i]] <- mapply(function (x, y) {
      theos[which(thfrs >= (x - 1L) & thfrs <= (y + 1L))]
    }, mins, maxs, SIMPLIFY = FALSE, USE.NAMES = FALSE)
  }
  # rm(list = c("theos", "mfrs", "thfrs", "mins", "maxs"))
  
  # (2) removes mgfs[[i]] not found in any anstheo[[i]]
  for (i in seq_along(mgfs)) {
    mi <- mgfs[[i]]
    fi <- names(mi)
    ti <- lapply(anstheo, `[[`, i) # theos at chunk[[i]] (for all modules)
    
    # expt frames found in (any) theo module
    oks <- lapply(ti, function (x) fi %in% names(x))
    oks <- Reduce(`|`, oks)
    mgfs[[i]] <- mi[oks]
  }
  # rm(list = c("mi", "ti", "fi", "oks"))
  
  if (length(mgfs) == 1L && !length(mgfs[[1]]))
    mgfs[1] <- list(NULL)

  # (3) removes unused frames of `anstheo`
  # (mgfs determines the length of each anstheo[[i]]; 
  #  more effective to first generate all bracketed mgfs indexes and apply
  #  the same set of indexes to each anstheo[[i]])
  for (i in seq_along(anstheo))
    anstheo[[i]] <- mapply(subset_theoframes, mgfs, anstheo[[i]], 
                           SIMPLIFY = FALSE, USE.NAMES = FALSE)
  
  # (4) reverses the order (longer/heavier peptides towards the beginning)
  #     do the difficult ones first when paralleling with LB
  ord <- rev(seq_along(anstheo[[1]]))
  mgfs <- mgfs[ord]
  anstheo <- lapply(anstheo, function (x) x[ord])
  
  # (5) outputs (in chunks)
  qs::qsave(mgfs, 
            file.path(mgf_path, paste0("expt_", 0, "_", notch, ".rds")), 
            preset = "fast")
  
  for (i in seq_len(n_modules))
    qs::qsave(anstheo[[i]], 
              file.path(mgf_path, paste0("theo_", i, "_", notch, ".rds")), 
              preset = "fast")

  # next version: note that mgfs are the same for different modules
  # also save by fractions -> avoid sendData in parallel by read from disk

  invisible(NULL)
}


#' Makes DIA MGFs
#' 
#' Replicates MS2 data by the multiplicity of precursor masses.
#' 
#' @param mgfs MGF data.
#' @param data_type The type of peak lists in one of raw, mzML or mgf. The
#'   argument is used to handle list(NULL) at an mzML format.
#' @inheritParams pair_mgftheos
make_dia_mgfs <- function (mgfs, mgf_path, quant = "none", min_mass = 200L, 
                           ppm_ms1_bin = 10L, data_type = "mzML")
{
  mgfs$apex_scan_num <- mgfs$ms_level <- mgfs$demux <- NULL
  
  col_nms  <- names(mgfs)
  cols2a <- c("ms2_moverzs", "ms2_ints", "ms2_charges")
  cols2b <- c("rptr_moverzs", "rptr_ints")
  
  if (!"scan_num" %in% col_nms)
    stop("Column `scan_num` not found in peaklist. Contact the developer.")

  lapply(cols2a, function (x) {
    if (!x %in% col_nms) 
      stop("Column \"", x, "\" not found. Contact developer.")
  })
  
  if (grepl("^tmt.*\\d+", quant)) {
    lapply(cols2b, function (x) {
      if (!x %in% col_nms) 
        stop("Column \"", x, "\" not found. Contact developer.")
    })
    
    cols_ms2 <- c(cols2a, cols2b)
  }
  else {
    cols_ms2 <- cols2a
  }
  
  # separate MS2 columns
  # cols_ms2 <- c("ms2_moverzs", "ms2_ints", "ms2_charges", "rptr_moverzs", "rptr_ints")
  # cols_ms2 <- cols_ms2[cols_ms2 %in% col_nms]
  data_ms2 <- mgfs[, cols_ms2, drop = FALSE]
  
  if (!ncol(data_ms2)) 
    stop("MS2 information not found in peaklist. Contact the developer.")
  
  mgfs <- mgfs[, -which(names(mgfs) %in% cols_ms2), drop = FALSE]
  
  # separate flat and list columns
  col_nms <- names(mgfs)
  cols_list <- col_nms[unlist(lapply(mgfs, is.list))]
  cols_flat <- col_nms[!col_nms %in% cols_list]

  # list columns
  datalist <- mgfs[, cols_list, drop = FALSE]
  
  if (data_type == "mzML") {
    for (i in 1:ncol(datalist)) {
      di <- datalist[[i]]
      lens <- lengths(di)
      bads <- .Internal(which(lens == 0L))
      
      if (length(bads)) {
        na_type <- switch(
          typeof(di[[1]]), 
          double = NA_real_, 
          integer = NA_integer_,
          NA_real_)
        
        di[bads] <- list(na_type)
        datalist[[i]] <- di
      }
    }
    
    rm(list = c("di", "lens", "bads"))
  }

  datalist <- lapply(datalist, unlist, use.names = FALSE, recursive = FALSE)
  datalist <- dplyr::bind_cols(datalist)
  
  # flat columns
  lens <- lengths(mgfs$ms1_charge)
  seqs <- rep(seq_along(lens), lens)
  dataflat <- mgfs[, cols_flat, drop = FALSE]
  dataflat <- dataflat[seqs, ]
  
  scans <- mapply(function (x, y) {
    if (y > 1L) paste0(x, ".", seq_len(y)) else x
  }, mgfs$scan_num, lens)
  dataflat$scan_num <- unlist(scans)
  
  data_ms2 <- data_ms2[seqs, ]
  mgfs <- dplyr::bind_cols(datalist, dataflat, data_ms2)

  ord <- order(mgfs$ms1_mass)
  mgfs <- mgfs[ord, ]
  ms1_bins <- ceiling(log(mgfs$ms1_mass/min_mass)/log(1+ppm_ms1_bin/1e6))
  ms1_bins <- as.integer(ms1_bins)
  
  # ms1_bins can be -Inf or NA since
  # (1) ms1_moverz can be NA because not yet determined by the current algorithm
  # (2) ms1_mass can also be NA due to ms1_charge being NA
  # (3) ms1_charge can be zero since undetermined
  mgfs <- split(mgfs, ms1_bins)
}


#' Helper: matches between theoretical and experimental MS2 ions.
#'
#' @param expts Numeric vector; one series of experimental MS2s.
#' @param theos Numeric vector; one to multiple series of theoretical MS2s.
#' @param ex Converted expts as integers.
#' @param d ppm_ms2 divided by 1E6.
#' @inheritParams matchMS
#' @inheritParams load_mgfs
#' @importFrom purrr map
#' @importFrom fastmatch fmatch %fin%
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' ## Experimental 322.18704 fit to both b- and y- ions
#' #  (one expt to multiple theos)
#' expts <- c(101.07140,102.05540,107.04956,110.07165,111.07500,
#'            112.08729,113.07130,115.08693,116.07092,120.08105,
#'            121.08428,126.12794,127.12494,127.13121,128.12825,
#'            128.13452,129.13164,129.13789,130.06493,130.09772,
#'            130.13495,130.14124,131.13831,132.14160,134.07635,
#'            136.07573,157.10826,158.09238,159.09117,170.12067,
#'            173.12846,173.14980,175.11896,176.12245,176.15956,
#'            184.11806,186.15303,188.15977,190.09743,193.63914,
#'            207.11292,210.12289,229.16670,230.17030,231.17410,
#'            235.10779,240.14383,248.18073,262.15305,265.67874,
#'            273.21210,285.13416,301.20700,305.16055,312.17740,
#'            314.69138,322.18704,365.23856,369.24496,371.70316,
#'            374.18283,376.27573,392.19308,393.23337,394.23743,
#'            399.20920,400.27567,400.72501,401.22650,401.27139,
#'            401.58405,401.72778,409.21918,410.22241,423.24564,
#'            433.29709,452.27066,462.25473,480.26578,481.26828,
#'            498.27670,530.35126,572.28278,573.28625,599.33899,
#'            600.34039,609.32202,626.29218,627.29303,627.33948,
#'            628.33417,629.30463,630.30219,643.31946,644.31763,
#'            644.35913,645.32520,646.32880,647.32825,648.32892)
#'
#' theos <- c(114.0913,251.1503,322.1874,423.2350,480.2565,
#'            627.3249,783.4260,175.1190,322.1874,379.2088,
#'            480.2565,551.2936,688.3525,801.4366)
#' 
#' ppm_ms2 <- 25L
#' min_ms2mass <- 115L
#' 
#' d <- ppm_ms2/1E6
#' ex <- ceiling(log(expts/min_ms2mass)/log(1+d))
#' 
#' pep <- "PEPTIDE"
#' nms <- unlist(stringr::str_split(pep, ""))
#'
#' names(theos) <- c(nms, rev(nms))
#' theos <- list(`0000000` = theos)
#'
#' x1 <- mzion:::find_ms2_bypep(theos, expts, ex, d)
#'
#' ## Both expts 74953 and 74955 fit to theos 74954
#' #  (multiple expts to one theo)
#' pep <- "DIAVEEDLSSTPLFKDLLALMR"
#' nms <- unlist(stringr::str_split(pep, ""))
#'
#' theos <- c(158.0448,271.1288,342.1660,441.2344,570.2770,699.3196,
#'            814.3465,927.4306,1094.4289,1181.4610,1282.5086,1379.5614,
#'            1492.6455,1639.7139,1996.9718,2111.9987,2225.0828,2338.1668,
#'            2409.2040,2522.2880,2653.3285,2809.4296,175.1190,306.1594,
#'            419.2435,490.2806,603.3647,716.4487,831.4757,1188.7336,
#'            1335.8020,1448.8861,1545.9388,1646.9865,1734.0185,1901.0169,
#'            2014.1010,2129.1279,2258.1705,2387.2131,2486.2815,2557.3186,
#'            2670.4027,2785.4296)
#' names(theos) <- c(nms, rev(nms))
#' theos <- list(`0000000070000000000000 (1)` = theos)
#'
#' expts <- c(126.12768, 127.13107, 128.12868, 128.13484, 130.13541,
#'            130.14117, 136.07610, 167.08173, 178.27960, 228.13425,
#'            230.17053, 238.11922, 248.18092, 256.12946, 257.12473,
#'            276.10172, 278.15823, 283.14044, 321.21228, 327.13010,
#'            358.71371, 368.22955, 376.27615, 394.73138, 396.15076,
#'            396.22488, 400.27673, 407.24142, 414.16251, 426.76105,
#'            445.29724, 447.31360, 458.76022, 486.28998, 490.79019,
#'            491.29218, 500.26715, 514.27716, 516.33514, 522.78906,
#'            523.28961, 528.33496, 535.27863, 543.27417, 549.31561,
#'            572.32416, 572.39752, 572.82666, 576.35638, 603.31360,
#'            603.36700, 604.36945, 619.36670, 631.30743, 632.30969,
#'            641.41919, 642.42230, 646.36780, 647.36938, 658.36029,
#'            675.03418, 675.36835, 681.03772, 681.37146, 690.27856,
#'            701.34332, 707.45813, 707.69342, 708.02728, 716.41888,
#'            716.45227, 726.35089, 726.85413, 760.40997, 787.48865,
#'            788.45386, 789.45624, 796.44757, 813.47363, 814.47614,
#'            815.48041, 874.51715, 906.91064, 907.41144, 916.51337,
#'            918.38928, 919.39429, 926.55829, 953.56543, 971.57239,
#'            972.57562, 1031.47534, 1044.57398, 1069.55029, 1085.45569,
#'            1143.64014, 1144.64404, 1214.67590, 1321.77869, 1322.78186)
#' 
#' ppm_ms2 <- 25L
#' min_ms2mass <- 115L
#' 
#' d <- ppm_ms2/1E6
#' ex <- ceiling(log(expts/min_ms2mass)/log(1+d))
#' 
#' x2 <- mzion:::find_ms2_bypep(theos, expts, ex, d)
#' 
#' ## Experimental 317.20001 & 317.19315 match to theoreitcal 317.2022 & 317.1932;
#' #  experimental 959.48468 is also multiple dipping
#' #  (multiple to multiple)
#' aas <- unlist(strsplit("SLAAEEEAAR", ""))
#' theos <- c(317.2022, 430.2863, 501.3234, 572.3605, 701.4031, 
#'            830.4457, 959.4883, 1030.5254, 1101.5625, 1257.6636, 
#'            175.1190, 246.1561, 317.1932, 446.2358, 575.2784, 
#'            704.3210, 775.3581, 846.3952, 959.4793, 1046.5113)
#' names(theos) <- c(aas, rev(aas))
#' theos <- list(`0000000000` = theos)
#' 
#' expts <- c(102.05550, 110.07173, 112.08743, 114.06662, 115.08708, 116.07106, 
#'            120.08112, 126.12806, 127.12510, 127.13136, 128.12843, 128.13467, 
#'            129.13181, 129.13805, 130.13509, 130.14134, 131.13843, 132.14159, 
#'            133.04318, 136.07600, 143.08151, 157.10843, 158.09259, 173.14983, 
#'            175.11917, 176.15997, 186.15306, 188.15982, 201.08725, 229.12970, 
#'            230.17041, 231.17366, 241.08228, 246.15643, 248.18086, 255.17380, 
#'            259.09235, 289.20801, 300.16696, 315.25952, 317.19315, 317.20001, 
#'            343.25476, 351.20572, 367.22961, 376.27621, 402.29141, 430.28644,
#'            438.26654, 446.23587, 501.32376, 502.32788, 523.34491, 537.33649, 
#'            556.83990, 557.34125, 557.84283, 572.36127, 575.27863, 590.31671, 
#'            605.84045, 629.33453, 637.86853, 638.33740, 638.83984, 661.35687, 
#'            667.39923, 673.40417, 701.40350, 702.40936, 770.42517, 775.35840, 
#'            776.37720, 802.44659, 830.44556, 831.44958, 846.39349, 847.39465, 
#'            931.49158, 932.48187, 933.48218, 954.54474, 955.54791, 957.55493, 
#'            958.55646, 959.48468, 960.48773, 1030.52563, 1046.50830, 1047.50684, 
#'            1100.53101, 1101.54858, 1103.53040, 1116.59692, 1117.54749, 
#'            1118.54334, 1119.54565, 1120.55347, 1121.55408, 1122.55737)
#' 
#' ppm_ms2 <- 13L
#' min_ms2mass <- 115L
#' d <- ppm_ms2/1E6
#' ex <- ceiling(log(expts/min_ms2mass)/log(1+d))
#' 
#' x3 <- mzion:::find_ms2_bypep(theos, expts, ex, d)
#' 
#' ## 7 b-ions and 9 y-bios 
#' #  (an even total, n_ps matched but identities off)
#' theos <- c(344.2131,504.2438,617.3278,732.3548,845.4389,946.4865,
#'            1003.5080,1102.5764,1258.6775,175.1190,274.1874,331.2088,
#'            432.2565,545.3406,660.3675,773.4516,933.4822,1047.5252)
#' names(theos) <- c("N","C","I","D","I","T","G","V","R",
#'                   "R","V","G","T","I","D","I","C","N")
#' theos <- list(`000000000` = theos)
#' 
#' expts <- c(115.08701,116.07098,120.08125,126.12807,127.12508,127.13135,
#'            128.12840,128.13467,129.10252,129.13177,129.13803,130.09766,
#'            130.13507,130.14136,131.13843,136.07590,142.09769,157.09749,
#'            157.10825,158.09258,173.14984,175.11916,175.15634,176.15977,
#'            186.15321,188.15988,215.13939,230.17043,231.17412,247.19698,
#'            248.18083,254.16139,255.14516,257.16092,272.17194,273.21265,
#'            295.17020,314.18243,316.21832,331.21051,331.21661,344.21338,
#'            345.19727,376.27597,377.27975,389.14813,400.27567,415.22980,
#'            432.25732,445.25986,458.28168,462.25909,473.74744,476.24893,
#'            491.30301,497.73514,501.31610,504.24396,506.24860,520.24512,
#'            545.34082,546.34387,584.76740,588.35773,589.32990,606.37183,
#'            616.83417,617.32935,629.88574,630.33142,638.32935,638.38837,
#'            638.84747,638.89111,639.34772,639.39099,660.36957,672.38916,
#'            715.32959,717.40179,732.35510,733.35760,773.45404,845.43958,
#'            900.49872,901.49738,902.42206,933.48560,946.48560,1003.50885,
#'            1047.52295,1102.53992,1104.54358,1118.53979,1118.65076,
#'            1119.55566,1120.54919,1121.56397,1122.56702,1123.57056)
#' 
#' ppm_ms2 <- 13L
#' min_ms2mass <- 115L
#' d <- ppm_ms2/1E6
#' ex <- ceiling(log(expts/min_ms2mass)/log(1+d))
#' 
#' x4 <- mzion:::find_ms2_bypep(theos, expts, ex, d)
#' 
#' 
#' ## fewer matches with "find_ppm_outer_bycombi" and check minn_ms2 again
#' #  (doesn't really return NULL since now with "ppm_ms2 * 2")
#' pep <- "EFINSLRLYR"
#' nms <- unlist(stringr::str_split(pep, ""))
#' 
#' theos <- c(359.2128,506.2812,619.3653,734.3922,821.4243,934.5083,1090.6094,
#'            1203.6935,1366.7568,1522.8579,175.1190,338.1823,451.2663,607.3675,
#'            720.4515,807.4835,922.5105,1035.5946,1182.6630,1311.7056)
#' 
#' names(theos) <- c(nms, rev(nms))
#' theos <- list(`0005000000` = theos)
#' 
#' expts <- c(126.12811,127.12556,127.13139,128.12862,128.13455,129.13194,
#'            129.13786,130.13542,130.14139,131.13852,136.07597,173.14980,
#'            175.11916,175.15663,176.15979,186.15309,188.15987,215.13940,
#'            227.10303,230.17044,231.17381,247.19708,248.18105,249.18443,
#'            273.21262,316.21869,344.21350,345.19760,345.21689,353.19775,
#'            358.22925,364.14948,376.27615,377.27942,397.20880,479.28204,
#'            480.28650,507.27704,507.31665,508.28040,508.31964,550.31934,
#'            578.31403,579.31818,601.33063,602.33466,620.40070,621.40363,
#'            679.36194,680.40875,680.90851,690.32965,707.35663,708.35950,
#'            721.44830,722.45142,736.94965,761.93817,762.43274,762.93304,
#'            770.79028,770.94440,771.44598,786.48285,786.98523,792.44543,
#'            820.44061,821.44318,834.53247,835.53638,877.45514,893.49561,
#'            903.47803,904.48071,921.48846,922.49133,945.56488,963.57489,
#'            964.57990,1006.57715,1016.55975,1017.56122,1034.60925,1035.57776,
#'            1035.61169,1165.61340,1166.61731,1197.67346,1198.67700,1311.71948,
#'            1312.72559,1366.73694,1368.74927,1369.74463,1382.75659,1383.75610,
#'            1384.75915,1385.76355,1386.76611,1387.76599)
#' 
#' ppm_ms2 <- 13L
#' min_ms2mass <- 115L
#' d <- ppm_ms2/1E6
#' ex <- ceiling(log(expts/min_ms2mass)/log(1+d))
#' 
#' x5 <- mzion:::find_ms2_bypep(theos, expts, ex, d, ppm_ms2)
#' }
#' 
#' @return Lists of (1) theo, (2) expt, (3) ith, (4) iex and (5) m.
find_ms2_bypep <- function (theos = NULL, expts = NULL, ex = NULL, d = NULL, 
                            ppm_ms2 = 10L, min_ms2mass = 115L, minn_ms2 = 6L) 
{
  # `theos`
  #   the same pep_seq at different applicable ivmods and NLs
  # 
  # length(theos) may be greater than one with site permutation and/or NLs.
  # 
  # `theos` may be empty: 
  #   e.g. the matched one is after `maxn_vmods_sitescombi_per_pep` 
  #   and never get matched.
  # 
  # ex: `expts` in integers
  # thi: the i-th `theos` in integers
  # 
  # ex has no duplicated entries; 
  # thi can.
  # 
  # Forward matching: match(theos, expts)
  # (i) allowed, e.g., b4- and y5 theo ions matched to the same ex value: 
  #   match(c(2,2,3,4), c(1:2, 5:10))
  # (ii) multiple ex' value's to the same thi value not allowed; 
  #   otherwise longer length `c(expts[bps], expts[yps])` than lhs.
  #   e.g. ex's 74953, 74955 both fit to thi 74954 and the best one is applied.
  #   (after a thi is matched, it will be removed from further matching)
  # 
  # Backward matching: match(expts, theos)
  # (i) %in% and %fin% only shows the first match for duplicated entries thi:
  #   match(1:4, c(1, 2, 2, 5))
  #   (so no worry about thi duplication)

  nullout <- list(theo = NULL, expt = NULL, ith = NULL, iex = NULL, m = NULL)
  len <- length(theos)
  
  if (!len) 
    return(nullout)
  
  out <- vector("list", len)
  
  if (len > 3L) {
    mths  <- index_mz(.Internal(unlist(theos, recursive = FALSE, use.names = FALSE)), 
                      min_ms2mass, d)
    tines <- mths %fin% ex | (mths - 1L) %fin% ex | (mths + 1L) %fin% ex
    tines <- fold_vec(tines, len)
    mths  <- fold_vec(mths, len)
    iths  <- lapply(tines, function (x) .Internal(which(x)))
    
    for (i in 1:len) {
      theoi <- theos[[i]]
      thi   <- mths[[i]]
      tine  <- tines[[i]]
      ith   <- iths[[i]]
      nth   <- length(ith)
      
      if (nth >= minn_ms2) {
        es <- theoi
        es[!tine] <- NA_real_
        
        thok <- thi[ith]
        tine2 <- fastmatch::fmatch(c(thok, thok - 1L, thok + 1L), ex)
        iex <- vector("integer", nth)
        
        for (j in 1:nth) {
          x <- tine2[[j]]
          
          if (is.na(x)) {
            y <- tine2[[j+nth]]
            
            if (is.na(y)) {
              iex[[j]] <- tine2[[j+nth*2]] 
            } else {
              iex[[j]] <- y
            }
          } else {
            iex[[j]] <- x
          }
        }
        
        nex <- length(iex)
        
        # should not occur?
        if (nth != nex) {
          # "* 2" for three-frame searches
          # also ensure that "ith = ith" in ascending order, not "iex = iex"
          out_i <- find_ppm_outer_bycombi(expts, theoi, ppm_ms2 * 2L)
          
          if (sum(!is.na(out_i[["expt"]])) < minn_ms2) {
            out[[i]] <- nullout
            next
          }
          
          out[[i]] <- out_i
          next
        }
        
        es[tine] <- expts[iex]
        out[[i]] <- list(theo = theoi, expt = es, ith = ith, iex = iex, m = nex)
      } 
      else
        out[[i]] <- nullout
    }
  }
  else {
    for (i in 1:len) {
      theoi <- theos[[i]]
      thi <- index_mz(theoi, min_ms2mass, d)
      t2e <- fastmatch::fmatch(c(thi, thi - 1L, thi + 1L), ex, nomatch = 0L)
      nth <- sum(t2e > 0L)
      
      if (nth >= minn_ms2) {
        l  <- length(thi)
        mi <- t2e[1:l]
        bf <- t2e[(l + 1L):(l + l)]
        af <- t2e[(l + l + 1L):(l + l + l)]
        
        okmi <- mi > 0L
        okbf <- bf > 0L
        okaf <- af > 0L
        
        ith <- c(.Internal(which(okmi)), .Internal(which(okbf)), .Internal(which(okaf)))
        iex <- c(mi[okmi], bf[okbf], af[okaf])
        
        es <- rep_len(NA_real_, l)
        es[ith] <- expts[iex]
        names(es) <- names(theoi)
        out[[i]] <- list(theo = theoi, expt = es, ith = ith, iex = iex, m = nth)
      } 
      else {
        out[[i]] <- nullout
      }
    }
  }
  
  names(out) <- names(theos)
  out
}


#' Matches an MGF query
#'
#' @param expt_mass_ms1 Numeric; the experimental MS1 mass.
#' @param expt_moverz_ms2 A numeric list; the experimental MS2 m/z's.
#' @param exptcharges_ms2 A list of integers; the charge states of MS2 m/z's.
#'   Values are \code{NULL} at \code{deisotope_ms2 = FALSE}.
#' @param theomasses_ms1 Numeric vector; the theoretical MS1 masses at the
#'   preceding \code{-1}, the current and the following \code{+1} frames.
#' @param theomasses_ms2 Numeric vector; the theoretical MS2 m/z's at the
#'   preceding \code{-1}, the current and the following \code{+1} frames.
#' @param pep_mod_groups The index(es) of peptide modification groups.
#' @inheritParams matchMS
#' @inheritParams load_mgfs
#' @inheritParams pair_mgftheos
#' @examples
#' \donttest{
#' library(mzion)
#' library(fastmatch)
#'
#' expt_ms2 <-
#'   c(1628,3179,7677,9129,13950,14640,18571,19201,19205,19830,19833,20454,
#'     20457,21030,21073,21077,21687,24644,25232,37146,42042,43910,43920,44811,
#'     44824,45298,47494,55080,55901,56677,59014,66693,72396,72402,72720,73043,
#'     82411,91067,91838,93101,95572,98301,98665,100270,102081,102305,102744,106013,
#'     107998,108102,113713,113898,115045,115140,117669,119131,120730,123859,124029,124200,
#'     126199,126208,126610,126693,126775,128157,129447,129603,132396,135402,135475,138158,
#'     140397,141566,141634,141702,142183,142580,144189,147799,147926,148678,148860,149911,
#'     149973,153047,155607,158520,158631,162612,162717,163346,169537,170401,171249,171344,
#'     178012,178620,181980,188455)
#'
#' theo_ms2 <-
#'   c(-26231,62754,105787,129278,151731,161552,174924,184489,196534,204867,212917,219771,
#'     236270,106013,129447,148679,163242,178619,187776,197630,203310,212976,219825,227451,
#'     234026,237018)
#' cr <- which(expt_ms2 %fin% theo_ms2)
#' pr <- which((expt_ms2-1) %fin% theo_ms2)
#' af <- which((expt_ms2+1) %fin% theo_ms2)
#' c(cr, pr, af)
#'
#' }
search_mgf <- function (expt_mass_ms1 = NULL, expt_moverz_ms2 = NULL, 
                        exptcharges_ms2 = NULL, theomasses_ms1 = NULL, 
                        theomasses_ms2 = NULL, pep_mod_groups = NULL, 
                        minn_ms2 = 6L, ppm_ms1 = 10L, ppm_ms2 = 10L, 
                        min_ms2mass = 115L)
{
  # don't flip the order of cdn1 & cdn2: FALSE & NA -> FALSE; TRUE & NA <- NA
  if (!is.null(exptcharges_ms2))
    expt_moverz_ms2[(!is.na(exptcharges_ms2)) & (exptcharges_ms2 > 1L)] <- NA_real_

  # --- find MS2 matches ---
  d2 <- ppm_ms2/1E6
  ex <- index_mz(expt_moverz_ms2, min_ms2mass, d2)

  # lapply by the same pep_seq at different ivmods and/or NLs
  ans <- if (length(theomasses_ms2)) 
    lapply(theomasses_ms2, find_ms2_bypep, 
           expts = expt_moverz_ms2, 
           ex = ex, 
           d = d2, 
           ppm_ms2 = ppm_ms2, 
           min_ms2mass = min_ms2mass, 
           minn_ms2 = minn_ms2)
  else 
    theomasses_ms2
  
  ## Not faster
  # if (is.null(.Internal(unlist(ans, recursive = TRUE, use.names = FALSE)))) return(list())
  
  ## cleans up
  # (1) within a list: removes vmods+ positions that are NULL (< minn_ms2)
  # (no effects on vmods-; need `type` info if to limit to vmods+)
  oks <- lapply(ans, function (this) {
    oks <- lapply(this, function (x) !is.null(x[["theo"]]))
    .Internal(unlist(oks, recursive = FALSE, use.names = FALSE))
  })
  
  # (lapply loses names by `[[` whereas map2 reserves names when available)
  ans <- mapply(function (x, y) x[y], ans, oks, SIMPLIFY = FALSE, USE.NAMES = TRUE)
  
  # (2)  removes empty lists
  oks2 <- lengths(ans, use.names = FALSE) > 0L
  ans <- ans[oks2]
  theomasses_ms1 <- theomasses_ms1[oks2]

  mapply(
    function (x, y, g) {
      attr(x, "theo_ms1") <- y
      attr(x, "pep_mod_group") <- g
      x
    }, 
    ans, theomasses_ms1, pep_mod_groups, 
    SIMPLIFY = FALSE,
    USE.NAMES = TRUE)
  
  # ---
  # `length(ans) == N(theos_peps)` within the ppm window
  # 
  # ATIPIFFDMMLCEYQR
  # (1) ATIPIFFDMMLCEYQR$`0000000050000000`
  #   A tibble: 6 x 2
  #   theo  expt
  #   <dbl> <dbl>
  #     1  173.  173.
  #     2  175.  175.
  # (2) ATIPIFFDMMLCEYQR$`0000000005000000`
  #   A tibble: 6 x 2
  #   theo  expt
  #   <dbl> <dbl>
  #     1  173.  173.
  #     2  175.  175.
  # $KADEQMESMTYSTER
  # ...
  
  ## No evidence of M
  # 
  # $ATIPIFFDMMLCEYQR
  # $ATIPIFFDMMLCEYQR$`0000000050000000`
  #   A tibble: 6 x 2
  #   theo  expt
  #   <dbl> <dbl>
  #   1  173.  173.
  #   2  175.  175.
  #   3  643.  643.
  #   4  790.  790.
  #   5  868.  868.
  #   6 1297. 1297.
  # 
  # $ATIPIFFDMMLCEYQR$`0000000005000000`
  #   A tibble: 6 x 2
  #   theo  expt
  #   <dbl> <dbl>
  #   1  173.  173.
  #   2  175.  175.
  #   3  643.  643.
  #   4  790.  790.
  #   5  868.  868.
  #   6 1297. 1297.
}


#' Matches experimentals and theoreticals
#'
#' For a single module
#'
#' @param pep_mod_group The index of peptide modification groups.
#' @param nms_expt Names of experimental files.
#' @param nms_theo Names of theoretical files.
#' @param aa_masses An amino-acid look-up.
#' @param FUN A function, e.g., \link{gen_ms2ions_base}, with an i-th module of
#'   \code{aa_masses}.
#' @param ms1vmods All possible labels of MS1 variable modifications with
#'   an i-th \code{aa_masses}.
#' @param ms2vmods All possible labels of MS2 variable modifications with
#'   an i-t \code{aa_masses}.
#' @param cl The value of clusters for parallel processes.
#' @param df0 An output template.
#' @param mod_indexes Integer; the indexes of fixed and/or variable
#'   modifications
#' @param df0 An output template with zero rows
hms2match_one <- function (pep_mod_group, nms_theo, nms_expt, aa_masses, FUN, 
                           ms1vmods, ms2vmods, cl, ms1_neulosses = NULL, 
                           maxn_neulosses_fnl = 1L, maxn_neulosses_vnl = 1L, 
                           deisotope_ms2 = TRUE, 
                           mod_indexes, mgf_path, out_path, type_ms2ions = "by", 
                           maxn_vmods_per_pep = 5L, maxn_sites_per_vmod = 3L, 
                           maxn_fnl_per_seq = 3L, maxn_vnl_per_seq = 3L, 
                           maxn_vmods_sitescombi_per_pep = 64L, 
                           minn_ms2 = 6L, ppm_ms1 = 10L, ppm_ms2 = 10L, 
                           min_ms2mass = 115L, df0 = NULL)
                           
{
  nm_fmods <- attr(aa_masses, "fmods", exact = TRUE)
  nm_vmods <- attr(aa_masses, "vmods", exact = TRUE)
  
  message("Matching against: ", 
          if (nchar(nm_vmods) == 0L) nm_fmods else paste0(nm_fmods, " | ", nm_vmods))
  
  # subset notches: c("Phospho (S)", "Phospho (T)", "Phospho (Y)")
  if (length(ms1_neulosses)) {
    if (length(vmods_nl <- attr(aa_masses, "vmods_nl", exact = TRUE))) {
      nls   <- extract_umods(ms1_neulosses)
      oksnl <- lapply(nls, function (x) length(x[["nl"]]) > 1L)
      nls   <- nls[unlist(oksnl)]

      if (length(nls) && any(oks <- names(nls) %in% names(vmods_nl))) {
        notches <- unique(unlist(lapply(nls[oks], `[[`, "nl")))
        notches <- -round(notches, digits = 4)
        
        df <- qs::qread(file.path(mgf_path, "notches.rds"))
        allowed <- df[with(df, ms1_offset %in% notches), ]$notch # at least one
        
        univ  <- as.integer(gsub("^theo_\\d+_(\\d+)\\.rds", "\\1", nms_theo))
        idxes <- univ %in% allowed
        
        nms_theo <- nms_theo[idxes] # at least length-1 of offset-0
        nms_expt <- nms_expt[idxes]
      }
      else {
        # Oxidation (M)
        nms_theo <- nms_theo[1]
        nms_expt <- nms_expt[1]
      }
    }
    else {
      # Deamidated (N)
      nms_theo <- nms_theo[1]
      nms_expt <- nms_expt[1]
    }
  }
  
  if ((len <- length(nms_theo)) == 1L) {
    df <- ms2match_one(
      nms_theo = nms_theo[[1]], 
      nms_expt = nms_expt[[1]], 
      pep_mod_group = pep_mod_group, aa_masses = aa_masses, FUN = FUN, 
      ms1vmods = ms1vmods, ms2vmods = ms2vmods, cl = cl, 
      mod_indexes = mod_indexes, mgf_path = mgf_path, out_path = out_path, 
      type_ms2ions = type_ms2ions, 
      maxn_vmods_per_pep = maxn_vmods_per_pep, 
      maxn_sites_per_vmod = maxn_sites_per_vmod, 
      maxn_fnl_per_seq = maxn_fnl_per_seq, 
      maxn_vnl_per_seq = maxn_vnl_per_seq, 
      deisotope_ms2 = deisotope_ms2, 
      maxn_vmods_sitescombi_per_pep = maxn_vmods_sitescombi_per_pep, 
      minn_ms2 = minn_ms2, ppm_ms1 = ppm_ms1, ppm_ms2 = ppm_ms2, 
      min_ms2mass = min_ms2mass, 
      df0 = df0)
  }
  else {
    df <- vector("list", len)
    
    df[[1]] <- ms2match_one(
      nms_theo = nms_theo[[1]], 
      nms_expt = nms_expt[[1]], 
      pep_mod_group = pep_mod_group, aa_masses = aa_masses, FUN = FUN, 
      ms1vmods = ms1vmods, ms2vmods = ms2vmods, cl = cl, 
      mod_indexes = mod_indexes, mgf_path = mgf_path, out_path = out_path, 
      type_ms2ions = type_ms2ions, 
      maxn_vmods_per_pep = maxn_vmods_per_pep, 
      maxn_sites_per_vmod = maxn_sites_per_vmod, 
      maxn_fnl_per_seq = maxn_fnl_per_seq, 
      maxn_vnl_per_seq = maxn_vnl_per_seq, 
      deisotope_ms2 = deisotope_ms2, 
      maxn_vmods_sitescombi_per_pep = maxn_vmods_sitescombi_per_pep, 
      minn_ms2 = minn_ms2, ppm_ms1 = ppm_ms1, ppm_ms2 = ppm_ms2, 
      min_ms2mass = min_ms2mass, 
      df0 = df0)
    
    # neutral losses: maxn_neulosses_vnl and maxn_neulosses_fnl
    for (i in 2:len) {
      df[[i]] <- ms2match_one(
        nms_theo = nms_theo[[i]], 
        nms_expt = nms_expt[[i]], 
        pep_mod_group = pep_mod_group, aa_masses = aa_masses, FUN = FUN, 
        ms1vmods = ms1vmods, ms2vmods = ms2vmods, cl = cl, 
        mod_indexes = mod_indexes, mgf_path = mgf_path, out_path = out_path, 
        type_ms2ions = type_ms2ions, 
        maxn_vmods_per_pep = maxn_vmods_per_pep, 
        maxn_sites_per_vmod = maxn_sites_per_vmod, 
        maxn_fnl_per_seq = maxn_neulosses_fnl, 
        maxn_vnl_per_seq = maxn_neulosses_vnl, 
        deisotope_ms2 = deisotope_ms2, 
        maxn_vmods_sitescombi_per_pep = maxn_vmods_sitescombi_per_pep, 
        minn_ms2 = minn_ms2, ppm_ms1 = ppm_ms1, ppm_ms2 = ppm_ms2, 
        min_ms2mass = min_ms2mass, 
        df0 = df0)
    }

    empties <- unlist(lapply(df, is.null))
    df <- df[!empties]
    df <- dplyr::bind_rows(df)
  }

  out_nm <- file.path(out_path, "temp", paste0("ion_matches_", pep_mod_group, ".rds"))
  
  if (is.null(df)) {
    qs::qsave(df, out_nm, preset = "fast")
    return(NULL)
  }
  
  df[["pep_fmod"]] <- nm_fmods
  df[["pep_vmod"]] <- nm_vmods
  df[["pep_mod_group"]] <- pep_mod_group
  
  df <- dplyr::rename(df, 
                      pep_ret_range = ret_time, 
                      pep_scan_title = scan_title,
                      pep_exp_mz = ms1_moverz, 
                      pep_n_ms2 = ms2_n, 
                      pep_exp_mr = ms1_mass, 
                      pep_tot_int = ms1_int, 
                      pep_scan_num = scan_num, 
                      pep_exp_z = ms1_charge, 
                      pep_ms2_moverzs = ms2_moverzs, 
                      pep_ms2_ints = ms2_ints, )
  # df[["pep_scan_num"]] <- as.character(df[["pep_scan_num"]])
  df <- reloc_col_after(df, "raw_file", "scan_num")
  df <- reloc_col_after(df, "pep_mod_group", "raw_file")
  qs::qsave(df, out_nm, preset = "fast")
}


#' Matches experimentals and theoreticals.
#'
#' For a single module and single notch.
#'
#' @param nms_expt Names of experimental files.
#' @param nms_theo Names of theoretical files.
#' @param pep_mod_group The index of peptide modification groups
#' @param aa_masses An amino-acid look-up
#' @param FUN A function, e.g., \link{gen_ms2ions_base}, with an i-th module of
#'   \code{aa_masses}
#' @param ms1vmods All possible labels of MS1 variable modifications with
#'   an i-th \code{aa_masses}
#' @param ms2vmods All possible labels of MS2 variable modifications with
#'   an i-t \code{aa_masses}
#' @param cl The value of clusters for parallel processes
#' @param mod_indexes Integer; the indexes of fixed and/or variable
#'   modifications
#' @param df0 An output template with zero rows
ms2match_one <- function (nms_theo, nms_expt, pep_mod_group, aa_masses, FUN, 
                          ms1vmods, ms2vmods, cl, 
                          mod_indexes, mgf_path, out_path, type_ms2ions = "by", 
                          maxn_vmods_per_pep = 5L, maxn_sites_per_vmod = 3L, 
                          maxn_fnl_per_seq = 3L, maxn_vnl_per_seq = 3L, 
                          deisotope_ms2 = TRUE, 
                          maxn_vmods_sitescombi_per_pep = 64L, 
                          minn_ms2 = 6L, ppm_ms1 = 10L, ppm_ms2 = 10L, 
                          min_ms2mass = 115L, 
                          df0 = NULL)
{
  out_name   <- gsub("^theo", "ion_matches", nms_theo)
  mgf_frames <- qs::qread(file.path(mgf_path, nms_expt))
  theopeps   <- qs::qread(file.path(mgf_path, nms_theo))

  len <- length(mgf_frames)
  
  # NULL or NULL list
  if ((!len) || (len == 1L && is.null(mgf_frames[[1]])))
    return(df0)

  ntmod    <- attr(aa_masses, "ntmod", exact = TRUE)
  ctmod    <- attr(aa_masses, "ctmod", exact = TRUE)
  ntmass   <- find_nterm_mass(aa_masses)
  ctmass   <- find_cterm_mass(aa_masses)
  fmods_nl <- attr(aa_masses, "fmods_nl", exact = TRUE)
  vmods_nl <- attr(aa_masses, "vmods_nl", exact = TRUE)
  amods    <- attr(aa_masses, "amods", exact = TRUE)
  
  fmods_nl <- if (length(fmods_nl)) fmods_nl else NULL
  vmods_nl <- if (length(vmods_nl)) vmods_nl else NULL
  amods    <- if (length(amods)) amods else NULL
  ms1vmods <- if (length(ms1vmods)) ms1vmods else NULL
  ms2vmods <- if (length(ms2vmods)) ms2vmods else NULL
  
  FUN  <- as.symbol(FUN)
  
  df <- parallel::clusterMap(
    cl, frames_adv, 
    mgf_frames, theopeps, 
    MoreArgs = list(aa_masses = aa_masses, 
                    ms1vmods = ms1vmods, 
                    ms2vmods = ms2vmods, 
                    ntmod = ntmod, 
                    ctmod = ctmod, 
                    ntmass = ntmass, 
                    ctmass = ctmass, 
                    amods = amods, 
                    vmods_nl = vmods_nl, 
                    fmods_nl = fmods_nl, 
                    pep_mod_group = pep_mod_group, 
                    mod_indexes = mod_indexes, 
                    type_ms2ions = type_ms2ions, 
                    maxn_vmods_per_pep = maxn_vmods_per_pep, 
                    maxn_sites_per_vmod = maxn_sites_per_vmod, 
                    maxn_fnl_per_seq = maxn_fnl_per_seq, 
                    maxn_vnl_per_seq = maxn_vnl_per_seq, 
                    deisotope_ms2 = deisotope_ms2, 
                    maxn_vmods_sitescombi_per_pep = maxn_vmods_sitescombi_per_pep, 
                    minn_ms2 = minn_ms2, 
                    ppm_ms1 = ppm_ms1, 
                    ppm_ms2 = ppm_ms2, 
                    min_ms2mass = min_ms2mass, 
                    FUN = FUN), 
    .scheduling = "dynamic")
  
  empties <- unlist(lapply(df, is.null))
  df <- df[!empties]
  df <- dplyr::bind_rows(df)
}


#' Frames advancement.
#'
#' (1) "amods- tmod- vnl- fnl-", (2) "amods- tmod+ vnl- fnl-"
#'
#' @param mgf_frames A group of mgf frames (from chunk splitting). A
#'   \code{mgf_frames[[i]]} contains one to multiple MGFs whose MS1 masses are
#'   in the same interval. The \code{mgf_frames} are ordered by increasing
#'   values in \code{frame} for progressive searches.
#' @param theopeps Binned theoretical peptides corresponding to an i-th
#'   \code{aa_masses}.
#' @param minn_ms2 Integer; the minimum number of MS2 ions for consideration as
#'   a hit.
#' @param ntmod The attribute \code{ntmod} from a \code{aa_masses}.
#' @param ctmod The attribute \code{ctmod} from a \code{aa_masses}.
#' @param ntmass The mass of a fixed or variable N-term modification.
#' @param ctmass The mass of a fixed or variable C-term modification.
#' @param amods \code{Anywhere} variable modifications.
#' @param fmods_nl The attribute of \code{fmods_nl} from an \code{aa_masses}.
#' @param vmods_nl The attribute of \code{vmods_nl} from an \code{aa_masses}.
#' @param ppm_ms1 The mass tolerance of MS1 species.
#' @param ppm_ms2 The mass tolerance of MS2 species.
#' @param FUN A function pointer to, e.g., \link{gen_ms2ions_base}.
#' @inheritParams matchMS
#' @inheritParams ms2match
#' @inheritParams hms2match_one
#' @return Matches to each MGF as a list elements. The length of the output is
#'   equal to the number of MGFs in the given frame.
frames_adv <- function (mgf_frames = NULL, theopeps = NULL, 
                        aa_masses = NULL, ms1vmods = NULL, ms2vmods = NULL, 
                        ntmod = NULL, ctmod = NULL, 
                        ntmass = NULL, ctmass = NULL, 
                        amods = NULL, vmods_nl = NULL, fmods_nl = NULL, 
                        pep_mod_group = NULL, mod_indexes = NULL, 
                        type_ms2ions = "by", 
                        maxn_vmods_per_pep = 5L, maxn_sites_per_vmod = 3L, 
                        maxn_fnl_per_seq = 3L, maxn_vnl_per_seq = 3L, 
                        deisotope_ms2 = TRUE, 
                        maxn_vmods_sitescombi_per_pep = 64L, 
                        minn_ms2 = 6L, ppm_ms1 = 10L, ppm_ms2 = 10L, 
                        min_ms2mass = 115L, FUN)
{
  len <- length(mgf_frames)
  
  if (!len)
    return(NULL)
  
  frames <- as.integer(names(mgf_frames))
  out <- vector("list", len) 
  
  ## --- initiation ---
  mgfs_cr <- mgf_frames[[1]]
  frame <- frames[1]
  
  bfi <- 1L
  thbf <- theopeps[[bfi]] 
  thbf_peps <- thbf[["pep_seq"]]
  thbf_masses <- thbf[["mass"]]
  
  cri <- bfi + 1L
  thcr <- theopeps[[cri]]
  thcr_peps <- thcr[["pep_seq"]]
  thcr_masses <- thcr[["mass"]]
  
  # generate both target and decoy MS2
  thbf_ms2s <- mapply(
    FUN, 
    aa_seq = thbf_peps, 
    ms1_mass = thbf_masses, 
    MoreArgs = list(
      aa_masses = aa_masses, 
      ms1vmods = ms1vmods, 
      ms2vmods = ms2vmods, 
      ntmod = ntmod, 
      ctmod = ctmod, 
      ntmass = ntmass, 
      ctmass = ctmass, 
      amods = amods, vmods_nl = vmods_nl, fmods_nl = fmods_nl, 
      mod_indexes = mod_indexes, 
      type_ms2ions = type_ms2ions, 
      maxn_vmods_per_pep = maxn_vmods_per_pep, 
      maxn_sites_per_vmod = maxn_sites_per_vmod, 
      maxn_fnl_per_seq = maxn_fnl_per_seq, 
      maxn_vnl_per_seq = maxn_vnl_per_seq, 
      maxn_vmods_sitescombi_per_pep = maxn_vmods_sitescombi_per_pep
    ), 
    SIMPLIFY = FALSE,
    USE.NAMES = FALSE
  )
  # temporarily share peptide names between targets and decoys; 
  # later is.na(pep_ivmod) -> decoys -> add "-" to prot_acc -> reverse sequence
  names(thbf_ms2s) <- thbf_peps
  
  thcr_ms2s <- mapply(
    FUN, 
    aa_seq = thcr_peps, 
    ms1_mass = thcr_masses, 
    MoreArgs = list(
      aa_masses = aa_masses, 
      ms1vmods = ms1vmods, 
      ms2vmods = ms2vmods, 
      ntmod = ntmod, 
      ctmod = ctmod, 
      ntmass = ntmass, 
      ctmass = ctmass, 
      amods = amods, vmods_nl = vmods_nl, fmods_nl = fmods_nl, 
      mod_indexes = mod_indexes, 
      type_ms2ions = type_ms2ions, 
      maxn_vmods_per_pep = maxn_vmods_per_pep, 
      maxn_sites_per_vmod = maxn_sites_per_vmod, 
      maxn_fnl_per_seq = maxn_fnl_per_seq, 
      maxn_vnl_per_seq = maxn_vnl_per_seq, 
      maxn_vmods_sitescombi_per_pep = maxn_vmods_sitescombi_per_pep
    ), 
    SIMPLIFY = FALSE,
    USE.NAMES = FALSE
  )
  names(thcr_ms2s) <- thcr_peps
  
  ## --- iteration ---
  for (i in seq_len(len)) {
    exptmasses_ms1  <- mgfs_cr$ms1_mass
    exptmoverzs_ms2 <- mgfs_cr$ms2_moverzs
    exptcharges_ms2 <- mgfs_cr$ms2_charges
    
    ### Slower to subset + passed as argument 
    #   compared to direct calculation at ~ 4us
    # 
    # exptimoverzs_ms2 <- mgfs_cr$ms2_imoverzs
    ###
    
    afi <- cri + 1L
    thaf <- theopeps[[afi]]
    thaf_peps <- thaf[["pep_seq"]]
    thaf_masses <- thaf[["mass"]]
    
    thaf_ms2s <- mapply(
      FUN, 
      aa_seq = thaf_peps, 
      ms1_mass = thaf_masses, 
      MoreArgs = list(
        aa_masses = aa_masses, 
        ms1vmods = ms1vmods, 
        ms2vmods = ms2vmods, 
        ntmod = ntmod, ctmod = ctmod, 
        ntmass = ntmass, 
        ctmass = ctmass, 
        amods = amods, vmods_nl = vmods_nl, fmods_nl = fmods_nl, 
        mod_indexes = mod_indexes, 
        type_ms2ions = type_ms2ions, 
        maxn_vmods_per_pep = maxn_vmods_per_pep, 
        maxn_sites_per_vmod = maxn_sites_per_vmod, 
        maxn_fnl_per_seq = maxn_fnl_per_seq, 
        maxn_vnl_per_seq = maxn_vnl_per_seq, 
        maxn_vmods_sitescombi_per_pep = maxn_vmods_sitescombi_per_pep
      ), 
      SIMPLIFY = FALSE,
      USE.NAMES = FALSE
    )
    names(thaf_ms2s) <- thaf_peps
    
    # each `out` for the results of multiple mgfs in one frame
    out[[i]] <- mapply(
      search_mgf, 
      expt_mass_ms1 = exptmasses_ms1, 
      expt_moverz_ms2 = exptmoverzs_ms2, 
      exptcharges_ms2 = exptcharges_ms2, 
      MoreArgs = list(
        pep_mod_groups = pep_mod_group, 
        theomasses_ms1 = c(thbf_masses, thcr_masses, thaf_masses), 
        theomasses_ms2 = c(thbf_ms2s, thcr_ms2s, thaf_ms2s), 
        minn_ms2 = minn_ms2, 
        ppm_ms1 = ppm_ms1, 
        ppm_ms2 = ppm_ms2, 
        min_ms2mass = min_ms2mass), 
      SIMPLIFY = FALSE,
      USE.NAMES = FALSE
    )
    
    if (i == len) 
      break
    
    # advance to the next frame
    mgfs_cr <- mgf_frames[[i+1]]
    new_frame <- frames[i+1L]
    
    if (isTRUE(new_frame == (frame + 1L))) {
      cri <- cri + 1L
      
      thbf <- thcr
      thbf_masses <- thcr_masses
      thbf_ms2s <- thcr_ms2s
      
      thcr <- thaf
      thcr_masses <- thaf_masses
      thcr_ms2s <- thaf_ms2s
    } 
    else if (isTRUE(new_frame == (frame + 2L))) {
      cri <- cri + 2L
      
      thbf <- thaf
      thbf_masses <- thaf_masses
      thbf_ms2s <- thaf_ms2s
      
      thcr <- theopeps[[cri]]
      thcr_peps <- thcr[["pep_seq"]]
      thcr_masses <- thcr[["mass"]]
      
      thcr_ms2s <- mapply(
        FUN, 
        aa_seq = thcr_peps, 
        ms1_mass = thcr_masses, 
        MoreArgs = list(
          aa_masses = aa_masses, 
          ms1vmods = ms1vmods, 
          ms2vmods = ms2vmods, 
          ntmod = ntmod, ctmod = ctmod, 
          ntmass = ntmass, 
          ctmass = ctmass, 
          amods = amods, vmods_nl = vmods_nl, fmods_nl = fmods_nl, 
          mod_indexes = mod_indexes, 
          type_ms2ions = type_ms2ions, 
          maxn_vmods_per_pep = maxn_vmods_per_pep, 
          maxn_sites_per_vmod = maxn_sites_per_vmod, 
          maxn_fnl_per_seq = maxn_fnl_per_seq, 
          maxn_vnl_per_seq = maxn_vnl_per_seq, 
          maxn_vmods_sitescombi_per_pep = maxn_vmods_sitescombi_per_pep
        ), 
        SIMPLIFY = FALSE,
        USE.NAMES = FALSE
      )
      names(thcr_ms2s) <- thcr_peps
    } 
    else {
      cri <- cri + 3L
      bfi <- cri - 1L
      
      thbf <- theopeps[[bfi]]
      thbf_peps <- thbf[["pep_seq"]]
      thbf_masses <- thbf[["mass"]]
      
      thcr <- theopeps[[cri]]
      thcr_peps <- thcr[["pep_seq"]]
      thcr_masses <- thcr[["mass"]]
      
      thbf_ms2s <- mapply(
        FUN, 
        aa_seq = thbf_peps, 
        ms1_mass = thbf_masses, 
        MoreArgs = list(
          aa_masses = aa_masses, 
          ms1vmods = ms1vmods, 
          ms2vmods = ms2vmods, 
          ntmod = ntmod, ctmod = ctmod, 
          ntmass = ntmass, 
          ctmass = ctmass, 
          amods = amods, vmods_nl = vmods_nl, fmods_nl = fmods_nl, 
          mod_indexes = mod_indexes, 
          type_ms2ions = type_ms2ions, 
          maxn_vmods_per_pep = maxn_vmods_per_pep, 
          maxn_sites_per_vmod = maxn_sites_per_vmod, 
          maxn_fnl_per_seq = maxn_fnl_per_seq, 
          maxn_vnl_per_seq = maxn_vnl_per_seq, 
          maxn_vmods_sitescombi_per_pep = maxn_vmods_sitescombi_per_pep
        ), 
        SIMPLIFY = FALSE,
        USE.NAMES = FALSE
      )
      names(thbf_ms2s) <- thbf_peps
      
      thcr_ms2s <- mapply(
        FUN, 
        aa_seq = thcr_peps, 
        ms1_mass = thcr_masses, 
        MoreArgs = list(
          aa_masses = aa_masses, 
          ms1vmods = ms1vmods, 
          ms2vmods = ms2vmods, 
          ntmod = ntmod, ctmod = ctmod, 
          ntmass = ntmass, 
          ctmass = ctmass, 
          amods = amods, vmods_nl = vmods_nl, fmods_nl = fmods_nl, 
          mod_indexes = mod_indexes, 
          type_ms2ions = type_ms2ions, 
          maxn_vmods_per_pep = maxn_vmods_per_pep, 
          maxn_sites_per_vmod = maxn_sites_per_vmod, 
          maxn_fnl_per_seq = maxn_fnl_per_seq, 
          maxn_vnl_per_seq = maxn_vnl_per_seq, 
          maxn_vmods_sitescombi_per_pep = maxn_vmods_sitescombi_per_pep
        ), 
        SIMPLIFY = FALSE,
        USE.NAMES = FALSE
      )
      names(thcr_ms2s) <- thcr_peps
    }
    
    frame <- new_frame
  }
  
  out <- post_frame_adv(out, mgf_frames)
}


#' Reads Thermo RAW files.
#' 
#' @param mgf_path A file path RAW MS files.
#' @param filelist A list of RAW MS files.
readRAW <- function (mgf_path = NULL, filelist = NULL) 
{
  sys_path <- system.file("extdata", package = "mzion")
  acceptMSFileReaderLicense(sys_path)
  
  temp_dir <- create_dir(file.path(mgf_path, "temp_dir"))
  
  local({
    fn_suffix <- tolower(gsub("^.*\\.([^.]*)$", "\\1", filelist[[1]]))
    
    if (fn_suffix == "raw") {
      data_format <- "Thermo-RAW"
      mgf_format <- "Mzion"
    }
    
    qs::qsave(list(data_format = data_format, mgf_format = mgf_format), 
              file.path(mgf_path, "info_format.rds"), preset = "fast")
  })
  
  len <- length(filelist)
  n_cores <- min(len, detect_cores(32L))
  
  if (n_cores == 1L) {
    filenames <- lapply(filelist, proc_raws, mgf_path, temp_dir)
  }
  else {
    cl <- parallel::makeCluster(getOption("cl.cores", n_cores))
    filenames <- parallel::clusterApply(cl, filelist, proc_raws, mgf_path, temp_dir)
    parallel::stopCluster(cl)
  }
  
  filenames
}


#' Helper in processing MGF entries in chunks.
#'
#' @param raw_file The file name of RAW MS data.
#' @param mgf_path The file path of MGF files.
#' @param temp_dir A file path for temporary files. 
proc_raws <- function (raw_file, mgf_path, temp_dir) 
{
  options(digits = 9L)
  
  filepeak <- exeReadRAW(raw_file, mgf_path)
  pathfile <- file.path(mgf_path, filepeak)
  lines <- readLines(pathfile)
  # DON'T; see the help document; memory allocation or access error
  # lines <- stringi::stri_read_lines(pathfile)

  idx_scans <- .Internal(which(stringi::stri_cmp_eq(lines, "SCAN")))
  scan_nums <- lines[idx_scans + 1L]
  ret_times <- as.numeric(lines[idx_scans + 3L]) * 60
  ms_levels <- as.integer(lines[idx_scans + 5L]) # 0 at exception
  iso_ctrs <- as.numeric(lines[idx_scans + 7L]) # 0 if MS1
  iso_widths <- as.numeric(lines[idx_scans + 9L]) # large values if MS1
  msx_ns <- as.integer(lines[idx_scans + 11L])
  
  msx_moverzs <- mapply(
    function (s, n) 
      as.numeric(
        stringi::stri_split_fixed(s, pattern = ",", n = n, simplify = TRUE)), 
    lines[idx_scans + 13L], msx_ns, 
    SIMPLIFY = TRUE, USE.NAMES = FALSE)
  
  msx_ints <- mapply(
    function (s, n) 
      as.numeric(
        stringi::stri_split_fixed(s, pattern = ",", n = n, simplify = TRUE)), 
    lines[idx_scans + 15L], msx_ns, 
    SIMPLIFY = TRUE, USE.NAMES = FALSE)
  
  scan_titles <- lines[idx_scans + 17L]
  half_widths <- iso_widths / 2
  iso_lwrs <- iso_ctrs - half_widths
  iso_uprs <- iso_ctrs + half_widths
  
  len <- length(msx_moverzs)
  na_ints <- rep_len(NA_integer_, len)
  na_reals <- rep_len(NA_real_, len)
  
  out <- list(
    msx_moverzs = msx_moverzs, 
    msx_ints = msx_ints, 
    msx_ns = msx_ns,
    ms1_moverzs = na_reals, 
    ms1_charges = na_ints, 
    ms1_ints = na_reals, 
    
    scan_title = scan_titles,
    raw_file = raw_file, # scalar
    ms_level = ms_levels, 
    ret_time = ret_times, 
    scan_num = as.integer(scan_nums), 
    orig_scan = scan_nums,
    iso_ctr = as.numeric(iso_ctrs), 
    iso_lwr = as.numeric(iso_lwrs), 
    iso_upr = as.numeric(iso_uprs)
  )
  
  out_name <- paste0(raw_file, ".rds")
  qs::qsave(out, file.path(temp_dir, out_name), preset = "fast")
  
  idx_first_ms1 <- which(ms_levels == 1L)[[1]]
  iso_ctr1 <- iso_ctrs[[idx_first_ms1]]
  attr(out_name, "is_dia") <- if (iso_ctr1 < 0) TRUE else FALSE
  attr(out_name, "mzml_type") <- "raw"
  
  invisible(out_name)
}


#' Helper in executing CSharp-compiled ReadRAW.exe
#' 
#' Requires mono for Linux or Mac OS.
#' 
#' @param raw_file A RAW file name.
#' @param mgf_path A file path RAW MS files.
exeReadRAW <- function(raw_file, mgf_path)
{
  sys_path <- system.file("extdata", package = "mzion")
  exe <- file.path(sys_path, name_exe = "ReadRAW.exe")
  mono <- if (Sys.info()['sysname'] %in% c("Darwin", "Linux")) TRUE else FALSE
  
  peaks  <- tempfile(tmpdir = mgf_path, fileext = ".peaks")
  stdout <- tempfile(tmpdir = mgf_path, fileext = ".stdout")
  stderr <- tempfile(tmpdir = mgf_path, fileext = ".stderr" )
  raw_full <- file.path(mgf_path, raw_file)
  
  if (mono) {
    rvs <- system2(Sys.which("mono"), 
                   args = c(shQuote(exe),
                            shQuote(raw_full),
                            shQuote(peaks)),
                   stdout = stdout,
                   stderr = stderr)
  }
  else{
    rvs <- system2(exe, 
                   args = c(shQuote(raw_full), 
                            shQuote(peaks)), 
                   stdout = stdout,
                   stderr = stderr)
  }
  
  if (rvs || !file.exists(peaks)) {
    stop("Fail to process ", raw_file, ".")
  }
  
  out_name <- paste0(gsub("\\.[^.]*$", "", raw_file), ".peaks")
  file.rename(peaks, file.path(mgf_path, out_name))
  unlink(c(stdout, stderr))
  
  out_name
}


#' License agreement.
#' 
#' @param sys_path The system path of Mzion.
acceptMSFileReaderLicense <- function(sys_path) 
{
  license  <- file.path(sys_path, name_exe = "RawFileReaderLicense.txt")
  libdir <- create_dir(tools::R_user_dir("mzion", which = 'cache'))

  if (file.exists(file.path(libdir, "rspn.txt")))
    return(TRUE)
  
  msg <- "By selecting YES, you are accepting the Thermo's License agreement."
  file.show(license)
  response <- readline(prompt = sprintf("Accept '%s'? [y/n]: ", license))
  
  if (tolower(response) != "y")
    stop("Need to accept the license agreement for processing Thermo's RAW.")
  
  rspnFile <- file.path(libdir, "rspn.txt")
  fileConn <- file(rspnFile)
  writeLines(paste(msg, paste0(date()), "Response = TRUE", sep = "\n"), fileConn)
  close(fileConn)
  
  NULL
}


#' An integrated facility for searches of mass spectrometry data.
#'
#' Database searches of MS/MS data (DDA).
#'
#' @section \code{Output columns}: \code{system.file("extdata",
#'   "column_keys.txt", package = "mzion")} \cr
#'
#' @section \code{Notes}: The annotation of protein attributes, including
#'   percent coverage, will be performed with \link[proteoQ]{normPSM} given that
#'   values will be affected with the combination of multiple PSM tables.
#'
#'   The search is a two-way match: (a) a forward matching of theoretical values
#'   to experiment ones and (b) a backward matching of the experimental values
#'   to the theoretical ones. This allows the establishment of one-to-one
#'   correspondences between experiments and theoreticals. The correspondences
#'   are made available to users in files of \code{ion_matches_1.rds...} (nested
#'   form) and \code{list_table_1.rds...} etc. (flat form). To open the files,
#'   use \code{qs::qread(...)}. A more self-contained output can be made
#'   available at the TRUE of \code{add_ms2theos}, \code{add_ms2theos2},
#'   \code{add_ms2moverzs} and \code{add_ms2ints}.
#'
#'   When there is no evidence to distinguish, e.g. distinct primary sequences
#'   of \code{P[EMPTY]EPTIDE} and \code{P[MTYPE]EPTIDE}, both will be reported
#'   by \code{mzion} and further kept by proteoQ. For peptides under the same
#'   primary sequence, the redundancy in the positions and/or neutral losses of
#'   \code{Anywhere} variable modifications are also kept in the outputs of
#'   \code{mzion} but removed with proteoQ.
#'
#' @param out_path A file path of outputs.
#' @param mgf_path A file path to a list of MGF files. The experimenter needs to
#'   supply the files.
#'
#'   The supported MGFs are in the formats of (1) MSConvert against \code{.raw}
#'   from Thermo's Orbitrap or \code{.d} from Bruker's timsTOF Pro, (2) Thermo's
#'   Proteome Discoverer or (3) Bruker's DataAnalysis.
#'
#'   With MSConvert, the default \code{titleMaker} is required for correct
#'   parsing (don't think it can be altered by users, but just in case).
#' @param fasta Character string(s) to the name(s) of fasta file(s) with
#'   prepended directory path. The experimenter needs to supply the files.
#' @param acc_type Character string(s); the types of protein accessions in one
#'   of c("uniprot_acc", "uniprot_id", "refseq_acc", "other"). For custom names,
#'   the corresponding regular expressions need to be supplied via argument
#'   \code{acc_pattern}.
#' @param acc_pattern Regular expression(s) describing the patterns in
#'   separating the header lines of fasta entries. At the \code{NULL} default,
#'   the pattern will be automated when \code{acc_type} are among
#'   c("uniprot_acc", "uniprot_id", "refseq_acc", "other"). See also
#'   \link{load_fasta2} for custom examples.
#' @param fixedmods Character string(s) of fixed modifications.
#'
#' @param varmods Character string(s) of variable modifications. Multiple
#'   modifications to the same residue are allowed, for example, both
#'   \code{Carbamyl (M)} and \code{Oxidation (M)}.
#'
#'   For both \code{fixedmods} and \code{varmods}, the modification title,
#'   \code{TMT6plex}, applies to all of TMT-6, TMT-10, TMT-11. It is also
#'   possible to use aliased: (1) \code{TMT10plex} for TMT-10 and
#'   \code{TMT11plex} for TMT-11 and (2) \code{TMT16plex} for TMTpro. See also
#'   \link{parse_unimod} for grammars of modification \code{title},
#'   \code{position} and \code{site}.
#' @param rm_dup_term_anywhere Logical; if TRUE, removes combinations in
#'   variable modifications with site(s) in positions of both terminal and
#'   anywhere, e.g., "Gln->pyro-Glu (N-term = Q)" and "Deamidated (Q).
#' @param fixedlabs Character string(s) of fixed isotopic labels. See examples
#'   of SILAC for details. Can be but not typically used in standard alone
#'   searches of labeled residues.
#' @param varlabs Character string(s) of variable isotopic labels. See examples
#'   of SILAC for details. Can be but not typically used in standard alone
#'   searches of labeled residues.
#' @param locmods Among \code{varmods} for the consideration of localization
#'   probabilities; for instance, \code{locmods = NULL} for nothing,
#'   \code{locmods = c("Phospho (S)", "Phospho (T)", "Phospho (Y)")} for
#'   phosphopeptides, \code{locmods = "Acetyl (K)"} for lysine acetylation.
#'   \code{fixedmods} that were coerced to \code{varmods} will be added
#'   automatically to \code{locmods}.
#'
#'   For convenience, the default is set to look for applicable peptide
#'   phosphorylation (and may encounter warning messages if the data type is
#'   different to the default).
#' @param mod_motifs The motifs to restrict \code{Anywhere} variable
#'   modification. For example, provided the \code{Anywhere} variable
#'   modifications containing \code{c("Oxidation (M)", "Deamidated (N)")} and
#'   \code{mod_motifs = list(`Deamidated (N)` = c("NG", "NM"), `Oxidation (M)` =
#'   c("NM", "MP"))},
#'   variable modifications will only be considered at sites that satisfy the
#'   motifs.
#' @param enzyme A character string; the proteolytic specificity of the assumed
#'   enzyme will be used to generate peptide sequences from protein entries. The
#'   default is \code{Trypsin_P}. See also parameter \code{custom_enzyme}.
#'
#' @param custom_enzyme Regular expression(s) for custom enzyme specificity. The
#'   default is NULL. Uses of custom enzyme specificity is probably rather
#'   infrequent. Should there be such need, the argument \code{enzyme} will be
#'   ignored and the following may be applied:
#'
#'   \cr ## Examples \cr \cr # Equivalent to Trypsin \cr # at the Cterm of K or
#'   R but not followed by P \cr # (the quantifiers "\{1\}" can be skipped at a
#'   small cost of speed) \cr custom_enzyme = c(Cterm =
#'   "([KR]\{1\})([^P]\{1\})")
#'
#'   \cr # GluN again \cr custom_enzyme = c(Nterm = "([E]\{1\})")
#'
#'   \cr # Trypsin_P + GluN \cr custom_enzyme = c(Cterm = "([KR]\{1\})", Nterm =
#'   "([E]\{1\})")
#'
#'   \cr # Faked: Trypsin, proline not allowed on neither Nterm or Cterm \cr
#'   custom_enzyme = c(Cterm = "([KR]\{1\})([^P]\{1\})", Nterm =
#'   "([^P]\{1\})([KR]\{1\})")
#'
#' @param nes_fdr_group A character string in one of \code{c("all",
#'   "all_cterm_tryptic", "all_cterm_nontryptic", "base", "base_cterm_tryptic",
#'   "base_cterm_nontryptic")}. All peptides will be used in the classifications
#'   of targets and decoys at \code{"all"}. Peptides with the chemistry of
#'   C-terminal K or R will be used at \code{"all_cterm_tryptic"} (peptides from
#'   protein C-terminals being excluded). Peptides without C-terminal K or R
#'   will be used at \code{"all_cterm_nontryptic"}. The same applied to
#'   \code{"base_cterm_tryptic"} and \code{"base_cterm_nontryptic"} with the
#'   difference of only peptides from the \code{base} group being used. See also
#'   parameter \code{fdr_group}.
#' @param noenzyme_maxn Non-negative integer; the maximum number of peptide
#'   lengths for sectional searches at \code{noenzyme} specificity. The argument
#'   may be used to guard against RAM exhaustion. At the zero default, The
#'   peptide lengths from \code{min_len} to \code{max_len} will be broken
#'   automatically into continuous sections. At value 1, searches will be
#'   performed against individual peptide lengths; at value 2, two adjacent
#'   lengths will be taken at a time, etc.
#' @param maxn_fasta_seqs A positive integer; the maximum number of protein
#'   sequences in fasta files. The default is 200000.
#' @param maxn_vmods_setscombi A non-negative integer; the maximum number of
#'   sets of combinatorial variable modifications. The default is 512.
#' @param maxn_vmods_per_pep A non-negative integer; the maximum number of
#'   \code{Anywhere} (non-terminal) variable modifications per peptide. The
#'   default is 5.
#' @param maxn_sites_per_vmod A non-negative integer; the maximum number of
#'   combinatorial \code{Anywhere} (non-terminal) variable modifications per
#'   site in a peptide sequence. The default is 3.
#'
#'   For instance, variable modifications of \code{Carbamyl (M)} and
#'   \code{Oxidation (M)} both have site \code{M}. In order to have a
#'   combination of two \code{Carbamyl (M)} and two \code{Oxidation (M)} being
#'   considered, the value of \code{maxn_sites_per_vmod} needs to be four or
#'   greater.
#' @param maxn_fnl_per_seq A non-negative integer; the maximum number of
#'   permutative neutral losses per peptide sequence for fixed modifications. To
#'   bypass the combinatorial of neutral losses, set \code{maxn_fnl_per_seq = 1}
#'   or \code{0}.
#' @param maxn_vnl_per_seq A non-negative integer; the maximum number of
#'   permutative neutral losses per peptide sequence for variable modifications.
#'   To bypass the combinatorial of neutral losses, set \code{maxn_vnl_per_seq =
#'   1} or \code{0}.
#' @param maxn_vmods_sitescombi_per_pep A non-negative integer; the maximum
#'   number of combinatorial variable modifications per peptide sequence (per
#'   module). The ways include the permutations in neutral losses and
#'   modifications (e.g., \code{Acetyl (K) and TMT (K)}).
#' @param min_len A positive integer; the minimum length of peptide sequences
#'   for considerations. Shorter peptides will be excluded. The default is 7.
#' @param max_len A positive integer; the maximum length of peptide sequences
#'   for considerations. Longer peptides will be excluded. The default is 40.
#' @param max_miss A non-negative integer; the maximum number of mis-cleavages
#'   per peptide sequence for considerations. The default is 2.
#' @param min_mass A positive integer; the minimum precursor mass for
#'   interrogation. The default is an arbitrarily low value (the primary guard
#'   against low molecular-weight precursors is \code{min_len}).
#' @param max_mass A positive integer; the maximum precursor mass for
#'   interrogation.
#' @param min_ms2mass A positive integer; the minimum MS2 mass for
#'   interrogation. The default is 110.
#' @param max_ms2mass A positive integer; the maximum MS2 mass for
#'   interrogation.
#' @param n_13c Number(s) of 13C off-sets in precursor masses, for example, over
#'   the range of \code{-1:2}. The default is 0.
#' @param ms1_notches A numeric vector; notches (off-sets) in precursor masses,
#'   e.g., \code{c(-97.976896)} to account fo the loss of a phosphoric acid in
#'   precursor masses.
#' @param ms1_neulosses Character string(s) specifying the neutral losses of
#'   precursors. The nomenclature is the same as those in argument
#'   \code{varmods}, e.g., \code{c("Phospho (S)", "Phospho (T)", "Phospho
#'   (Y)")}.
#'
#'   The argument is a simplified (narrower) usage of argument
#'   \code{ms1_notches} with additional specificity in modifications and sites.
#' @param maxn_neulosses_fnl A positive integer used in conjunction with
#'   arguments \code{ms1_notches} and \code{ms1_neulosses}. The maximum number
#'   of fixed MS2 neutral losses to be considered when searching against peak
#'   lists with MS1 mass off-sets. The default is two (one MS2 neutral loss in
#'   addition to 0).
#' @param maxn_neulosses_vnl A positive integer used in conjunction with
#'   arguments \code{ms1_notches} and \code{ms1_neulosses}. The maximum number
#'   of variable MS2 neutral losses to be considered when searching against peak
#'   lists with MS1 mass off-sets. The default is two (one MS2 neutral loss in
#'   addition to 0).
#' @param par_groups A low-priority feature. Parameter(s) of \code{matchMS}
#'   multiplied by sets of values in groups. Multiple searches will be performed
#'   separately against the parameter groups. For instance with one set of
#'   samples in SILAC light and the other in SILAC heavy, the experimenters may
#'   specify two arguments for parameter \code{mgf_path} and two arguments for
#'   parameter \code{fixedmods} that link to the respective samples. In this
#'   way, there is no need to search against, e.g. heavy-isotope-labeled K8R10
#'   with the light samples and vice versa. Note that results will be combined
#'   at the end, with the group names indicated under column \code{pep_group}.
#'   The default is NULL without grouped searches. See the examples under SILAC
#'   and Group searches.
#' @param silac_mix A list of labels indicating SILAC groups in samples. The
#'   parameter is most relevant for SILAC experiments where peptides of heavy,
#'   light etc. were \emph{mixed} into one sample. The default is NULL
#'   indicating a none mixed-SILAC experiment. See also the examples under
#'   SILAC.
#' @param type_ms2ions Character; the type of
#'   \href{http://www.matrixscience.com/help/fragmentation_help.html}{ MS2
#'   ions}. Values are in one of "by", "ax" and "cz". The default is "by" for b-
#'   and y-ions.
#' @param deisotope_ms2 Logical; if TRUE, de-isotope MS2 features.
#' @param max_ms2_charge Maximum charge states for consideration with MS2
#'   deisotoping.
#' @param use_defpeaks Depreciated. Logical; if TRUE, uses MS1 m-over-z's,
#'   intensities and charge states pre-calculated by other peak-picking
#'   algorithms.
#' @param maxn_dia_precurs Maximum number of DIA precursors.
#' @param n_dia_ms2bins Allowance in adjacent DIA-MS2 bins for retention time
#'   alignment with a DIA-MS1.
#' @param n_dia_scans Allowance in the number of adjacent MS scans for
#'   constructing a peak profile and thus for determining the apex scan number
#'   of an moverz value along LC.
#' @param topn_dia_ms2ions Top-N DIA-MS2 features (for deisotoping). For
#'   example, 100 features per Th of isolation window (2400 for an isolation
#'   windown of 24Th).
#' @param delayed_diams2_tracing Logical; if TRUE, delays the tracing of MS1-MS2
#'   after ion matches.
#' @param maxn_mdda_precurs Maximum number of precursors for consideration in a
#'   multi-precursor DDA scan. Note that at \code{maxn_mdda_precurs = 1}, it is
#'   equivalent to DDA with precursor re-deisotoping. At \code{maxn_mdda_precurs
#'   = 0}, it is equivalent to DDA using the original monoisotopic masses and
#'   charge states provided by a peak-picking algorithm (e.g., MSConvert).
#' @param n_mdda_flanks The number of preceding and following MS1 scans for
#'   consideration when averaging isotope envelops of precursors.
#' @param ppm_ms1_deisotope Mass error tolerance in MS1 deisotoping.
#' @param ppm_ms2_deisotope Mass error tolerance in MS2 deisotoping.
#' @param grad_isotope Positive numeric; the gradient threshold between two
#'   adjacent peaks in an isotopic envelop. The smaller the value, the more
#'   stringent it is in calling an adjacent peak being a mono-isotopic
#'   precursor.
#' @param fct_iso2 A multiplication factor for the fuzzy discrimination of a
#'   secondary precursor in parallel to a primary precursor in an isotopic
#'   envelop. The smaller the value, the more stringent it is in calling an
#'   adjacent peak being a mono-isotopic precursor
#' @param topn_ms2ions A positive integer; the top-n species for uses in MS2 ion
#'   searches.
#' @param topn_ms2ion_cuts Advanced feature. Either \code{NA} or a named vector.
#'   For instance, at \code{topn_ms2ions = 100} and \code{topn_ms2ion_cuts =
#'   c(`1000` = 90, `1100` = 5, `4500` = 5)}, the maximum number of MS2 peaks
#'   that can be used is \eqn{90} at \eqn{m/z \le 1000}, \eqn{5} at \eqn{1000 <
#'   m/z < 1100} and \code{5} at \eqn{m/z > 1100}. The trailing \code{`4500` =
#'   5} can be skipped.
#'
#'   To exclude MS2 features such as at \eqn{m/z > 4500}: \code{topn_ms2ion_cuts
#'   = c(`4500` = 100)}.
#'
#'   It is also possible to make a zone of voids. For instance, features at
#'   \eqn{1200 < m/z < 1250} can be excluded at \code{topn_ms2ion_cuts =
#'   c(`1000` = 90, `1200` = 5, `1250` = 0)}.
#'
#'   The default is \code{NA} where \code{topn_ms2ions} are picked uniformly
#'   across the entire m/z range.
#' @param minn_ms2 A positive integer; the minimum number of matched MS2 ions
#'   for consideration as a hit. Counts of secondary ions, e.g. b0, b* etc., are
#'   not part of the threshold.
#' @param exclude_reporter_region Logical; if TRUE, excludes MS2 ions in the
#'   region of TMT reporter ions. The default is FALSE. The corresponding range
#'   of TMT reporter ions is informed by \code{tmt_reporter_lower} and
#'   \code{tmt_reporter_upper}. The argument affects only TMT data.
#' @param tmt_reporter_lower The lower bound of the region of TMT reporter ions.
#'   The default is \eqn{126.1}.
#' @param tmt_reporter_upper The upper bound of the region of TMT reporter ions.
#'   The default is \eqn{135.2}.
#' @param min_ms1_charge A positive integer; the minimum MS1 charge state for
#'   considerations. The default is 2.
#' @param max_ms1_charge A positive integer; the maximum MS1 charge state for
#'   considerations. The default is 6.
#' @param min_scan_num Depreciated. A positive integer; the minimum scan number
#'   for considerations. The default is 1. The setting only applies to MGFs with
#'   numeric scan numbers. For example, it has no effects on Bruker's timsTOF
#'   data.
#' @param max_scan_num Depreciated. A positive integer; the maximum scan number
#'   for considerations. The default is the maximum machine integer. The setting
#'   only applies to MGFs with numeric scan numbers.
#' @param min_ret_time A non-negative numeric; the minimum retention time in
#'   seconds for considerations. The default is 0.
#' @param max_ret_time Numeric; the maximum retention time in seconds for
#'   considerations. The default is \code{Inf}. At a negative value, e.g. -800,
#'   data in the last 800s of LC retention time will be excluded.
#' @param ppm_ms1 A positive integer; the mass tolerance of MS1 species. The
#'   default is 20.
#' @param ppm_ms2 A positive integer; the mass tolerance of MS2 species. The
#'   default is 20.
#' @param calib_ms1mass Logical; if TRUE, calibrates precursor masses.
#' @param ppm_reporters A positive integer; the mass tolerance of MS2 reporter
#'   ions. The default is 10.
#' @param ppm_ms1calib A positive integer; the mass tolerance of MS1 species for
#'   precursor mass calibration. The argument has no effect at
#'   \code{calib_ms1mass = FALSE}.
#' @param quant A character string; the quantitation method. The default is
#'   "none". Additional choices include \code{tmt6, tmt10, tmt11, tmt16 and
#'   tmt18}. For other multiplicities of \code{tmt}, use the compatible higher
#'   plexes. For example, apply \code{tmt16} for \code{tmt12} provided a set of
#'   12-plexes being constructed from a 16-plex TMTpro \eqn{(7 * 13C + 2 *
#'   15N)}. It is also possible that an experimenter may construct a
#'   \code{tmt12} from a 18-plex TMTpro \eqn{(8 *13C + 1 * 15N)} where
#'   \code{quant = tmt18} is suitable.
#' @param use_lfq_intensity Logical; if TRUE, replace spectrum-centric precursor
#'   intensities with peptide-centric intensities in DDA-MS. Require mzML data
#'   format. The feature enables LFQ and can also be applied to TMT experiments.
#' @param target_fdr A numeric; the targeted false-discovery rate (FDR) at the
#'   levels of PSM, peptide or protein. The default is 0.01. See also argument
#'   \code{fdr_type}.
#' @param fdr_type A character string; the type of FDR control. The value is in
#'   one of c("protein", "peptide", "psm"). The default is \code{protein}.
#'
#'   Note that \code{fdr_type = protein} is comparable to \code{fdr_type =
#'   peptide} with the additional filtration of data at \code{prot_tier == 1}.
#' @param fdr_group A character string; the modification group(s) for uses in
#'   peptide FDR controls. The value is in one of \code{c("all", "base")}. The
#'   \code{base} corresponds to the modification group with the largest number
#'   of matches.
#' @param max_pepscores_co A positive numeric; the upper limit in the cut-offs
#'   of peptide scores for discriminating significant and insignificant
#'   identities.
#' @param min_pepscores_co A non-negative numeric; the lower limit in the
#'   cut-offs of peptide scores for discriminating significant and insignificant
#'   identities.
#' @param max_protscores_co A positive numeric; the upper limit in the cut-offs
#'   of protein scores for discriminating significant and insignificant
#'   identities.  For higher quality and data-driven thresholds, choose the
#'   default \code{max_protscores_co = Inf}.
#' @param max_protnpep_co A positive integer; the maximum number of peptides
#'   under a protein (\code{prot_n_pep}) to warrant the protein significance.
#'   For instance, proteins with \code{prot_n_pep > max_protnpep_co} will have a
#'   protein significance score cutoff of zero and thus are significant. Choose
#'   \code{max_protnpep_co = Inf} to learn automatically the cut-off from data.
#'   Note that the the value of \code{prot_n_pep} includes the counts of shared
#'   peptides.
#' @param method_prot_es_co A low-priority setting. A character string; the
#'   method to calculate the cut-offs of protein enrichment scores. The value is
#'   in one of \code{"median", "mean", "max", "min"} with the default of
#'   \code{"median"}. For instance at the default, the median of
#'   \code{peptide_score - pep_score_cutoff} under a protein will be used to
#'   represent the threshold of a protein enrichment score. For more conserved
#'   thresholds, the statistics of \code{"max"} may be considered.
#' @param soft_secions Logical; if TRUE, collapses the intensities of secondary
#'   ions to primary ions even when the primaries are absent. The default is
#'   FALSE. For instance, the signal of \code{b5^*} will be ignored if its
#'   primary ion \code{b5} is not matched. The impacts of \code{soft_secions =
#'   TRUE} on search performance has not yet been assessed.
#' @param topn_seqs_per_query Positive integer; a threshold to discard peptide
#'   matches under the same MS query with scores beyond the top-n.
#'
#'   The same \code{MS query} refers to the identity in \code{MS scan number}
#'   and \code{MS raw file name}. Target and decoys matches are treated
#'   separately.
#' @param topn_mods_per_seq Positive integer; a threshold to discard variable
#'   modifications under the same peptide match with scores beyond the top-n.
#'
#'   The same \code{peptide match} refers to matches with identities in \code{MS
#'   scan number}, \code{MS raw file name} and \code{peptide sequence}. Target
#'   and decoys matches are treated separately.
#'
#'   For a variable modification with multiple neutral losses (NL), the
#'   best-scored NL will be used in the ranking.
#' @param combine_tier_three Logical; if TRUE, combines search results at tier-3
#'   to tier-1 to form the single output of \code{psmQ.txt}. The default is
#'   FALSE in that data will be segregated into the three quality tiers (shown
#'   below) by the choice of \code{fdr_type}. Note that the argument affects
#'   only at the \code{fdr_type} of \code{psm} or \code{peptide} where there are
#'   no tier-2 outputs. In general, the tier-3 results correspond to
#'   one-hit-wonders and setting \code{combine_tier_three = TRUE} is
#'   discouraged.
#'
#'   In subproteome analysis, such as phosphoproteome analysis, some proteins
#'   may be well established globally, but fail the significance assessment by
#'   protein FDR on the local scale. In situations like this, it may be suitable
#'   to apply \code{fdr_type = "peptide"} or \code{fdr_type = "psm"} other than
#'   incurring \code{combine_tier_three = TRUE}.
#'
#'   Tier-1: both proteins and peptides with scores above significance
#'   thresholds.
#'
#'   Tier-2: \eqn{\ge} 2 significant peptides but protein scores below
#'   significance thresholds.
#'
#'   Tier-3: one significant peptide per protein and protein scores below
#'   significance thresholds.
#'
#' @param max_n_prots Softly depreciated. A positive integer to threshold the
#'   maximum number of protein entries before coercing \code{fdr_type} from
#'   \code{psm} or \code{peptide} to \code{protein}. The argument has no effect
#'   if \code{fdr_type} is already \code{protein}. In general, there is no need
#'   to change the default.
#'
#'   Note that for memory efficiency proteins at tiers 1, 2 and 3 are grouped
#'   separately. Further note that there is no tier-2 proteins at
#'   \code{fdr_type} of \code{psm} or \code{peptide}. For very large data sets,
#'   a lower value of \code{max_n_prots} can be used to reduce the chance of
#'   memory exhaustion by setting aside some protein entries from tier 1 to 2.
#' @param use_ms1_cache Logical; at the TRUE default, use cached precursor
#'   masses.
#'
#'   Set \code{use_ms1_cache = TRUE} for reprocessing of data, e.g., from
#'   \code{fdr_type = psm} to \code{fdr_type = protein}.
#' @param add_ms2theos Logical. If true, adds the sequence of primary
#'   theoretical MS2 m/z values (\code{pep_ms2_theos}). The sequence order at a
#'   given \code{type_ms2ions} is:
#'
#'   \tabular{ll}{ \strong{Type}   \tab \strong{Sequence}\cr by \tab \eqn{b1,
#'   b2..., y1, y2...} \cr ax \tab \eqn{a1, a2..., x1, x2...} \cr cz \tab
#'   \eqn{c1, c2..., z1, z2...} \cr }
#'
#' @param add_ms2theos2 Logical. If true, adds the sequence of secondary
#'   theoretical MS2 m/z values (\code{pep_ms2_theos2}). The sequence order at a
#'   given \code{type_ms2ions} is:
#'
#'   \tabular{ll}{ \strong{Type}   \tab \strong{Order of sequences}\cr by \tab
#'   \eqn{b2, b*, b*2, b0, b02, y2, y*, y*2, y0, y02} \cr ax \tab \eqn{a2, a*,
#'   a*2, a0, a02, x2} \cr cz \tab \eqn{c2, z2} \cr }
#'
#' @param add_ms2moverzs Logical; if TRUE, adds the sequence of experimental
#'   \eqn{m/z} values (\code{pep_ms2_moverzs}).
#' @param add_ms2ints Logical; if TRUE, adds the sequence of experimental MS2
#'   intensity values (\code{pep_ms2_ints}).
#'
#' @param svm_reproc Logical; if TRUE, reprocesses peptide data for significance
#'   thresholds with a support vector machine (SVM) approach analogous to
#'   \href{https://www.nature.com/articles/nmeth1113}{Percolator}.
#' @param svm_kernel The SVM kernel. See also \link[e1071]{svm}.
#' @param svm_feats Features used for SVM classifications.
#' @param svm_iters A positive integer; the number of iterations in
#'   \link[e1071]{svm}.
#' @param svm_cv Logical; if TRUE, performs cross validation for the
#'   regularization cost.
#' @param svm_k A positive integer; specifies the k-number of folds in cross
#'   validation.
#' @param svm_costs The cost constraints for k-fold cross validation.
#' @param svm_def_cost The default cost for SVM.
#' @param svm_iters The number of iteration in SVM learning.
#'
#' @param .path_cache The file path of cached search parameters. The parameter
#'   is for the users' awareness of the underlying structure of file folders and
#'   the use of default is suggested. Occasionally experimenters may remove the
#'   file folder for disk space or under infrequent events of modified framework
#'   incurred by the developer.
#'
#' @param .path_fasta The parent file path to the theoretical masses of MS1
#'   precursors. At the NULL default, the path is \code{gsub("(.*)\\.[^\\.]*$",
#'   "\\1", get("fasta", envir = environment())[1])}. The parameter is for the
#'   users' awareness of the structure of file folders and the use of default is
#'   suggested. Occasionally experimenters may remove the file folder for disk
#'   space or under infrequent events of modified framework incurred by the
#'   developer.
#' @param make_speclib Makes spectrum library from the search results of
#'   \code{psmQ.txt}.
#' @param digits A non-negative integer; the number of decimal places to be
#'   used. The default is 4.
#' @param ... Not currently used.
#' @section \code{FASTA}: \link{load_fasta2} sets the values of \code{acc_type}
#'   and \code{acc_pattern}. \cr
#' @section \code{Unimod}: \link{table_unimods} summarizes
#'   \href{https://www.unimod.org/}{Unimod} into a table format. \cr\cr
#'   \link{find_unimod} finds the mono-isotopic mass, position, site and neutral
#'   losses of a modification \cr\cr \link{parse_unimod} parses a Unimod.
#'   \href{https://proteoq.netlify.app/post/mixing-data-at-different-tmt-plexes/}{For
#'    example}, the name tag of "TMT6plex" is common among TMT-6, -10 and -11
#'   while "TMTpro" is for TMT-16. Experimenters may use aliases of "TMT10plex",
#'   "TMT11plex" and "TMT16plex.\cr\cr \link{calc_unimod_compmass} calculates
#'   the composition masses of a Unimod \cr\cr \link{add_unimod} adds a Unimod
#'   entry. \cr\cr \link{remove_unimod} removes a Unimod entry \cr\cr
#'   \link{remove_unimod_title} removes a Unimod entry by title.
#' @section \code{Visualization}: \link{mapMS2ions} visualizes the MS2 ion
#'   ladders.
#' @section \code{mzTab}: \link{make_mztab} converts outputs from the mzion ->
#'   proteoQ pipeline to mzTab files.
#' @return A list of complete PSMs in \code{psmC.txt}; a list of quality PSMs in
#'   \code{psmQ.txt}.
#' @examples
#' \dontrun{
#' ## All examples are hypothetical
#' ## (Users are responsible for supplying FASTA and peak lists in MGF or mzML)
#'
#' # TMT-10plex
#' matchMS(
#'   fasta    = c("~/mzion/dbs/fasta/refseq/refseq_hs_2013_07.fasta",
#'                "~/mzion/dbs/fasta/refseq/refseq_mm_2013_07.fasta",
#'                "~/mzion/dbs/fasta/crap/crap.fasta"),
#'   acc_type = c("refseq_acc", "refseq_acc", "other"),
#'   max_miss = 2,
#'   quant    = "tmt10",
#'   fdr_type = "protein",
#'   out_path = "~/mzion/examples",
#' )
#'
#' # TMT-16plex, phospho
#' matchMS(
#'   fixedmods = c("TMTpro (N-term)", "TMTpro (K)", "Carbamidomethyl (C)"),
#'   varmods   = c("Acetyl (Protein N-term)", "Oxidation (M)",
#'                 "Deamidated (N)", "Phospho (S)", "Phospho (T)",
#'                 "Phospho (Y)", "Gln->pyro-Glu (N-term = Q)"),
#'   locmods   = c("Phospho (S)", "Phospho (T)", "Phospho (Y)"),
#'   quant     = "tmt16",
#'   fdr_type  = "psm",
#'   out_path  = "~/mzion/examples",
#' )
#'
#' # TMT-18plex
#' matchMS(
#'   fixedmods = c("TMTpro (N-term)", "TMTpro (K)", "Carbamidomethyl (C)"),
#'   varmods   = c("Acetyl (Protein N-term)", "Oxidation (M)",
#'                 "Deamidated (N)", "Deamidated (Q)",
#'                 "Gln->pyro-Glu (N-term = Q)"),
#'   quant     = "tmt18",
#'   out_path  = "~/mzion/examples",
#' )
#'
#' # Bruker's PASEF
#' matchMS(
#'   fixedmods = c("Carbamidomethyl (C)"),
#'   varmods   = c("Acetyl (Protein N-term)", "Oxidation (M)",
#'                 "Deamidated (N)"),
#'   ppm_ms1   = 25,
#'   ppm_ms2   = 40,
#'   quant     = "none",
#'   fdr_type  = "protein",
#'   out_path  = "~/mzion/examples",
#' )
#'
#' # Wrapper of matchMS(enzyme = noenzyme, ...) without sectional searches
#' #   by ranges of peptide lengths
#' matchMS_NES(
#'   fasta    = c("~/mzion/dbs/fasta/refseq/refseq_hs_2013_07.fasta",
#'                "~/mzion/dbs/fasta/refseq/refseq_mm_2013_07.fasta",
#'                "~/mzion/dbs/fasta/crap/crap.fasta"),
#'   acc_type = c("refseq_acc", "refseq_acc", "other"),
#'   quant    = "tmt10",
#'   fdr_type = "protein",
#'   out_path = "~/mzion/examples",
#' )
#'
#'
#' # Custom Unimod (Oxi+Carbamidomethyl)
#' # (see also calc_unimod_compmass)
#' add_unimod(header      = c(title       = "Oxi+Carbamidomethyl",
#'            full_name   = "Oxidation and iodoacetamide derivative"),
#'            specificity = c(site        = "M",
#'                            position    = "Anywhere"),
#'            delta       = c(mono_mass   = "73.016379",
#'                            avge_mass   = "73.0507",
#'                            composition = "H(3) C(2) N O(2)"),
#'            neuloss     = c(mono_mass   = "63.998285",
#'                            avge_mass   = "64.1069",
#'                            composition = "H(4) C O S"))
#'
#' matchMS(
#'   fixedmods = c("TMT6plex (N-term)", "TMT6plex (K)", "Carbamidomethyl (C)"),
#'   varmods   = c("Acetyl (Protein N-term)", "Oxidation (M)", "Deamidated (N)",
#'                 "Oxi+Carbamidomethyl (M)"),
#'   quant    = "tmt10",
#' )
#'
#'
#' ## Stable isotope-labeled K and R (not SILAC mixtures)
#' # Anywhere K8, R10
#' matchMS(
#'   fixedmods = c("Carbamidomethyl (C)"),
#'   varmods   = c("Acetyl (Protein N-term)", "Oxidation (M)", "Deamidated (N)",
#'                 "Label:13C(6)15N(2) (K)", "Label:13C(6)15N(4) (R)"),
#'   quant     = "none",
#' )
#'
#' # K8, R10 + TMT10
#' matchMS(
#'   fixedmods = c("TMT6plex (N-term)", "TMT10plex+K8 (K)", "Carbamidomethyl (C)"),
#'   varmods   = c("Acetyl (Protein N-term)", "Oxidation (M)", "Deamidated (N)",
#'                 "R10 (R)"),
#'   quant     = "tmt10",
#' )
#'
#'
#' #######################################
#' # SILAC
#' #######################################
#'
#' ## 1. heavy and light mixed into one sample (classical SILAC)
#' # (i) K8R10
#' matchMS(
#'   fixedmods = c("Carbamidomethyl (C)"),
#'   varmods   = c("Acetyl (Protein N-term)", "Oxidation (M)", "Deamidated (N)",
#'                 "Gln->pyro-Glu (N-term = Q)"),
#'   silac_mix = list(base  = c(fixedlabs = NULL, varlabs = NULL),
#'                    K8R10 = c(fixedlabs = c("Label:13C(6)15N(2) (K)",
#'                                            "Label:13C(6)15N(4) (R)"),
#'                              varlabs   = NULL)),
#'   ...
#'   )
#'
#'
#' # (ii) base: unlabeled; grpC: 13C; grpN: 15N
#' # (example Dong-Ecoli-QE, Nat. Biotech. 2018, 36, 1059-1061)
#' matchMS(
#'   fixedmods = c("Carbamidomethyl (C)"),
#'   varmods   = c("Acetyl (Protein N-term)", "Oxidation (M)", "Deamidated (N)",
#'                 "Gln->pyro-Glu (N-term = Q)"),
#'
#'   silac_mix = list(base = c(fixedlabs = NULL, varlabs   = NULL),
#'
#'                    grpC = c(fixedlabs = c("Label:13C(3) (A)", "Label:13C(6) (R)",
#'                                           "Label:13C(4) (N)", "Label:13C(4) (D)",
#'                                           "Label:13C(3) (C)", "Label:13C(5) (E)",
#'                                           "Label:13C(5) (Q)", "Label:13C(2) (G)",
#'                                           "Label:13C(6) (H)", "Label:13C(6) (I)",
#'                                           "Label:13C(6) (L)", "Label:13C(6) (K)",
#'                                           "Label:13C(5) (M)", "Label:13C(9) (F)",
#'                                           "Label:13C(5) (P)", "Label:13C(3) (S)",
#'                                           "Label:13C(4) (T)", "Label:13C(11) (W)",
#'                                           "Label:13C(9) (Y)", "Label:13C(5) (V)"),
#'                             varlabs = c("Label:13C(2) (Protein N-term)")),
#'
#'                    grpN = c(fixedlabs = c("Label:15N(1) (A)", "Label:15N(4) (R)",
#'                                           "Label:15N(2) (N)", "Label:15N(1) (D)",
#'                                           "Label:15N(1) (C)", "Label:15N(1) (E)",
#'                                           "Label:15N(2) (Q)", "Label:15N(1) (G)",
#'                                           "Label:15N(3) (H)", "Label:15N(1) (I)",
#'                                           "Label:15N(1) (L)", "Label:15N(2) (K)",
#'                                           "Label:15N(1) (M)", "Label:15N(1) (F)",
#'                                           "Label:15N(1) (P)", "Label:15N(1) (S)",
#'                                           "Label:15N(1) (T)", "Label:15N(2) (W)",
#'                                           "Label:15N(1) (Y)", "Label:15N(1) (V)"),
#'                             varlabs = c("Label:15N(-1) (N)",
#'                                         "Label:15N(-1) (N-term = Q)"))),
#'   ...)
#'
#'
#' # (iii) labeled base
#' # (first to add exemplary K4 Unimod if not yet available)
#' K4 <- calc_unimod_compmass("2H(4) H(-4)")
#' mono_mass <- K4$mono_mass
#' avge_mass <- K4$avge_mass
#'
#' add_unimod(header      = c(title       = "K4",
#'                            full_name   = "Heavy lysine 2H(4) H(-4)"),
#'            specificity = c(site        = "K",
#'                            position    = "Anywhere"),
#'            delta       = c(mono_mass   = "4.025108",
#'                            avge_mass   = "4.02464",
#'                            composition = "2H(4) H(-4)"),
#'            neuloss     = c(mono_mass   = "0",
#'                            avge_mass   = "0",
#'                            composition = "0"))
#'
#' matchMS(
#'   silac_mix = list(base   = c(fixedlabs = c("K4 (K)"), varlabs = NULL),
#'                    median = c(fixedlabs = c("K6 (K)", "R6 (R)"), varlabs = NULL),
#'                    heavy  = c(fixedlabs = c("K8 (K)", "R10 (R)"), varlabs = NULL)),
#'   ...
#' )
#'
#'
#' ## 2. Heavy and light in separate samples
#' #  (toy examples assessing the technical quality of SILAC)
#'
#' # MGFs of light and heavy samples under separate folders;
#' # Heavy modifications being fixedmods
#'
#' # (i) SILAC but low throughput since no sample mixing
#' matchMS(
#'   par_groups = list(
#'     light = list(mgf_path  = "~/mzion/my_project/mgf/light",
#'                  fixedmods = "Carbamidomethyl (C)"),
#'     heavy = list(mgf_path  = "~/mzion/my_project/mgf/heavy",
#'                  fixedmods = c("Carbamidomethyl (C)", "K8 (K)", "R10 (R)"))
#'   ),
#'   quant = "none",
#'   ...
#' )
#'
#' }
#' @export
matchMS <- function (out_path = "~/mzion/outs",
                     mgf_path = file.path(out_path, "mgf"),
                     fasta = c("~/mzion/dbs/fasta/uniprot/uniprot_hs_2020_05.fasta",
                               "~/mzion/dbs/fasta/crap/crap.fasta"),
                     acc_type = c("uniprot_acc", "other"),
                     acc_pattern = NULL,
                     fixedmods = c("TMT6plex (N-term)", "TMT6plex (K)", 
                                   "Carbamidomethyl (C)"),
                     varmods = c("Acetyl (Protein N-term)",
                                 "Oxidation (M)", "Deamidated (N)",
                                 "Gln->pyro-Glu (N-term = Q)"),
                     rm_dup_term_anywhere = TRUE, 
                     
                     ms1_neulosses = NULL, 
                     maxn_neulosses_fnl = 2L, 
                     maxn_neulosses_vnl = 2L, 

                     fixedlabs = NULL, 
                     varlabs = NULL, 
                     locmods = c("Phospho (S)", "Phospho (T)", "Phospho (Y)"), 
                     mod_motifs = NULL, 
                     enzyme = c("Trypsin_P", "Trypsin", "LysC", "LysN", "ArgC", 
                                "LysC_P", "Chymotrypsin", "GluC", "GluN", 
                                "AspC", "AspN", "SemiTrypsin_P", "SemiTrypsin", 
                                "SemiLysC", "SemiLysN", "SemiArgC", 
                                "SemiLysC_P", "SemiChymotrypsin", "SemiGluC", 
                                "SemiGluN", "SemiAspC", "SemiAspN", "Noenzyme", 
                                "Nodigest"),
                     custom_enzyme = c(Cterm = NULL, Nterm = NULL), 
                     nes_fdr_group = c("base", "base_cterm_tryptic", 
                                       "base_cterm_nontryptic", 
                                       "all", "all_cterm_tryptic", 
                                       "all_cterm_nontryptic", 
                                       "top3", "top3_cterm_tryptic", 
                                       "top3_cterm_nontryptic"), 
                     noenzyme_maxn = 0L, 
                     maxn_fasta_seqs = 200000L,
                     maxn_vmods_setscombi = 512L,
                     maxn_vmods_per_pep = 5L,
                     maxn_sites_per_vmod = 3L,
                     maxn_fnl_per_seq = 3L, 
                     maxn_vnl_per_seq = 3L, 
                     maxn_vmods_sitescombi_per_pep = 64L,
                     min_len = 7L, max_len = 40L, max_miss = 2L, 
                     min_mass = 200L, max_mass = 4500L, 
                     ppm_ms1 = 20L, 
                     n_13c = 0L, 
                     ms1_notches = 0, 
                     
                     par_groups = NULL, 
                     silac_mix = NULL, 
                     
                     type_ms2ions = "by", 
                     min_ms2mass = 115L, 
                     max_ms2mass = 4500L, 
                     minn_ms2 = 6L, 
                     ppm_ms2 = 20L, 
                     tmt_reporter_lower = 126.1, 
                     tmt_reporter_upper = 135.2, 
                     exclude_reporter_region = FALSE, 

                     ppm_reporters = 10L,
                     quant = c("none", "tmt6", "tmt10", "tmt11", "tmt16", "tmt18"),
                     use_lfq_intensity = TRUE, 
                     
                     target_fdr = 0.01,
                     fdr_type = c("protein", "peptide", "psm"),
                     fdr_group = c("base", "all", "top3"), 
                     max_pepscores_co = 70, min_pepscores_co = 0, 
                     max_protscores_co = Inf, 
                     max_protnpep_co = 10L, 
                     method_prot_es_co = c("median", "mean", "max", "min"), 
                     soft_secions = FALSE, 
                     
                     topn_mods_per_seq = 1L, 
                     topn_seqs_per_query = 1L, 
                     
                     combine_tier_three = FALSE,
                     max_n_prots = 60000L, 
                     use_ms1_cache = TRUE, 
                     .path_cache = "~/mzion/.MSearches (1.3.0.1)/Cache/Calls", 
                     .path_fasta = NULL,

                     deisotope_ms2 = TRUE, max_ms2_charge = 3L, 
                     n_mdda_flanks = 6L, maxn_mdda_precurs = 1L, 
                     ppm_ms1_deisotope = 8L, ppm_ms2_deisotope = 8L, 
                     grad_isotope = 1.6, fct_iso2 = 3.0, 
                     use_defpeaks = FALSE, 
                     
                     maxn_dia_precurs = 1000L, n_dia_ms2bins = 1L, 
                     n_dia_scans = 4L, topn_dia_ms2ions = 2400L, 
                     delayed_diams2_tracing = FALSE, 
                     
                     topn_ms2ions = 150L,
                     topn_ms2ion_cuts = NA, 
                     min_ms1_charge = 2L, max_ms1_charge = 4L, 
                     min_scan_num = 1L, max_scan_num = .Machine$integer.max, 
                     min_ret_time = 0, max_ret_time = Inf, 
                     calib_ms1mass = FALSE, 
                     ppm_ms1calib = 20L,

                     add_ms2theos = FALSE, add_ms2theos2 = FALSE, 
                     add_ms2moverzs = FALSE, add_ms2ints = FALSE,
                     
                     svm_reproc = FALSE,
                     svm_kernel = "radial",
                     svm_feats  = c("pep_score", "pep_ret_range", 
                                    "pep_delta", "pep_n_ms2", 
                                    "pep_expect", "pep_exp_mz", # "pep_exp_z", 
                                    "pep_exp_mr", "pep_tot_int", 
                                    "pep_n_matches2", "pep_ms2_deltas_mean"), 
                     svm_cv = TRUE, svm_k  = 3L, 
                     svm_costs = c(.1, .3, 1, 3, 10), svm_def_cost = 1, 
                     svm_iters  = 10L, 
                     
                     make_speclib = FALSE, 
                     digits = 4L, ...) 
{
  options(digits = 9L)

  on.exit(
    if (exists(".savecall", envir = environment())) {
      if (.savecall) {
        # Don't: "fun = fun"; seem name collide of `fun` when called from Shiny
        tryCatch(save_call2(path = file.path(out_path, "Calls"), fun = "matchMS"), 
                 error = function(e) NA)
      }
    },
    add = TRUE
  )
  
  message("Started at: ", Sys.time())
  max_integer <- .Machine$integer.max
  
  # Shiny compatibles
  if (is.na(max_protscores_co)) max_protscores_co <- Inf
  if (is.na(max_scan_num)) max_scan_num <- max_integer
  if (is.na(max_ret_time)) max_ret_time <- max_integer
  if ((!is.na(topn_ms2ion_cuts)) && (topn_ms2ion_cuts == "")) topn_ms2ion_cuts <- NA
  if (!(is.numeric(ms1_notches) && length(ms1_notches))) ms1_notches <- 0
  if (is.null(noenzyme_maxn)) noenzyme_maxn <- 0L
  
  if (!is.null(custom_enzyme)) {
    if (!all(names(custom_enzyme) %in% c("Cterm", "Nterm")))
      stop("Custom enzyme terminals need to be `Cterm` and/or `Nterm`.")
    
    if (length(custom_enzyme) > 2L)
      stop("Custom enzyme cannot have more than 2 terminals.")
    
    custom_enzyme <- custom_enzyme[custom_enzyme != ""]
    
    if (!length(custom_enzyme))
      custom_enzyme = c(Cterm = NULL, Nterm = NULL)
  }

  oks <- fasta != ""
  
  if (!all(is.null(acc_pattern)) && length(acc_pattern) == length(fasta))
    acc_pattern <- acc_pattern[oks]
  else
    acc_pattern <- NULL
  
  if (length(acc_type) == length(fasta))
    acc_type <- acc_type[oks]
  
  fasta <- fasta[oks]
  
  lapply(fasta, function (x) {
    if (!file.exists(x)) stop("FASTA file not existed: ", x)
  })
  
  # temporary solution: caused by reload_pars in the ShinyApp
  # may have something to do renderUI
  if (is.null(ppm_reporters)) ppm_reporters <- 10L
  if (is.null(tmt_reporter_lower)) tmt_reporter_lower <- 126.1
  if (is.null(tmt_reporter_upper)) tmt_reporter_upper <- 135.2

  # fixedmods <- gsub("Protein N-term = N-term", "Protein N-term", fixedmods)
  # fixedmods <- gsub("Protein C-term = C-term", "Protein C-term", fixedmods)
  # varmods <- gsub("Protein N-term = N-term", "Protein N-term", varmods)
  # varmods <- gsub("Protein C-term = C-term", "Protein C-term", varmods)

  # Calls
  this_call <- match.call()
  fun <- as.character(this_call[1])
  this_fml <- formals()
  
  ## Match arguments
  method_prot_es_co <- match.arg(method_prot_es_co)

  ## Developer's dots
  dots <- as.list(substitute(...()))

  if (is.null(aa_masses <- dots$aa_masses)) {
    aa_masses <- c(
      A = 71.037114, R = 156.101111, N = 114.042927, D = 115.026943,
      C = 103.009185, E = 129.042593, Q = 128.058578, G = 57.021464,
      H = 137.058912, I = 113.084064, L = 113.084064, K = 128.094963,
      M = 131.040485, F = 147.068414, P = 97.052764, S = 87.032028,
      T = 101.047679, W = 186.079313, Y = 163.063329, V = 99.068414,
      "N-term" = 1.007825, "C-term" = 17.002740,
      U = 150.953633, B = 114.534940, X = 111.000000, Z = 128.550590,
      "-" = 0)
  }
  
  if (!is.null(fixedlabs))
    aa_masses <- add_fixedlab_masses(fixedlabs, aa_masses)

  suppressWarnings(
    rm(list = c(".path_cache", ".path_fasta", ".path_ms1masses", 
                ".time_stamp", ".time_bin", ".path_bin"), 
       envir = .GlobalEnv))

  ## Preparation
  # modifications
  fixedmods <- sort(fixedmods)
  varmods <- sort(varmods)
  locmods <- check_locmods(locmods, fixedmods, varmods, ms1_neulosses)
  
  # accession pattern
  db_ord <- order(fasta)
  fasta  <- fasta[db_ord]
  acc_type <- acc_type[db_ord]
  
  if ((!is.null(acc_pattern)) && all(acc_pattern == "")) 
    acc_pattern <- NULL
  
  if (!is.null(acc_pattern)) {
    if (length(acc_pattern) != length(acc_type))
      stop("The length of `acc_pattern` needs to be the same as `acc_type`.")
    else
      acc_pattern <- acc_pattern[db_ord]
  }
  rm(list = "db_ord")

  # logical types
  stopifnot(vapply(c(soft_secions, combine_tier_three, calib_ms1mass, 
                     use_ms1_cache, add_ms2theos, add_ms2theos2, add_ms2moverzs, 
                     add_ms2ints, exclude_reporter_region, 
                     svm_reproc, svm_cv, rm_dup_term_anywhere, 
                     make_speclib, deisotope_ms2, use_defpeaks, 
                     delayed_diams2_tracing), 
                   is.logical, logical(1L)))

  # numeric types 
  stopifnot(vapply(c(maxn_fasta_seqs, maxn_vmods_setscombi, maxn_vmods_per_pep, 
                     maxn_sites_per_vmod, maxn_fnl_per_seq, maxn_vnl_per_seq, 
                     ms1_notches, maxn_neulosses_fnl, maxn_neulosses_vnl, 
                     maxn_vmods_sitescombi_per_pep, 
                     min_len, max_len, max_miss, topn_ms2ions, minn_ms2, 
                     min_mass, max_mass, min_ms2mass, max_ms2mass, n_13c, 
                     ppm_ms1, ppm_ms2, ppm_reporters, max_n_prots, digits, 
                     target_fdr, max_pepscores_co, min_pepscores_co, 
                     max_protscores_co, max_protnpep_co, topn_mods_per_seq, 
                     topn_seqs_per_query, tmt_reporter_lower, tmt_reporter_upper, 
                     max_ms2_charge, maxn_dia_precurs, topn_dia_ms2ions, 
                     maxn_mdda_precurs, n_dia_ms2bins, n_dia_scans, 
                     n_mdda_flanks, ppm_ms1_deisotope, ppm_ms2_deisotope, 
                     grad_isotope, fct_iso2), 
                   is.numeric, logical(1L)))

  # (a) integers casting for parameter matching when calling cached)
  if (is.infinite(max_len)) max_len <- max_integer
  if (is.infinite(maxn_fasta_seqs)) maxn_fasta_seqs <- max_integer
  if (is.infinite(maxn_vmods_setscombi)) maxn_vmods_setscombi <- max_integer
  if (is.infinite(maxn_vmods_per_pep)) maxn_vmods_per_pep <- max_integer
  if (is.infinite(maxn_sites_per_vmod)) maxn_sites_per_vmod <- max_integer
  if (is.infinite(maxn_vmods_sitescombi_per_pep)) maxn_vmods_sitescombi_per_pep <- max_integer
  if (is.infinite(max_miss)) max_miss <- max_integer
  if (is.infinite(max_mass)) max_mass <- max_integer
  if (is.infinite(max_n_prots)) max_n_prots <- max_integer
  if (is.infinite(topn_ms2ions)) topn_ms2ions <- max_integer
  if (is.infinite(max_scan_num)) max_scan_num <- max_integer
  if (is.infinite(max_ret_time)) max_ret_time <- max_integer
  if (is.infinite(topn_mods_per_seq)) topn_mods_per_seq <- max_integer
  if (is.infinite(topn_seqs_per_query)) topn_seqs_per_query <- max_integer

  maxn_fasta_seqs <- as.integer(maxn_fasta_seqs)
  maxn_vmods_setscombi <- as.integer(maxn_vmods_setscombi)
  maxn_vmods_per_pep <- as.integer(maxn_vmods_per_pep)
  maxn_sites_per_vmod <- as.integer(maxn_sites_per_vmod)
  maxn_vmods_sitescombi_per_pep <- as.integer(maxn_vmods_sitescombi_per_pep)
  maxn_fnl_per_seq <- as.integer(maxn_fnl_per_seq)
  maxn_vnl_per_seq <- as.integer(maxn_vnl_per_seq)
  maxn_neulosses_fnl <- as.integer(maxn_neulosses_fnl)
  maxn_neulosses_vnl <- as.integer(maxn_neulosses_vnl)
  min_len <- as.integer(min_len)
  max_len <- as.integer(max_len)
  max_miss <- as.integer(max_miss)
  topn_ms2ions <- as.integer(topn_ms2ions)
  minn_ms2 <- as.integer(minn_ms2)
  min_mass <- as.integer(min_mass)
  max_mass <- as.integer(max_mass)
  min_ms2mass <- as.integer(min_ms2mass)
  max_ms2mass <- as.integer(max_ms2mass)
  n_13c <- as.integer(n_13c)
  noenzyme_maxn <- as.integer(noenzyme_maxn)
  ppm_ms1 <- as.integer(ppm_ms1)
  ppm_ms2 <- as.integer(ppm_ms2)
  ppm_reporters <- as.integer(ppm_reporters)
  max_n_prots <- as.integer(max_n_prots)
  min_ms1_charge <- as.integer(min_ms1_charge)
  max_ms1_charge <- as.integer(max_ms1_charge)
  min_scan_num <- as.integer(min_scan_num)
  max_scan_num <- as.integer(max_scan_num)
  topn_mods_per_seq <- as.integer(topn_mods_per_seq)
  topn_seqs_per_query <- as.integer(topn_seqs_per_query)
  
  max_ms2_charge <- as.integer(max_ms2_charge)
  maxn_dia_precurs <- as.integer(maxn_dia_precurs)
  topn_dia_ms2ions <- as.integer(topn_dia_ms2ions)
  n_dia_ms2bins <- as.integer(n_dia_ms2bins)
  n_dia_scans <- as.integer(n_dia_scans)
  maxn_mdda_precurs <- as.integer(maxn_mdda_precurs)
  n_mdda_flanks <- as.integer(n_mdda_flanks)
  ppm_ms1_deisotope <- as.integer(ppm_ms1_deisotope)
  ppm_ms2_deisotope <- as.integer(ppm_ms2_deisotope)
  digits <- as.integer(digits)
  
  stopifnot(min_len >= 1L, max_len >= min_len, max_miss <= 10L, minn_ms2 >= 2L, 
            min_mass >= 1L, max_mass >= min_mass, 
            min_ms2mass >= 1L, max_ms2mass > min_ms2mass, 
            maxn_vmods_sitescombi_per_pep >= 2L, noenzyme_maxn >= 0L, 
            maxn_fnl_per_seq >= 0L, maxn_vnl_per_seq >= 0L, 
            maxn_neulosses_fnl >= 0L, maxn_neulosses_vnl >= 0L,
            maxn_vmods_per_pep >= maxn_sites_per_vmod, max_n_prots > 1000L, 
            min_ms1_charge >= 1L, max_ms1_charge >= 2L, 
            max_ms1_charge >= min_ms1_charge, ppm_ms1 > 1, ppm_ms2 > 1, 
            min_scan_num >= 1L, max_scan_num >= min_scan_num, 
            topn_mods_per_seq >= 1L, topn_seqs_per_query >= 1L, 
            tmt_reporter_lower < tmt_reporter_upper, max_ms2_charge >= 1L, 
            maxn_dia_precurs >= 1L, topn_dia_ms2ions >= 1L, n_dia_ms2bins >= 0L, 
            maxn_mdda_precurs >= 0L, n_mdda_flanks >= 1L, 
            ppm_ms1_deisotope >= 1L, ppm_ms2_deisotope >= 1L)
  
  if (n_dia_scans < 2L)
    stop("Choose a larger value of n_dia_scans for defining peak profiles.")
  
  if (n_dia_ms2bins > n_dia_scans)
    stop("Choose a smaller value of n_dia_ms2bins than n_dia_scans.")
  
  # (b) doubles
  target_fdr <- round(as.double(target_fdr), digits = 2L)
  
  if (target_fdr > .25) 
    stop("Choose a smaller `target_fdr`.")
  
  min_ret_time <- round(min_ret_time, digits = 2L)
  max_ret_time <- round(max_ret_time, digits = 2L)
  max_pepscores_co <- round(max_pepscores_co, digits = 2L)
  min_pepscores_co <- round(min_pepscores_co, digits = 2L)
  max_protscores_co <- round(max_protscores_co, digits = 2L)

  stopifnot(max_pepscores_co >= 0, min_pepscores_co >= 0, max_protscores_co >= 0, 
            min_ret_time >= 0, max_pepscores_co >= min_pepscores_co, 
            max_protnpep_co >= 1L, 
            grad_isotope >= 1.0, grad_isotope <= 5.0, 
            fct_iso2 >= 1.0, fct_iso2 <= 6.0)
  
  if (max_ret_time > 0 && max_ret_time < min_ret_time)
    stop("max_ret_time > min_ret_time is not TRUE at positive max_ret_time.")
  
  # named vectors
  if (any(is.na(topn_ms2ion_cuts)))
    mgf_cutmzs <- mgf_cutpercs <- numeric()
  else {
    if (is.infinite(topn_ms2ions))
      stop("Choose a finite \"topn_ms2ions\" value to enable \"topn_ms2ion_cuts\".")
    
    mgf_cutmzs <- as.numeric(names(topn_ms2ion_cuts))
    len <- length(topn_ms2ion_cuts)
    
    if (!identical(mgf_cutmzs, sort(mgf_cutmzs)))
      stop("\"mgf_cutmzs\" is not in an ascending order.")
    
    if (anyDuplicated(mgf_cutmzs))
      warning("Duplicated m-over-z cutpoints in \"topn_ms2ion_cuts\".")
    
    s_topn <- sum(topn_ms2ion_cuts)
    
    if (s_topn > topn_ms2ions) {
      stop("\"sum(topn_ms2ion_cuts) = ", s_topn, "\" is greater than ", 
           "\"topn_ms2ions = ", topn_ms2ions, ".\"")
    }
    else if (s_topn < topn_ms2ions) {
      mgf_cutpercs <- c(unname(topn_ms2ion_cuts), topn_ms2ions - s_topn)
      mgf_cutmzs <- c(mgf_cutmzs, max_ms2mass)
    }
    else {
      mgf_cutpercs <- unname(topn_ms2ion_cuts)
    }
    
    rm(list = c("len", "s_topn"))
    
    if (mgf_cutpercs[length(mgf_cutpercs)] != 0) {
      mgf_cutpercs <- c(mgf_cutpercs, 0)
      mgf_cutmzs <- c(mgf_cutmzs, max_ms2mass)
    }
  }

  # enzyme
  if ((!is.null(custom_enzyme)) && custom_enzyme == "")
    custom_enzyme <- NULL

  if (is.null(custom_enzyme)) {
    enzyme <- tolower(match.arg(enzyme))
  }
  else {
    warning("Overrule `enzyme` with `custom_enzyme`.")
    enzyme <- NULL
  }

  if ((!is.null(enzyme)) && (enzyme == "noenzyme"))
    max_miss <- 0L
  
  if ((!is.null(enzyme)) && (enzyme == "nodigest")) {
    max_miss <- 0L
    max_len <- max_integer
  }

  # fdr_type
  fdr_type <- match.arg(fdr_type)
  fdr_group <- match.arg(fdr_group)
  nes_fdr_group <- match.arg(nes_fdr_group)
  
  # quant
  quant <- match.arg(quant)

  # TMT
  check_tmt_pars(fixedmods, varmods, quant)
  
  # MS1 off-sets
  if (!all(ms1_neulosses %in% varmods))
    stop("Not all `ms1_neulosses` found in `varmods`.")
  
  check_notches(ms1_notches = ms1_notches, ms1_neulosses = ms1_neulosses)
  ms1_offsets <- find_ms1_offsets(n_13c = n_13c, ms1_notches = ms1_notches)
  is_notched  <- length(unique(c(ms1_offsets, ms1_neulosses))) > 1L

  # system paths
  homedir <- find_dir("~")
  
  if (is.null(.path_cache))
    .path_cache <- "~/mzion/.MSearches/Cache/Calls/"

  if (is.null(.path_fasta))
    .path_fasta <- file.path(gsub("(.*)\\.[^\\.]*$", "\\1", fasta[1]))

  .path_cache <- create_dir(.path_cache)
  .path_fasta <- create_dir(.path_fasta)
  .path_ms1masses <- create_dir(file.path(.path_fasta, "ms1masses"))

  fasta <- lapply(fasta, function (x) if (grepl("~", x)) gsub("~", homedir, x) else x)
  fasta <- unlist(fasta, recursive = FALSE, use.names = FALSE)
  
  # Output path
  out_path <- create_dir(out_path)
  dir.create(file.path(out_path, "Calls"), showWarnings = FALSE, recursive = FALSE)
  dir.create(file.path(out_path, "temp"), showWarnings = FALSE, recursive = FALSE)

  # grouped searches 
  # (this step before checking mgf_path)
  if (length(par_groups)) {
    if ("out_path" %in% names(par_groups))
      stop("Do not include `out_path` in `par_groups`.\n", 
           "The same parent `out_path` is assumed.")
    
    if ("fasta" %in% names(par_groups))
      stop("Do not include `fasta` in `par_groups`.\n", 
           "The same set of `fasta` files is assumed.")
    
    grp_args <- local({
      nms <- lapply(par_groups, names)
      all_nms <- sort(unique(unlist(nms, use.names = FALSE, recursive = FALSE)))
      nms_1 <- sort(nms[[1]])
      
      if (!identical(nms_1, all_nms))
        stop("Not all names are identical to those in the first group: ", 
             paste(nms_1, collapse = ", "))
      
      fargs <- formalArgs(fun)
      bads <- nms_1[! nms_1 %in% fargs]
      
      if (length(bads)) 
        stop("Arguments in `par_groups` not defined in `", fun, "`:\n  ", 
             paste(bads, collapse = ", "))
      
      cargs <- names(this_call)
      cargs <- cargs[cargs != ""]
      dups <- nms_1[nms_1 %in% cargs]
      
      if (length(dups))
        stop("Arguments in `par_groups` already in the call", ":\n  ", 
             paste(dups, collapse = ", "))
      
      nms_1
    })
  }
  else {
    grp_args <- NULL
  }

  # MGF path
  if ("mgf_path" %in% grp_args) {
    mgf_path <- NULL
    
    mgf_paths <- lapply(par_groups, `[[`, "mgf_path")
    mgf_paths <- lapply(mgf_paths, checkMGF, grp_args, error = "warn")
    
    for (i in seq_along(mgf_paths)) 
      par_groups[[i]][["mgf_path"]] <- mgf_paths[[i]]
    
    rm(list = c("i"))
  }
  else {
    # (MGFs in sub-folders if group searches)
    mgf_path <- checkMGF(mgf_path, error = "warn")
    mgf_paths <- NULL
  }
  
  ## No-enzyme searches
  exec_noenzyme <- if (isTRUE(dots$bypass_noenzyme)) FALSE else TRUE
  
  if (isTRUE(enzyme == "noenzyme") && exec_noenzyme) {
    matchMS_noenzyme(this_call = this_call, min_len = min_len, max_len = max_len, 
                     fasta = fasta, out_path = out_path, mgf_path = mgf_path, 
                     noenzyme_maxn = noenzyme_maxn, quant = quant, 
                     silac_noenzyme = if (!is.null(silac_mix)) TRUE else FALSE, 
                     groups_noenzyme = if (!is.null(par_groups)) TRUE else FALSE)

    return(NULL)
  }

  ## Mixed SILAC
  exec_silac_mix <- if (isTRUE(dots$bypass_silac_mix)) FALSE else TRUE
  
  if (length(silac_mix) && exec_silac_mix) {
    if (!is.null(fixedlabs)) {
      stop("Arguments \"fixedlabs\" and \"silac_mix\" both are non-NULL.\n", 
           "  Set up \"fixedlabs\" under \"silac_mix\" for SILAC;\n", 
           "  Use directly \"fixedlabs\" for direct searches with labels.\n", 
           "The same applies to \"varlabs\".")
    }
    
    matchMS_silac_mix(silac_mix = silac_mix, 
                      this_call = this_call, 
                      out_path = out_path, 
                      mgf_path = mgf_path, 
                      aa_masses = aa_masses)

    return(NULL)
  }
  
  # Searches by group (separate SILACs)
  exec_par_groups <- if (isTRUE(dots$bypass_par_groups)) FALSE else TRUE
  
  if (length(par_groups) && exec_par_groups) {
    df <- matchMS_par_groups(par_groups = par_groups, 
                             grp_args = grp_args,
                             mgf_paths = mgf_paths, 
                             this_call = this_call, 
                             out_path = out_path)
    
    .savecall <- TRUE
    
    return(df)
  }
  
  ## Theoretical MS1 masses
  if (is.null(bypass_pepmasses <- dots$bypass_pepmasses)) 
    bypass_pepmasses <- FALSE

  if (!bypass_pepmasses)
    res <- calc_pepmasses2(
      aa_masses = aa_masses, 
      fasta = fasta,
      acc_type = acc_type,
      acc_pattern = acc_pattern,
      fixedmods = fixedmods,
      varmods = varmods,
      rm_dup_term_anywhere = rm_dup_term_anywhere, 
      fixedlabs = fixedlabs, 
      varlabs = varlabs, 
      mod_motifs = mod_motifs, 
      enzyme = enzyme,
      custom_enzyme = custom_enzyme, 
      noenzyme_maxn = noenzyme_maxn, 
      maxn_fasta_seqs = maxn_fasta_seqs,
      maxn_vmods_setscombi = maxn_vmods_setscombi,
      maxn_vmods_per_pep = maxn_vmods_per_pep,
      maxn_sites_per_vmod = maxn_sites_per_vmod,
      min_len = min_len,
      max_len = max_len,
      max_miss = max_miss,
      min_mass = min_mass, 
      max_mass = max_mass, 
      out_path = out_path,
      digits = digits,
      use_ms1_cache = use_ms1_cache, 
      .path_cache = .path_cache, 
      .path_fasta = .path_fasta, 
      .path_ms1masses = .path_ms1masses)

  ## Bin theoretical peptides
  if (is.null(bypass_bin_ms1 <- dots$bypass_bin_ms1)) 
    bypass_bin_ms1 <- FALSE
  
  reframe_mgfs <- calib_ms1mass && ppm_ms1calib != ppm_ms1

  if (!bypass_bin_ms1) {
    .path_bin <- 
      bin_ms1masses(res = res, 
                    min_mass = min_mass, 
                    max_mass = max_mass, 
                    min_len = min_len,
                    max_len = max_len,
                    ppm_ms1 = ppm_ms1, 
                    use_ms1_cache = use_ms1_cache, 
                    .path_cache = .path_cache, 
                    .path_ms1masses = .path_ms1masses, 
                    enzyme = enzyme, 
                    out_path = out_path)
    
    .path_bin_calib <- if (reframe_mgfs)
      bin_ms1masses(res = res, 
                    min_mass = min_mass, 
                    max_mass = max_mass, 
                    min_len = min_len,
                    max_len = max_len,
                    ppm_ms1 = ppm_ms1calib, 
                    use_ms1_cache = use_ms1_cache, 
                    .path_cache = .path_cache, 
                    .path_ms1masses = .path_ms1masses, 
                    enzyme = enzyme, 
                    out_path = out_path)
    else
      .path_bin

    if (exists("res"))
      rm(list = "res")
  }

  ## MGFs
  file_type_acqu <- file.path(mgf_path, "type_acqu.rds")
  
  if (is.null(bypass_mgf <- dots$bypass_mgf)) 
    bypass_mgf <- FALSE

  if ((!bypass_mgf) || (!file.exists(file_type_acqu))) {
    type_acqu <- load_mgfs(
      out_path = out_path, 
      mgf_path = mgf_path, 
      topn_ms2ions = topn_ms2ions, 
      
      topn_dia_ms2ions = topn_dia_ms2ions, 
      delayed_diams2_tracing = delayed_diams2_tracing, 
      maxn_dia_precurs = maxn_dia_precurs, 
      n_dia_ms2bins = n_dia_ms2bins, 
      n_dia_scans = n_dia_scans, 
      
      min_mass = min_mass, 
      max_mass = max_mass, 
      min_ms2mass = min_ms2mass, 
      max_ms2mass = max_ms2mass,
      min_ms1_charge = min_ms1_charge, 
      max_ms1_charge = max_ms1_charge, 
      min_scan_num = min_scan_num, 
      max_scan_num = max_scan_num, 
      min_ret_time = min_ret_time, 
      max_ret_time = max_ret_time, 
      ppm_ms1 = ppm_ms1, 
      ppm_ms2 = ppm_ms2, 
      tmt_reporter_lower = tmt_reporter_lower, 
      tmt_reporter_upper = tmt_reporter_upper, 
      exclude_reporter_region = exclude_reporter_region, 
      mgf_cutmzs = mgf_cutmzs, 
      mgf_cutpercs = mgf_cutpercs, 
      enzyme = enzyme, 
      deisotope_ms2 = deisotope_ms2, 
      grad_isotope = grad_isotope, 
      fct_iso2 = fct_iso2, 
      max_ms2_charge = max_ms2_charge, 
      use_defpeaks = use_defpeaks, 
      maxn_mdda_precurs = maxn_mdda_precurs, 
      n_mdda_flanks = n_mdda_flanks, 
      ppm_ms1_deisotope = ppm_ms1_deisotope, 
      ppm_ms2_deisotope = ppm_ms2_deisotope, 
      quant = quant, 
      use_lfq_intensity = use_lfq_intensity, 
      digits = digits)
  }
  else {
    type_acqu <- qs::qread(file_type_acqu)
  }

  ## MSMS matches
  if (is.null(bypass_ms2match <- dots$bypass_ms2match)) 
    bypass_ms2match <- FALSE

  if (length(.time_stamp <- find_ms1_times(out_path)) == 1L) {
    path_time <- file.path(.path_ms1masses, .time_stamp)
    file_aams <- file.path(path_time, "aa_masses_all.rds")
    file_mods <- file.path(path_time, "mod_indexes.txt")
    aa_masses_all <- qs::qread(file_aams)
    mod_indexes <- find_mod_indexes(file_mods)
    
    file.copy(file_aams, file.path(out_path, "aa_masses_all.rds"), overwrite = TRUE)
    file.copy(file_mods, file.path(out_path, "mod_indexes.txt"), overwrite = TRUE)
    rm(list = c("path_time", "file_aams", "file_mods"))
  }
  else {
    # only with group searches (low priority)
    aa_masses_all <- NULL
    mod_indexes <- NULL
  }
  
  if (calib_ms1mass) {
    calib_mgf(mgf_path = mgf_path, aa_masses_all = aa_masses_all[1], # base
              out_path = out_path, .path_bin = .path_bin_calib, 
              mod_indexes = mod_indexes[names(mod_indexes) %in% fixedmods], 
              type_ms2ions = type_ms2ions, 
              maxn_vmods_per_pep = maxn_vmods_per_pep,
              maxn_sites_per_vmod = maxn_sites_per_vmod, 
              maxn_fnl_per_seq = maxn_fnl_per_seq, 
              maxn_vnl_per_seq = maxn_vnl_per_seq, 
              maxn_vmods_sitescombi_per_pep = maxn_vmods_sitescombi_per_pep,
              minn_ms2 = minn_ms2, 
              ppm_ms1 = ppm_ms1calib, 
              reframe_mgfs = reframe_mgfs, 
              ppm_ms2 = ppm_ms2, min_mass = min_mass, max_mass = max_mass, 
              min_ms2mass = min_ms2mass, quant = quant, 
              ppm_reporters = ppm_reporters, 
              fasta = fasta, acc_type = acc_type, 
              acc_pattern = acc_pattern, topn_ms2ions = topn_ms2ions, 
              fixedmods = fixedmods, varmods = NULL, # the first search
              enzyme = enzyme, maxn_fasta_seqs = maxn_fasta_seqs, 
              maxn_vmods_setscombi = maxn_vmods_setscombi,
              min_len = min_len, max_len = max_len, max_miss = max_miss)
  }

  if (!bypass_ms2match) {
    if (min_ms2mass < 5L) 
      warning("Maybe out of RAM at \"min_ms2mass < 5L\".")
    
    ms2match(mgf_path = mgf_path,
             aa_masses_all = aa_masses_all,
             out_path = out_path,
             .path_bin = .path_bin, 
             mod_indexes = mod_indexes,
             type_ms2ions = type_ms2ions,
             maxn_vmods_per_pep = maxn_vmods_per_pep,
             maxn_sites_per_vmod = maxn_sites_per_vmod,
             maxn_fnl_per_seq = maxn_fnl_per_seq, 
             maxn_vnl_per_seq = maxn_vnl_per_seq, 
             maxn_vmods_sitescombi_per_pep = maxn_vmods_sitescombi_per_pep,
             minn_ms2 = minn_ms2,
             ppm_ms1 = ppm_ms1,
             reframe_mgfs = FALSE, 
             ppm_ms2 = ppm_ms2,
             min_mass = min_mass, 
             max_mass = max_mass, 
             min_ms2mass = min_ms2mass,
             quant = quant,
             ppm_reporters = ppm_reporters,
             ms1_offsets = ms1_offsets, 
             ms1_neulosses = ms1_neulosses, 
             maxn_neulosses_fnl = maxn_neulosses_fnl, 
             maxn_neulosses_vnl = maxn_neulosses_vnl, 
             deisotope_ms2 = deisotope_ms2, 

             # dummy for argument matching
             fasta = fasta,
             acc_type = acc_type,
             acc_pattern = acc_pattern,
             topn_ms2ions = topn_ms2ions,
             fixedmods = fixedmods,
             varmods = varmods,
             enzyme = enzyme,
             maxn_fasta_seqs = maxn_fasta_seqs,
             maxn_vmods_setscombi = maxn_vmods_setscombi,
             min_len = min_len,
             max_len = max_len,
             max_miss = max_miss)
  }

  ## Peptide scores
  fct_score <- 5
  
  if (is.null(bypass_from_pepscores <- dots$bypass_from_pepscores)) 
    bypass_from_pepscores <- FALSE

  if (bypass_from_pepscores) 
    return(NULL)
  
  if (is.null(bypass_pepscores <- dots$bypass_pepscores)) 
    bypass_pepscores <- FALSE
  
  maxn_mdda_precurs2 <- if (type_acqu == "dia") 500L else maxn_mdda_precurs
  
  if (!bypass_pepscores) {
    if (is.null(tally_ms2ints <- dots$tally_ms2ints)) 
      tally_ms2ints <- TRUE
    
    if (is.null(n_ms2_bg <- dots$n_ms2_bg))
      n_ms2_bg <- max_len * 250L

    calc_pepscores(topn_ms2ions = topn_ms2ions,
                   type_ms2ions = type_ms2ions,
                   target_fdr = target_fdr,
                   min_len = min_len,
                   max_len = max_len,
                   ppm_ms2 = ppm_ms2,
                   soft_secions = soft_secions, 
                   out_path = out_path,
                   min_ms2mass = min_ms2mass,
                   maxn_mdda_precurs = maxn_mdda_precurs2, 
                   n_ms2_bg = n_ms2_bg, 
                   tally_ms2ints = tally_ms2ints, 
                   
                   # dummies
                   mgf_path = mgf_path,
                   maxn_vmods_per_pep = maxn_vmods_per_pep,
                   maxn_sites_per_vmod = maxn_sites_per_vmod,
                   maxn_vmods_sitescombi_per_pep = 
                     maxn_vmods_sitescombi_per_pep,
                   minn_ms2 = minn_ms2,
                   ppm_ms1 = ppm_ms1,
                   quant = quant,
                   ppm_reporters = ppm_reporters,
                   fasta = fasta,
                   acc_type = acc_type,
                   acc_pattern = acc_pattern,
                   fixedmods = fixedmods,
                   varmods = varmods,
                   enzyme = enzyme,
                   maxn_fasta_seqs = maxn_fasta_seqs,
                   maxn_vmods_setscombi = maxn_vmods_setscombi,
                   add_ms2theos = add_ms2theos, 
                   add_ms2theos2 = add_ms2theos2, 
                   add_ms2moverzs = add_ms2moverzs, 
                   add_ms2ints = add_ms2ints,
                   digits = digits)
  }
  
  if (is.null(bypass_primatches <- dots$bypass_primatches)) 
    bypass_primatches <- FALSE
  
  if (!bypass_primatches)
    hadd_primatches(out_path = out_path, 
                    is_notched = is_notched, 
                    add_ms2theos = add_ms2theos, 
                    add_ms2theos2 = add_ms2theos2, 
                    add_ms2moverzs = add_ms2moverzs, 
                    add_ms2ints = add_ms2ints)

  ## Peptide FDR 
  if (is.null(bypass_pepfdr <- dots$bypass_pepfdr)) 
    bypass_pepfdr <- FALSE
  
  if (!bypass_pepfdr) {
    prob_cos <- calc_pepfdr(target_fdr = target_fdr, 
                            fdr_type = fdr_type, 
                            min_len = min_len, 
                            max_len = max_len, 
                            is_notched = is_notched, 
                            max_pepscores_co = max_pepscores_co, 
                            min_pepscores_co = min_pepscores_co, 
                            enzyme = enzyme, 
                            fdr_group = fdr_group, 
                            nes_fdr_group = nes_fdr_group, 
                            out_path = out_path, 
                            fct_score = fct_score)
    
    ans <- post_pepfdr(prob_cos = prob_cos, n_13c = n_13c, out_path = out_path, 
                       fct_score = fct_score)

    if (svm_reproc) {
      message("SVM reprocessing of peptide probabilities.")
      
      prob_cos <- perco_svm(out_path = out_path, df = ans, prob_cos = prob_cos, 
                            target_fdr = target_fdr, fdr_type = fdr_type, 
                            min_len = min_len, max_len = max_len, 
                            max_pepscores_co = max_pepscores_co, 
                            min_pepscores_co = min_pepscores_co, enzyme = enzyme, 
                            fdr_group = fdr_group, nes_fdr_group = nes_fdr_group, 
                            svm_kernel = svm_kernel, svm_feats = svm_feats, 
                            cross_valid = svm_cv, k  = svm_k, 
                            costs = svm_costs, 
                            def_cost = svm_def_cost, 
                            svm_iters = svm_iters, 
                            fct_score = fct_score)

      # post_pepfdr(prob_cos, out_path)
      message("Completed SVM reprocessing.")
    }

    rm(list = c("ans", "prob_cos"))
  }

  ## Peptide ranks and score deltas between `pep_ivmod`
  if (is.null(bypass_peploc <- dots$bypass_peploc)) 
    bypass_peploc <- FALSE
  
  if (!bypass_peploc) {
    calc_peploc(out_path = out_path, 
                mod_indexes = mod_indexes, 
                locmods = locmods, 
                is_notched = is_notched,
                topn_mods_per_seq = topn_mods_per_seq, 
                topn_seqs_per_query = topn_seqs_per_query)
  }

  ## Protein accessions
  if (is.null(bypass_from_protacc <- dots$bypass_from_protacc)) 
    bypass_from_protacc <- FALSE
  
  if (bypass_from_protacc) 
    return(NULL)
  
  if (is.null(bypass_protacc <- dots$bypass_protacc)) 
    bypass_protacc <- FALSE
  
  temp_dir <- file.path(out_path, "temp")
  file_protacc <- file.path(temp_dir, "df_protacc.rds")
  
  if (bypass_protacc && file.exists(file_protacc))
    df <- qs::qread(file_protacc)
  else {
    if (is.null(enzyme) || 
        (enzyme != "noenzyme" || isTRUE(dots[["direct_prot_acc"]]))) {
      df <- add_protacc(out_path = out_path, 
                        .path_cache = .path_cache, 
                        .path_fasta = .path_fasta)
    }
    else {
      silac_noenzyme <- if (isTRUE(dots$silac_noenzyme)) TRUE else FALSE
      
      # see matchMS_noenzyme for nested silac under noenzyme
      df <- if (silac_noenzyme)
        add_protacc(out_path = out_path, 
                    .path_cache = .path_cache, 
                    .path_fasta = .path_fasta)
      else
        add_protacc2(out_path = out_path, 
                     .path_cache = .path_cache, 
                     .path_fasta = .path_fasta)
      
      rm(list = c("silac_noenzyme"))
    }
    
    qs::qsave(df, file_protacc, preset = "fast")
  }
  
  rm(list = "file_protacc")
  
  ## Protein FDR
  if (is.null(bypass_protfdr <- dots$bypass_protfdr)) 
    bypass_protfdr <- FALSE
  
  file_protfdr <- file.path(temp_dir, "df_protfdr.rds")
  
  if (bypass_protfdr && file.exists(file_protfdr)) {
    df <- qs::qread(file_protfdr)
  }
  else {
    df <- calc_protfdr(df = df, 
                       target_fdr = target_fdr, 
                       max_protscores_co = max_protscores_co, 
                       max_protnpep_co = max_protnpep_co, 
                       method_prot_es_co = method_prot_es_co, 
                       out_path = out_path)
    qs::qsave(df, file_protfdr, preset = "fast")
  }
  
  # second removals after combining pep_mod_group's
  df <- rm_dup13c(df, n_13c = n_13c)

  # add optional reporters
  df <- add_rptrs(df, quant, out_path)

  ## Clean-ups
  # (raw_file etc. already mapped if `from_group_search`)
  if (!isTRUE(from_group_search <- dots$from_group_search)) {
    if (file.exists(file.path(mgf_path, "scan_indexes.rds"))) {
      df <- map_raw_n_scan_old(df, mgf_path) # backward-compatible
    }
    else {
      df <- map_raw_n_scan(df, mgf_path)
    }
  }

  df <- dplyr::mutate(df, pep_expect = 
                        10^((pep_score_co - pep_score)/fct_score) * target_fdr)
  df[["pep_score_co"]] <- NULL
  df$pep_delta <- df$pep_exp_mr - df$pep_calc_mr

  nms <- names(df)
  df  <- dplyr::bind_cols(
    df[grepl("^prot_", nms)],
    df[grepl("^pep_", nms)],
    df[grepl("^psm_", nms)],
    df[!grepl("^prot_|^pep_|^psm_", nms)], )
  rm(list = "nms")
  
  df <- reloc_col_after(df, "pep_exp_z", "pep_exp_mr")
  df <- reloc_col_after(df, "pep_calc_mr", "pep_exp_z")
  df <- reloc_col_after(df, "pep_delta", "pep_calc_mr")
  
  cols_tmt <- grepl("^I[0-9]{3}[Nc]{0,1}", names(df))
  rows_tmt <- grepl("TMT", df[["pep_fmod"]]) | grepl("TMT", df[["pep_vmod"]])
  df[!rows_tmt, cols_tmt] <- NA_real_
  rm(list = c("cols_tmt", "rows_tmt"))
  
  local({
    df$pep_exp_mz  <- round(df$pep_exp_mz, digits = 4L)
    df$pep_exp_mr  <- round(df$pep_exp_mr, digits = 4L)
    df$pep_calc_mr <- round(df$pep_calc_mr, digits = 4L)
    df$pep_delta   <- round(df$pep_delta, digits = 4L)
    df$pep_tot_int <- round(df$pep_tot_int, digits = 1L)
    df$pep_expect  <- format(df$pep_expect, digits = 3L)
    
    readr::write_tsv(df, file.path(out_path, "psmC.txt"))
    session_info <- sessionInfo()
    save(session_info, file = file.path(out_path, "Calls", "mzion.rda"))
  })

  ## psmC to psmQ
  if (is.null(bypass_psmC2Q <- dots$bypass_psmC2Q)) 
    bypass_psmC2Q <- FALSE
  
  if (bypass_psmC2Q) {
    df <- readr::read_tsv(file.path(out_path, "psmQ.txt"), 
                          col_types = get_mzion_coltypes())
  }
  else {
    df <- df[, c("prot_acc", "pep_seq", "pep_issig", "pep_isdecoy", 
                 "prot_issig", "prot_n_pep")]
    
    df <- dplyr::filter(df, pep_issig, !pep_isdecoy, !grepl("^-", prot_acc))
    
    df <- try_psmC2Q(df, 
                     out_path = out_path,
                     fdr_type = fdr_type, # for workflow controls 
                     combine_tier_three = combine_tier_three, 
                     max_n_prots = max_n_prots)
  }

  
  
  message("Completed at: ", Sys.time())
  
  .savecall <- TRUE

  invisible(df)
}


#' Helper of \link{psmC2Q}.
#' 
#' "n_peps" and "n_prots" including both targets and decoys: \cr
#' "n_prots" about 1:1 \cr
#' "n_peps" about 1.8:1
#' 
#' @inheritParams psmC2Q
#' @importFrom magrittr %>% %T>%
try_psmC2Q <- function (df = NULL, out_path = NULL, fdr_type = "protein",
                        combine_tier_three = FALSE, max_n_prots = 60000L) 
{
  n_peps <- length(unique(df$pep_seq))
  n_prots <- length(unique(df$prot_acc))
  
  if (n_prots == 1L) {
    message("No grouping with the number of of proteins = ", n_prots, ".\n",
            "Search completed successfully.")
    options(show.error.messages = FALSE)
    stop()
  }
  
  if (n_peps > 1000000L && n_prots > 100000L)
    df <- NA
  else
    df <- tryCatch(
      psmC2Q(df,
             out_path = out_path,
             fdr_type = fdr_type,
             combine_tier_three = combine_tier_three, 
             max_n_prots = max_n_prots),
      error = function(e) NA)

  if (length(df) == 1L && is.na(df)) {
    message("Retry with a new R session: \n\n",
            "Manual execution of the following codes if not start automatically.\n\n", 
            "mzion::reproc_psmC(\n",
            "  out_path = \"", out_path, "\",\n",
            "  fdr_type = \"", fdr_type, "\",\n",
            "  combine_tier_three  = ", combine_tier_three, ",\n",
            "  max_n_prots  = ", max_n_prots, "\n",
            ")\n")
    
    fileConn <- file(file.path("~/post_psmC.R"))
    
    lines <- c(
      "library(mzion)\n",
      "mzion::reproc_psmC(",
      paste0("  out_path = \"", out_path, "\","),
      paste0("  fdr_type = \"", fdr_type, "\","),
      paste0("  combine_tier_three = ", combine_tier_three, ","),
      paste0("  max_n_prots = ", max_n_prots),
      ")\n",
      "unlink(\"~/post_psmC.R\")"
    )
    
    writeLines(lines, fileConn)
    close(fileConn)
    
    rstudioapi::restartSession(command = 'source("~/post_psmC.R")')
  } 
  else {
    suppressWarnings(
      rm(list = c(".path_cache", ".path_ms1masses", ".time_stamp"), 
         envir = .GlobalEnv))

    message("Done.")
  }
  
  invisible(df)
}


#' Reprocessing of \code{psmC.txt}.
#'
#' Protein grouping from \code{psmC.txt} to \code{psmQ.txt}.
#'
#' May solve some memory shortage issues for large data sets by restarting An
#' Rstudio session.
#'
#' The score cut-offs are different among the \code{fdr_type} of "psm",
#' "peptide" and "protein". An experimenter need to match the value of
#' \code{fdr_type}.
#'
#' @param fct A factor for data splitting into chunks. May consider a greater
#'   value for a larger data set.
#' @inheritParams matchMS
#' @export
reproc_psmC <- function (out_path = NULL, fdr_type = "protein",
                         combine_tier_three = FALSE, max_n_prots = 60000L, 
                         fct = 4L) 
{
  if (is.null(out_path)) 
    stop("`out_path` cannot be NULL.", call. = FALSE)

  message("Leave the session open and wait for the `Search completed` message.")

  df <- suppressWarnings(
    readr::read_tsv(file.path(out_path, "psmC.txt"), 
                    col_types = get_mzion_coltypes()))

  df <- df[, c("pep_seq", "prot_acc", "prot_issig", "prot_n_pep",
               "pep_issig", "pep_isdecoy")]
  
  df <- dplyr::filter(df, pep_issig, !pep_isdecoy, !grepl("^-", prot_acc))
  gc()

  psmC2Q(df, out_path = out_path,
         fdr_type = fdr_type,
         combine_tier_three = combine_tier_three, 
         max_n_prots = max_n_prots, 
         fct = fct)

  message("Done.")
}


#' From \code{psmC.txt} to \code{psmQ.txt}.
#'
#' Non-significant and decoy peptides should have been removed from the input
#' \code{df}, as well as decoy proteins.
#'
#' @param df A result of \code{psmC.txt} with the removals of non-significant
#'   or decoy peptides, as well as decoy proteins.
#' @param fct A factor for data splitting into chunks. May consider a greater
#'   value for a larger data set.
#' @inheritParams matchMS
#' @importFrom fastmatch %fin%
psmC2Q <- function (df = NULL, out_path = NULL, fdr_type = "protein",
                    combine_tier_three = FALSE, max_n_prots = 60000L, 
                    fct = 4L) 
{
  options(warn = 1L)
  
  # if (!all(df[["pep_issig"]])) stop("Developer: filter data by \"pep_issig\" first.")
  # if (any(df[["pep_isdecoy"]])) stop("Developer: remove decoy peptide first.")
  # if (any(grepl("^-", df["prot_acc"]))) stop("Developer: remove decoy proteins first.")

  message("\n=================================\n",
          "prot_tier  prot_issig  prot_n_pep \n",
          "    1          [y]          \n",
          "    2          [n]          > 1\n",
          "    3          [n]          = 1\n",
          "=================================\n")
  
  # Set aside one-hit wonders
  df3 <- dplyr::filter(df, !prot_issig, prot_n_pep == 1L)
  df3 <- dplyr::mutate(df3, prot_tier = 3L)

  df <- dplyr::bind_rows(
    dplyr::filter(df, prot_issig),
    dplyr::filter(df, !prot_issig, prot_n_pep >= 2L))

  df <- dplyr::mutate(df, prot_tier = ifelse(prot_issig, 1L, 2L))

  # the same peptide can be present in all three protein tiers; 
  # steps up if pep_seq(s) in tier 3 also in tiers 1, 2
  if (FALSE) {
    rows <- df3$pep_seq %in% df$pep_seq
    df <- dplyr::bind_rows(df, df3[rows, ])
    df3 <- df3[!rows, ]
    rm(list = "rows")
  }
  
  # Protein groups
  message("Building protein-peptide maps.")
  
  len_prots <- length(unique(df$prot_acc))
  
  if (len_prots > max_n_prots && fdr_type != "protein") {
    warning("Large number of proteins at ", len_prots, ".\n", 
            "Coerce to `fdr_type = protein` ",
            "and save peptide results of tier-2 proteins in `psmT2.txt`.",
            call. = FALSE)
    
    fdr_type <- "protein"
    
    df2 <- dplyr::filter(df, prot_tier == 2L)
    df  <- dplyr::filter(df, prot_tier == 1L)
  } 
  else {
    if (fdr_type == "protein") {
      df2 <- dplyr::filter(df, prot_tier == 2L)
      df  <- dplyr::filter(df, prot_tier == 1L)
    } 
    else {
      message("No tier-2 outputs at `fdr_type = ", fdr_type, "`.")
      
      if (len_prots > max_n_prots) {
        warning("The number of proteins is ", len_prots, ".\n", 
                "Consider `fdr_type = protein`.",
                call. = FALSE)
      }
      
      df2 <- df[0, ]
      df <- df # prot_tiers: 1 + 2
    }
  }
  
  # df may have both prot_tier 1 and 2 if fdr_type != "protein"
  df_tier12 <- unique(df[, c("prot_acc", "prot_tier")])
  
  df  <- unique(df [, c("prot_acc", "pep_seq")])
  df2 <- unique(df2[, c("prot_acc", "pep_seq")])
  df3 <- unique(df3[, c("prot_acc", "pep_seq")])

  nms <- c("prot_acc", "pep_seq", "prot_isess", "prot_hit_num", 
           "prot_family_member", "pep_literal_unique", "pep_razor_unique")
  
  if (nrow(df)) {
    df <- groupProts(df, out_path = file.path(out_path, "temp1"), fct = fct)
    df <- dplyr::left_join(df, df_tier12, by = "prot_acc")
  }
  else
    df <- make_zero_df(nms)

  df2 <- if (nrow(df2)) 
    groupProts(df2, out_path = file.path(out_path, "temp2"), fct = fct)
  else 
    make_zero_df(nms)
  
  df3 <- if (nrow(df3)) 
    groupProts(df3, out_path = file.path(out_path, "temp3"), fct = fct)
  else 
    make_zero_df(nms)
  
  rm(list = c("nms", "df_tier12"))

  # Cleanup
  dfC <- suppressWarnings(
    read_tsv(file.path(out_path, "psmC.txt"), col_types = get_mzion_coltypes()))
  dfC <- dplyr::filter(dfC, pep_issig, !pep_isdecoy, !grepl("^-", prot_acc))
  dfC <- tidyr::unite(dfC, uniq_id, prot_acc, pep_seq, sep = ".", remove = FALSE)

  df  <- post_psmC2Q(df,  dfC, tier = NULL)
  df2 <- post_psmC2Q(df2, dfC, tier = 2L)
  df3 <- post_psmC2Q(df3, dfC, tier = 3L)
  
  rm(list = "dfC")

  # Three-tier combines
  nms_df <- names(df)
  df2 <- df2[, nms_df]
  df3 <- df3[, nms_df]
  rm(list = "nms_df")
  
  max <- max(df$prot_hit_num, na.rm = TRUE)
  
  if (fdr_type == "protein" && combine_tier_three) {
    warning("Coerce to `combine_tier_three = FALSE` at `fdr_type = protein`.",
            call. = FALSE)
    combine_tier_three <- FALSE
  }
  
  if (combine_tier_three) {
    df3 <- df3[!df3[["pep_seq"]] %fin% df[["pep_seq"]], ]
    df <- dplyr::bind_rows(list(df, df3)) # df2 should have no rows
    df <- dplyr::arrange(df, prot_acc, pep_seq)
    readr::write_tsv(df, file.path(out_path, "psmQ.txt"))

    local({
      file_t2 <- file.path(out_path, "psmT2.txt")
      file_t3 <- file.path(out_path, "psmT3.txt")
      
      if (file.exists(file_t2)) {
        message("Delete `psmT2.txt` at `combine_tier_three = TRUE`.")
        unlink(file_t2)
      }
      
      if (file.exists(file_t3)) {
        message("Delete `psmT3.txt` at `combine_tier_three = TRUE`.")
        unlink(file_t3)
      }
    })
  } 
  else {
    df <- dplyr::arrange(df, prot_acc, pep_seq)
    readr::write_tsv(df, file.path(out_path, "psmQ.txt"))

    if (nrow(df2)) {
      df2 <- dplyr::mutate(df2[names(df)], prot_hit_num = prot_hit_num + max)
      readr::write_tsv(df2, file.path(out_path, "psmT2.txt"))
      max <- max(df2[["prot_hit_num"]], na.rm = TRUE)
    }
    
    if (nrow(df3)) {
      df3 <- dplyr::mutate(df3[names(df)], prot_hit_num = prot_hit_num + max)
      readr::write_tsv(df3, file.path(out_path, "psmT3.txt"))
    }
  }

  #  No pepQ.txt and prnQ.txt; use proteoQ for data mining

  invisible(df)
}


#' Post \link{psmC2Q}.
#'
#' @param df A data frame of protein-peptide map.
#' @param dfC A \code{psmQ} data with the removal of non-significant peptides
#'   etc.
#' @param tier The tier of proteins in \code{df}.
post_psmC2Q <- function (df, dfC, tier = NULL) 
{
  if (!is.null(tier))
    df <- dplyr::mutate(df, prot_tier = tier)

  df <- tidyr::unite(df, uniq_id, prot_acc, pep_seq, sep = ".", remove = TRUE)
  df <- dplyr::left_join(df, dfC, by = "uniq_id")
  df <- dplyr::select(df, -uniq_id)

  ord_prots <- c("prot_acc", "prot_issig")
  
  df <- dplyr::bind_cols(
    df[, ord_prots, drop = FALSE], 
    df[, !names(df) %in% ord_prots, drop = FALSE])

  ord_peps <- c("pep_seq", "pep_issig", "pep_literal_unique", 
                "pep_razor_unique", "pep_score", "pep_expect")
  
  df <- dplyr::bind_cols(
    df[, ord_peps, drop = FALSE], 
    df[, !names(df) %in% ord_peps, drop = FALSE])

  df <- dplyr::bind_cols(
    df[grepl("^prot_", names(df))],
    df[grepl("^pep_", names(df))],
    df[grepl("^psm_", names(df))],
    df[!grepl("^prot_|^pep_|^psm_", names(df))])
  
  
  df$pep_exp_mz  <- round(df$pep_exp_mz, digits = 4L)
  df$pep_exp_mr  <- round(df$pep_exp_mr, digits = 4L)
  df$pep_calc_mr <- round(df$pep_calc_mr, digits = 4L)
  df$pep_delta   <- round(df$pep_delta, digits = 4L)
  df$pep_tot_int <- round(df$pep_tot_int, digits = 1L)
  df$pep_expect  <- format(df$pep_expect, digits = 3L)

  df <- dplyr::select(df, -which(names(df) %in% c("prot_n_psm", "prot_n_pep")))
}


#' Checks the compatibility of TMT names and plexes.
#' 
#' @inheritParams matchMS
check_tmt_pars <- function (fixedmods, varmods, quant) 
{
  if (FALSE) {
    # mono-isotopic
    H <- 1.007825035
    O <- 15.99491463
    C <- 12
    N <- 14.003074
    C13 <- 13.00335483
    N15 <- 15.00010897
    
    # average
    H_a <- 1.00794
    O_a <- 15.9994
    C_a <- 12.0107
    C13_a <- C13
    N_a <- 14.0067
    N15_a <- N15
    
    # TMTpro-16
    H * 25 + C * 8 + C13 * 7 + N * 1 + N15 * 2 + O * 3 # 304.207146
    H_a * 25 + C_a * 8 + C13_a * 7 + N_a * 1 + N15_a * 2 + O_a * 3 # 304.312702
    
    # TMTpro-18
    H*(25) + C*(7) + C13*(8) + N*(2) + N15*(1) + O*(3) # 304.213465
    H_a*(25) + C_a*(7) + C13_a*(8) + N_a*(2) + N15_a*(1) + O_a*(3) # 304.311948
    
    # TMTpro-zero
    H*(25) + C*(8) + C*(7) + N + N*(2) + O*(3) # 295.189592
    H_a*(25) + C_a*(8) + C_a*(7) + N_a*(1) + N_a*(2) + O_a*(3) # 295.3773
  }
  
  tmt_msg_1 <- "*** TMT6plex for tmt6, tmt10, tmt11 ***"
  tmt_msg_2 <- "*** TMTpro for tmt16 ***"
  tmt_msg_3 <- "*** TMTpro18 for tmt18 ***"
  
  fvmods <- c(fixedmods, varmods)
  
  if (!grepl("^tmt[0-9]+", quant))
    return(NULL)
  
  tmts <- fvmods[grepl("^TMT", fvmods)]
  
  if (!length(tmts))
    warning("No fixed or variable modifications of TMT were specified at ", 
            "\"quant = ", quant, "\"")
  
  if (quant == "tmt18") {
    ok <- all(grepl("TMTpro18.* |TMT18plex.* ", tmts))
    
    if (!ok) 
      warning("All TMT modifications need to be `TMTpro18` or `TMT18plex` at `", 
              quant, "`.\n", 
              tmt_msg_1, "\n", tmt_msg_2, "\n", tmt_msg_3)
  } 
  else if (quant == "tmt16") {
    ok <- all(grepl("TMTpro.* |TMT16plex.* ", tmts))
    
    if (!ok) 
      warning("All TMT modifications need to be `TMTpro` or `TMT16plex` at `", 
              quant, "`.\n", 
              tmt_msg_1, "\n", tmt_msg_2, "\n", tmt_msg_3)
  } 
  else {
    ok <- all(grepl("TMT6plex.* |TMT10plex.* |TMT11plex.* ", tmts))
    
    if (!ok) 
      warning("All TMT modifications need to be `TMT6plex`, `TMT10plex` or `TMT11plex` at `", 
              quant, "`.\n", 
              tmt_msg_1, "\n", tmt_msg_2, "\n", tmt_msg_3)
  }
  
  invisible(NULL)
}


#' Checks the path of MGF files
#' 
#' @param error Character string; the level of error.
#' @inheritParams matchMS
#' @inheritParams matchMS_par_groups
checkMGF <- function (mgf_path = NULL, grp_args = NULL, error = c("stop", "warn")) 
{
  mgf_path <- find_dir(mgf_path)
  error <- match.arg(error)
  
  if (! error %in% c("warn", "stop"))
    stop("`error` needs to be one of \"error\" or \"stop\".")
  
  if (is.null(mgf_path)) 
    stop("`mgf_path` not found.")
  
  fi_mgf <- list.files(path = file.path(mgf_path), pattern = "^.*\\.mgf$", 
                       ignore.case = TRUE)
  fi_mzml <- list.files(path = file.path(mgf_path), pattern = "^.*\\.mzML$", 
                        ignore.case = TRUE)
  fi_raw <- list.files(path = file.path(mgf_path), pattern = "^.*\\.raw$", 
                       ignore.case = TRUE)
  len_mgf <- length(fi_mgf)
  len_mzml <- length(fi_mzml)
  len_raw <- length(fi_raw)

  if (len_mgf && len_mzml || len_raw && len_mzml || len_mgf && len_raw)
    stop("The type of peak lists need to be only one of RAW, MGF or mzML.")
  
  if (!(len_mgf || len_mzml || len_raw)) {
    if (error == "warn")
      warning("No peak-list files immediately under ", mgf_path)
    else
      stop("No peak-list files immediately under ", mgf_path)
  }
  
  invisible(mgf_path)
}


#' Checks \code{locmods}
#' 
#' Coerced \code{fixedmods} not considered.
#' 
#' @inheritParams matchMS
check_locmods <- function (locmods, fixedmods, varmods, ms1_neulosses = NULL)
{
  if (!length(locmods))
    return(NULL)
  
  if (!is.null(ms1_neulosses)) {
    if (sum(bads <- !ms1_neulosses %in% locmods)) {
      warning("\nPLEASE READ: \n\n", 
              "\"ms1_neulosses\": ", paste(ms1_neulosses[bads], collapse = ", "), 
              " not found in \"locmods\": ", paste(locmods, collapse =, ""), 
              "\n!!! Consider matching some of the \"locmods\" setting to", 
              " \"ms1_neulosses\". !!!\n")
      
      if (FALSE) {
        nls <- lapply(ms1_neulosses, find_unimod)
        nlresids <- lapply(nls, `[[`, "position_site")
        nlresids <- unlist(nlresids, use.names = FALSE, recursive = FALSE)
        
        vs <- lapply(varmods, find_unimod)
        vresids <- lapply(vs, `[[`, "position_site")
        vresids <- unlist(vresids, use.names = FALSE, recursive = FALSE)
      }
    }
  }

  if (!all(oks <- locmods %in% c(fixedmods, varmods))) {
    warning("Ignore \"locmods\" not in \"varmods\" or \"fixedmods\": ", 
            paste(locmods[!oks], collapse = ", "))
    locmods <- locmods[oks]
  }

  if (!length(locmods))
    return(NULL)

  # locmods are only among fixedmods
  if (!length(vids <- which(varmods %in% locmods))) 
    stop("No \"varmods\" matched to \"locmods\": ", paste(locmods, collapse = ", "))
  
  vmods <- find_modps(varmods)
  vsites <- unlist(vmods[vids], recursive = FALSE, use.names = FALSE)
  fmods <- find_modps(fixedmods)
  fids <- which(fmods %in% vsites)
  
  if (length(fids))
    locmods <- c(fixedmods[fids], locmods)

  locmods
}


#' Maps raw_file and scan_title from indexes to real values.
#' 
#' @param df A data frame.
#' @inheritParams matchMS
map_raw_n_scan <- function (df, mgf_path) 
{
  file_raw <- file.path(mgf_path, "raw_indexes.rds")
  
  if (file.exists(file_raw)) {
    raws <- qs::qread(file_raw)
    pos <- match(as.character(df$raw_file), as.character(raws))
    df$raw_file <- names(raws)[pos]
  }
  else {
    stop("File not found: ", file_raw)
  }
  
  files_scan <- list.files(mgf_path, pattern = "^scan_map_.*\\.rds$")

  if (!(len_sc <- length(files_scan))) {
    stop("No `scan_map` files found.")
  }
    
  
  if (len_sc != length(raws))
    stop("The number of `scan_map` files is different to the number of RAWs.")
  
  dfs <- split(df, df$raw_file)
  raws_in_df <- names(dfs)
  ids <- match(raws_in_df, gsub("^scan_map_(.*)\\.rds$", "\\1", files_scan))

  if (any(bads <- is.na(ids))) {
    stop("Files do not have matched `scan_map`", 
         paste(raws_in_df[bads], collapse = ", "))
  }

  files_scan <- files_scan[ids]

  for (i in ids) {
    scans <- qs::qread(file.path(mgf_path, files_scan[[i]]))
    pos <- match(dfs[[i]]$pep_scan_title, as.character(scans))
    dfs[[i]]$pep_scan_title <- names(scans)[pos]
  }
  
  df <- dplyr::bind_rows(dfs)

  invisible(df)
}


#' Maps raw_file and scan_title from indexes to real values.
#' 
#' For backward compatibility.
#' 
#' @param df A data frame.
#' @inheritParams matchMS
map_raw_n_scan_old <- function (df, mgf_path) 
{
  file_raw <- file.path(mgf_path, "raw_indexes.rds")
  file_scan <- file.path(mgf_path, "scan_indexes.rds")
  
  if (file.exists(file_raw)) {
    raws <- qs::qread(file_raw)
    raws2 <- names(raws)
    names(raws2) <- raws
    df$raw_file <- unname(raws2[df$raw_file])
  }
  else {
    stop("File not found: ", file_raw)
  }
  
  if (file.exists(file_scan)) {
    scans <- qs::qread(file_scan)
    scans2 <- names(scans)
    names(scans2) <- scans
    df$pep_scan_title <- unname(scans2[df$pep_scan_title])
  }
  else {
    stop("File not found: ", file_scan)
  }
  
  invisible(df)
}


#' Checks the values of \code{fdr_group}
#' 
#' Not yet used. Takes values of integers or character strings.
#' 
#' @param oks A vector of allowed modification groups.
#' @inheritParams matchMS
check_fdr_group <- function (fdr_group = c("base", "all", "top3"), 
                             oks = c("base", "all"))
{
  is_trivial <- all(is.null(fdr_group)) || all(is.na(fdr_group)) || 
    all(fdr_group == "")
  
  if (is_trivial)
    return(oks[[1]])
  
  len  <- length(fdr_group <- unique(fdr_group))
  oks2 <- fdr_group %in% oks
  
  if (len > 1L)
    fdr_group <- if (all(oks2)) oks[1] else fdr_group[!oks2]

  as.character(fdr_group)
}


#' Checks the compatibility between ms1_notches and ms1_neulosses.
#' 
#' @inheritParams matchMS
check_notches <- function (ms1_notches, ms1_neulosses)
{
  n_notches   <- length(ms1_notches)
  n_neulosses <- length(ms1_neulosses)
  
  if (n_neulosses) {
    cdn_1 <- n_notches == 1L && ms1_notches != 0
    cdn_2 <- n_notches > 1L
    
    if (cdn_1 || cdn_2)
      stop("Not support simultaneous non-trival `ms1_notches` and `ms1_neulosses`.")
  }
}


#' Matches theoretical peptides (parallel by mgf chunks).
#'
#' All files under `out_path` are removed if incur \code{calc_pepmasses} in the
#' upstream.
#'
#' @param aa_masses_all A list of amino acid lookups for all the combination of
#'   fixed and variable modifications.
#' @param mod_indexes Integer; the indexes of fixed and/or variable
#'   modifications.
#' @param ms1_offsets The MS1 off-sets.
#' @param .path_bin The file path to binned precursor masses.
#' @param reframe_mgfs Logical; if TRUE, recalculates the frame indexes of MGFs.
#' @param first_search Logical; is the first search (for MGF mass calibration)
#'   or not.
#' @param .savecall Logical; if TRUE, saves the current call.
#' @inheritParams matchMS
#' @inheritParams load_mgfs
#' @inheritParams frames_adv
#' @inheritParams add_var_masses
#' @import parallel
ms2match <- function (mgf_path, aa_masses_all, out_path, .path_bin, 
                      mod_indexes, type_ms2ions = "by", maxn_vmods_per_pep = 5L, 
                      maxn_sites_per_vmod = 3L, maxn_fnl_per_seq = 3L, 
                      maxn_vnl_per_seq = 3L, maxn_vmods_sitescombi_per_pep = 64L, 
                      minn_ms2 = 6L, ppm_ms1 = 20L, ppm_ms2 = 20L, 
                      min_mass = 200L, max_mass = 4500L, min_ms2mass = 115L, 
                      quant = "none", ppm_reporters = 10L, 
                      reframe_mgfs = FALSE, ms1_offsets = 0, 
                      ms1_neulosses = NULL, maxn_neulosses_fnl = 1L, 
                      maxn_neulosses_vnl = 1L, deisotope_ms2 = TRUE, 

                      # dummies
                      fasta, acc_type, acc_pattern, topn_ms2ions, fixedmods, 
                      varmods, enzyme, maxn_fasta_seqs, maxn_vmods_setscombi, 
                      min_len, max_len, max_miss, 
                      first_search = FALSE, .savecall = TRUE) 
                      
{
  options(digits = 9L)
  
  on.exit(
    if (exists(".savecall", envir = fun_env)) {
      if (.savecall) {
        save_call2(path = file.path(out_path, "Calls"), fun = fun)
      }
    }, add = TRUE)

  # Check cached 
  fun <- as.character(match.call()[[1]])
  fun_env <- environment()
  fml_nms <- names(formals(fun))
  faa <- file.path(out_path, "aa_masses_all.rds")
  
  # (OK as `argument` not for users)
  # min_mass and max_mass only for calib_ms1mass, not to be changed by users
  # args_except <- c("ms1_offsets")
  args_except <- NULL
  fml_incl    <- fml_nms[!fml_nms %in% args_except]
  cache_pars  <- find_callarg_vals(time = NULL, 
                                   path = file.path(out_path, "Calls"), 
                                   fun = paste0(fun, ".rda"), 
                                   args = fml_incl) 
  cache_pars  <- cache_pars[sort(names(cache_pars))]
  call_pars   <- mget(fml_incl, envir = fun_env, inherits = FALSE)
  call_pars   <- call_pars[sort(names(call_pars))]
  
  # backward compatibility of old cached parameters
  if (".path_bin" %in% names(cache_pars) && ".path_bin" %in% names(call_pars)) {
    if (!(is.null(cache_pars$.path_bin) || 
          "fs_path" %in% class(cache_pars$.path_bin))) {
      cache_pars$.path_bin <- fs::fs_path(cache_pars$.path_bin)
    }
    
    if (!(is.null(call_pars$.path_bin) || 
          "fs_path" %in% class(call_pars$.path_bin))) {
      call_pars$.path_bin <- fs::fs_path(call_pars$.path_bin)
    }
  }
  
  if (identical(cache_pars, call_pars)) {
    fions   <- list.files(path = file.path(out_path, "temp"), 
                          pattern = "ion_matches_[0-9]+\\.rds$")

    if (n_fi <- length(fions)) {
      message("Found ", n_fi, " cached ion matches.")

      if (!file.exists(faa))
        qs::qsave(aa_masses_all, faa)
      
      .savecall <- FALSE
      
      return(NULL)
    }
  }
  
  rm(list = c("args_except", "cache_pars", "call_pars"))
  
  delete_files(
    out_path, 
    ignores = c("\\.[Rr]$", "\\.(mgf|MGF)$", "\\.(mzML|mzml)$", "\\.(raw|RAW)$", 
                "\\.xlsx$", "\\.xls$", "\\.csv$", "\\.txt$", "\\.pars$", 
                "^mgf$", "^mgfs$", "^mzML$", "^mzMLs$", "^raw$", 
                "Calls", "^PSM$", "^Peptide$", "^Protein$", 
                "fraction_scheme.rda", "label_scheme.rda", 
                "label_scheme_full.rda"), 
    paths_excluded = mgf_path)

  # pairs expts and theos
  files_a  <-  list.files(mgf_path, pattern = "^expttheo_", full.names = TRUE)
  files_b  <-  list.files(mgf_path, pattern = "^mgftheo_",  full.names = TRUE)
  nfiles_a <- length(files_a)
  nfiles_b <- length(files_b)

  if (nfiles_a && nfiles_b) {
    warning("Both cached `expttheo_` and `mgftheo_` under", mgf_path, ".\n", 
            "Deleting ", paste(files_a, collapse = "\n"))
    file.remove(files_a)
    nfiles_a <- 0L
  }

  # For three-frame searches
  # (matches of secondary ions may use `outer` products and no adjustments)
  ppm_ms1_bin <- calc_threeframe_ppm(ppm_ms1)
  ppm_ms2_bin <- calc_threeframe_ppm(ppm_ms2)
  
  pair_mgftheos(mgf_path = mgf_path, n_modules = length(aa_masses_all), 
                ms1_offsets = comb_ms1_offsets(ms1_offsets = ms1_offsets, 
                                               ms1_neulosses = ms1_neulosses), 
                quant = quant, min_mass = min_mass, max_mass = max_mass, 
                ppm_ms1_bin = ppm_ms1_bin, .path_bin = .path_bin, 
                reframe_mgfs = reframe_mgfs, first_search = first_search)

  rm(list = c("files_a", "files_b", "nfiles_a", "nfiles_b"))

  # MS2 generation functions
  types  <- unlist(lapply(aa_masses_all, attr, "type", exact = TRUE))
  
  funs_ms2 <- lapply(types, function (x) {
    if (x %in% c("amods- tmod- vnl- fnl-", "amods- tmod+ vnl- fnl-"))
      "gen_ms2ions_base"
    else if (x %in% c("amods- tmod- vnl- fnl+", "amods- tmod+ vnl- fnl+"))
      "gen_ms2ions_a0_vnl0_fnl1"
    else if (x %in% c("amods+ tmod- vnl- fnl-", "amods+ tmod+ vnl- fnl-"))
      "gen_ms2ions_a1_vnl0_fnl0"
    else if (x %in% c("amods+ tmod- vnl+ fnl-", "amods+ tmod+ vnl+ fnl-"))
      "gen_ms2ions_a1_vnl1_fnl0"
    else if (x %in% c("amods+ tmod- vnl- fnl+", "amods+ tmod+ vnl- fnl+"))
      "gen_ms2ions_a1_vnl0_fnl1"
    else
      stop("Unknown modification type.")
  })
  
  # other attributes
  ms1vmods_all <- lapply(aa_masses_all, make_ms1vmod_i,
                         maxn_vmods_per_pep = maxn_vmods_per_pep,
                         maxn_sites_per_vmod = maxn_sites_per_vmod)
  ms2vmods_all <- lapply(ms1vmods_all, lapply, make_ms2vmods)
  
  df0 <- tibble::tibble(
    scan_title = integer(), raw_file = integer(), 
    pep_mod_group = integer(), pep_exp_mz = numeric(), 
    pep_exp_mr = numeric(), pep_tot_int = numeric(), 
    pep_exp_z = numeric(), pep_ret_range = numeric(), 
    pep_scan_num = character(), 
    pep_ms2_moverzs = list(list()), 
    pep_ms2_ints = list(list()), 
    pep_n_ms2 = integer(), 
    rptr_moverz = list(list()), 
    rptr_int = list(list()), 
    pep_ms1_offset = numeric(), 
    matches = list(list()), 
    pep_fmod = character(), 
    pep_vmod = character())

  hms2match(
    aa_masses_all = aa_masses_all, 
    funs_ms2 = funs_ms2, 
    ms1vmods_all = ms1vmods_all, 
    ms2vmods_all = ms2vmods_all, 
    ms1_neulosses = ms1_neulosses, 
    maxn_neulosses_fnl = maxn_neulosses_fnl, 
    maxn_neulosses_vnl = maxn_neulosses_vnl, 
    deisotope_ms2 = deisotope_ms2, 
    mod_indexes = mod_indexes, 
    mgf_path = mgf_path, 
    out_path = out_path, 
    type_ms2ions = type_ms2ions, 
    maxn_vmods_per_pep = maxn_vmods_per_pep, 
    maxn_sites_per_vmod = maxn_sites_per_vmod, 
    maxn_fnl_per_seq = maxn_fnl_per_seq, 
    maxn_vnl_per_seq = maxn_vnl_per_seq, 
    maxn_vmods_sitescombi_per_pep = maxn_vmods_sitescombi_per_pep, 
    minn_ms2 = minn_ms2, 
    ppm_ms1 = ppm_ms1_bin, 
    ppm_ms2 = ppm_ms2_bin, 
    min_ms2mass = min_ms2mass, 
    df0 = df0)

  qs::qsave(aa_masses_all, faa)
  
  invisible(NULL)
}


#' Helper of \link{reverse_seqs}.
#' 
#' Reverses \code{pep_seq} in a frame.
#' 
#' @param pep_frame A frame of data.
#' 
#' @examples 
#' ## pep_frame
#' #                                  pep_seq      mass  frame    prot_acc
#' # 2148391     CSCNNGEMCDRFQGCLCSPGWQGLQCER 3694.4923 100001   TIE2_HUMAN
#' # 2148392 EGSARASEQPENAESPDNEDGDCEETTEEAGR 3694.5248 100001  TXLNB_HUMAN
reverse_peps_in_frame <- function (pep_frame) 
{
  nms <- names(pep_frame)
  
  if ("pep_seq" %in% nms) 
    pep_frame[["pep_seq"]]  <- reverse_seqs(pep_frame[["pep_seq"]])

  if ("prot_acc" %in% nms) 
    pep_frame[["prot_acc"]] <- paste0("-", pep_frame[["prot_acc"]])

  pep_frame
}


#' Reverses peptide sequences.
#' 
#' @param seqs Lists of peptide sequences.
#' @examples 
#' \donttest{
#' seqs = c(paste0(LETTERS[1:10], collapse = ""), paste0(letters[1:10], collapse = ""))
#' }
reverse_seqs <- function (seqs) 
{
  fis  <- stringi::stri_sub(seqs, 1L, 1L, use_matrix = FALSE)
  las  <- stringi::stri_sub(seqs, -1L, -1L, use_matrix = FALSE)
  lens <- stringi::stri_length(seqs)
  revs <- stringi::stri_reverse(seqs)
  
  substring(revs, 1)    <- fis
  substring(revs, lens) <- las
  
  revs
}


#' MGF precursor mass calibration.
#'
#' \code{ppm_ms1} only for the calculation of frame indexes of precursors.
#'
#' @param aa_masses_all List(1); The first list of all amino-acid look-ups.
#' @param mod_indexes Integer; the indexes of fixed and/or variable
#'   modifications.
#' @param .path_bin The file path to binned precursor masses.
#' @param reframe_mgfs Logical; if TRUE, recalculates the frame indexes of MGFs
#' @inheritParams matchMS
calib_mgf <- function (mgf_path, aa_masses_all, out_path, .path_bin, 
                       mod_indexes = NULL, type_ms2ions = "by", 
                       maxn_vmods_per_pep = 5L,maxn_sites_per_vmod = 3L, 
                       maxn_fnl_per_seq = 3L, maxn_vnl_per_seq = 3L, 
                       maxn_vmods_sitescombi_per_pep = 64L, minn_ms2 = 6L, 
                       ppm_ms1 = 20L, reframe_mgfs = TRUE, 
                       ppm_ms2 = 20L, min_mass = 200L, 
                       max_mass = 4500L, min_ms2mass = 115L, quant = "none", 
                       ppm_reporters = 10L, 
                       fasta = NULL, acc_type = NULL, 
                       acc_pattern = NULL, topn_ms2ions = 150L, 
                       fixedmods = NULL, varmods = NULL, enzyme = "trypsin_p", 
                       maxn_fasta_seqs = 200000L, maxn_vmods_setscombi = 512L,
                       min_len = 7L, max_len = 40L, max_miss = 2L)
{
  on.exit(
    if (exists(".savecall", envir = fun_env)) {
      if (.savecall) save_call2(path = file.path(out_path, "Calls"), fun = fun)
    }, add = TRUE)

  fun <- as.character(match.call()[[1]])
  fun_env <- environment()
  args <- names(formals(fun))
  args_except <- NULL
  args_must <- if (length(args_except)) args[!args %in% args_except] else args

  cache_pars <- find_callarg_vals(
    time = NULL, 
    path = file.path(out_path, "Calls"), 
    fun = paste0(fun, ".rda"), 
    args = args_must)
  
  cache_pars <- cache_pars[sort(names(cache_pars))]
  call_pars  <- mget(args_must, envir = fun_env, inherits = FALSE)
  call_pars  <- call_pars[sort(names(call_pars))]
  ok_pars    <- identical(call_pars, cache_pars)

  if (ok_pars) {
    message("Mass calibration performed previously. ", 
            "Delete `", paste0(fun, ".rda"), "` to recalibrate.")
    .savecall <- FALSE
    return(NULL)
  }
  
  ## the first search
  tempdir <- file.path(out_path, "temp")
  pat_th <- "^(theo|expt)_\\d+.*\\.rds$"
  pat_im <- "^ion_matches_\\d+.*\\.rds$"
  fs_th <- list.files(mgf_path, pattern = pat_th, full.names = TRUE)
  fs_im <- list.files(tempdir,  pattern = pat_im, full.names = TRUE)
  file.remove(fs_th, recursive = TRUE)
  file.remove(fs_im, recursive = TRUE)
  
  if (!dir.exists(tempdir))
    create_dir(tempdir)

  fi_aa <- file.path(out_path, "aa_masses_all.rds")
  fi_mi <- file.path(out_path, "mod_indexes.txt")

  if (!file.exists(fi_aa))
    stop("Amino-acid look-ups not found: ", fi_aa)
  
  if (!file.exists(fi_mi))
    stop("Amino-acid look-ups not found: ", fi_mi)

  fi_aa2 <- file.path(out_path, "Calls", "aa_masses_all.rds")
  fi_mi2 <- file.path(out_path, "Calls", "mod_indexes.txt")
  file.rename(fi_aa, fi_aa2)
  file.rename(fi_mi, fi_mi2)
  
  ms2match(mgf_path = mgf_path,
           aa_masses_all = aa_masses_all,
           out_path = out_path,
           .path_bin = .path_bin, 
           mod_indexes = mod_indexes, 
           type_ms2ions = type_ms2ions,
           maxn_vmods_per_pep = 1L,
           maxn_sites_per_vmod = 1L,
           maxn_fnl_per_seq = 1L, 
           maxn_vnl_per_seq = 1L, 
           ms1_offsets = 0, 
           ms1_neulosses = NULL, 
           maxn_neulosses_fnl = 1L, 
           maxn_neulosses_vnl = 1L, 
           maxn_vmods_sitescombi_per_pep = 1L,
           minn_ms2 = minn_ms2,
           ppm_ms1 = ppm_ms1,
           ppm_ms2 = ppm_ms2,
           min_mass = min_mass, 
           max_mass = max_mass, 
           min_ms2mass = min_ms2mass,
           quant = "none",
           ppm_reporters = ppm_reporters,
           reframe_mgfs = reframe_mgfs, 
           fasta = fasta,
           acc_type = acc_type,
           acc_pattern = acc_pattern,
           topn_ms2ions = topn_ms2ions,
           fixedmods = fixedmods,
           varmods = varmods,
           enzyme = enzyme,
           maxn_fasta_seqs = maxn_fasta_seqs,
           maxn_vmods_setscombi = maxn_vmods_setscombi,
           min_len = min_len,
           max_len = max_len,
           max_miss = max_miss,
           first_search = TRUE, 
           .savecall = FALSE)
  
  calc_pepscores(topn_ms2ions = topn_ms2ions,
                 type_ms2ions = type_ms2ions,
                 target_fdr = .01,
                 min_len = min_len,
                 max_len = max_len,
                 ppm_ms2 = ppm_ms2,
                 soft_secions = FALSE, 
                 out_path = out_path,
                 min_ms2mass = min_ms2mass,
                 tally_ms2ints = TRUE, 
                 
                 # dummies
                 mgf_path = mgf_path,
                 maxn_vmods_per_pep = 1L,
                 maxn_sites_per_vmod = 1L,
                 maxn_vmods_sitescombi_per_pep = 1L,
                 minn_ms2 = minn_ms2,
                 ppm_ms1 = ppm_ms1,
                 quant = quant,
                 ppm_reporters = ppm_reporters,
                 fasta = fasta,
                 acc_type = acc_type,
                 acc_pattern = acc_pattern,
                 fixedmods = fixedmods,
                 varmods = varmods,
                 enzyme = enzyme,
                 maxn_fasta_seqs = maxn_fasta_seqs,
                 maxn_vmods_setscombi = maxn_vmods_setscombi,
                 add_ms2theos = FALSE, 
                 add_ms2theos2 = FALSE, 
                 add_ms2moverzs = FALSE, 
                 add_ms2ints = FALSE,
                 digits = 4L)
  
  file.rename(fi_aa2, fi_aa)
  file.rename(fi_mi2, fi_mi)
  
  ## mass calibration
  fs_mgf <- list.files(mgf_path, "^mgf_queries_.*\\.rds$")
  fi_ion <- file.path(out_path, "temp", "prescores_1_1.rds")

  if (!length(fs_mgf))
    stop("No `mgf_queries` files found for calibrations.")
  if (!file.exists(fi_ion))
    stop("No `ion_matches` files found for calibrations.")
  
  df <- qs::qread(fi_ion)
  df <- df[with(df, pep_prob <= .01), ]
  
  if (!"raw_file" %in% names(df))
    stop("Column not found in search results: `raw_file`")

  dfs <- split(df, df[["raw_file"]])
  raws <- qs::qread(file.path(mgf_path, "raw_indexes.rds"))
  ord <- match(names(dfs), as.character(raws))
  names(dfs) <- names(raws)[ord]

  ord_mgf <- match(gsub("^mgf_queries_(.*)\\.rds$", "\\1", fs_mgf), names(dfs))
  fs_mgf <- fs_mgf[ord_mgf]

  len <- length(dfs)
  n_cores <- min(len, detect_cores(32L))
  
  if (len <= 2L) {
    mapply(calib_ms1, fs_mgf, dfs, 
           MoreArgs = list(
             mgf_path = mgf_path, out_path = out_path, ppm_ms1 = ppm_ms1, 
             min_mass = min_mass, max_mass = max_mass), 
           SIMPLIFY = FALSE, 
           USE.NAMES = FALSE)
  }
  else {
    cl <- parallel::makeCluster(getOption("cl.cores", n_cores))
    parallel::clusterExport(cl, "calib_ms1", envir = environment(mzion::matchMS))
    
    parallel::clusterMap(
      cl, calib_ms1, fs_mgf, dfs, 
      MoreArgs = list(
        mgf_path = mgf_path, out_path = out_path, ppm_ms1 = ppm_ms1, 
        min_mass = min_mass, max_mass = max_mass), 
      SIMPLIFY = FALSE, 
      USE.NAMES = FALSE)
    
    parallel::stopCluster(cl)
  }
  
  message("Completed precursor mass calibration.\n")

  fs_th <- list.files(mgf_path, pattern = pat_th, full.names = TRUE)
  fs_im <- list.files(tempdir,  pattern = pat_im, full.names = TRUE)
  file.remove(fs_th, recursive = TRUE)
  file.remove(fs_im, recursive = TRUE)
  
  .savecall <- TRUE

  invisible(NULL)
}


#' Calibrates precursor masses (by individual RAW_Files)
#' 
#' @param filename An MGF file name
#' @param df A data frame of \code{ion_matches_1.rds}
#' @param range The range of spine knots
#' @inheritParams calib_mgf
calib_ms1 <- function (filename, df = NULL, mgf_path = NULL, out_path = NULL, 
                       ppm_ms1 = 20L, min_mass = 200L, max_mass = 4500L, 
                       range = 3:6)
{
  n_row <- nrow(df)
  mgfs  <- qs::qread(file.path(mgf_path, filename))
  
  # subsets by minn_ms2 and ms1_int
  if (FALSE) {
    ms1int_co <- quantile(df$ms1_int, probs = .25, na.rm = TRUE)
    df <- df[with(df, ms1_int >= ms1int_co), ]
    
    minn_ok <- lapply(df[["matches"]], function (x) {
      m <- x[[1]][[1]][["m"]]
      (!is.null(m)) && m >= 8L
    })
    minn_ok  <- .Internal(unlist(minn_ok, recursive = FALSE, use.names = FALSE))
    
    df <- df[minn_ok, ]
  }
  
  diff_ms1 <- (df[["pep_exp_mr"]] - df[["theo_ms1"]])/df[["theo_ms1"]] * 1E6
  mdiff <- median(diff_ms1, na.rm = TRUE)/1E6

  if (n_row <= 100L || mdiff <= 1e-6) {
    mgfs[["ms1_mass"]] <- mgfs[["ms1_mass"]] - mdiff
    post_calib(mgfs, min_mass, max_mass, mgf_path, filename)
    .savecall <- TRUE
    return(NULL)
  }
  else {
    cvs <- lapply(range, cv_ms1err, k = 10, df = df) 
    cvs <- unlist(cvs, recursive = FALSE, use.names = FALSE)
    # stopifnot(length(cvs) == length(range))
    
    if (all(is.na(cvs))) {
      mgfs[["ms1_mass"]] <- mgfs[["ms1_mass"]] - mdiff
      post_calib(mgfs, min_mass, max_mass, mgf_path, filename)
      .savecall <- TRUE
      return(NULL)
    }
    
    cvs[is.na(cvs)] <- Inf
    knots <- range[which.min(cvs)]
    
    if (length(knots) > 1L)
      knots <- knots[[1]]
  }
  
  ret_time <- df[["pep_ret_range"]]
  fit_ns <- lm(diff_ms1 ~ splines::ns(ret_time, knots))
  fit_bs <- lm(diff_ms1 ~ splines::bs(ret_time, knots))

  if (all(is.na(fit_ns))) {
    if (all(is.na(fit_bs))) {
      mgfs[["ms1_mass"]] <- mgfs[["ms1_mass"]] - mdiff
      post_calib(mgfs, min_mass, max_mass, mgf_path, filename)
      .savecall <- TRUE
      return(NULL)
    }
    else
      fit_ns <- fit_bs
  }
  else if (all(is.na(fit_bs)))
    fit_bs <- fit_ns
  
  bad_ns <- anyNA(coef(fit_ns))
  bad_bs <- anyNA(coef(fit_bs))
  
  if (bad_ns) {
    if (bad_bs) {
      mgfs[["ms1_mass"]] <- mgfs[["ms1_mass"]] - mdiff
      post_calib(mgfs, min_mass, max_mass, mgf_path, filename)
      .savecall <- TRUE
      return(NULL)
    }
    else
      fit_ns <- fit_bs
  }
  else if (bad_bs)
    fit_bs <- fit_ns

  res_ns <- if (class(fit_ns) == "lm") mean(resid(fit_ns)^2, na.rm = TRUE) else Inf
  res_bs <- if (class(fit_bs) == "lm") mean(resid(fit_bs)^2, na.rm = TRUE) else Inf
  fit    <- if (res_ns <= res_bs) fit_ns else fit_bs
  
  # (keeps the original df$ms1_mass -> can later infer mass deltas)
  # charges <- get_ms1charges(df[["ms1_charge"]])
  # df[["ms1_moverz"]] <- (df[["ms1_mass"]] + 1.00727647 * charges)/charges
  
  ## Update mgf
  rt <- mgfs[["ret_time"]]
  min_rt <- min(ret_time, na.rm = TRUE)
  max_rt <- max(ret_time, na.rm = TRUE)
  
  oks <- if ((min_rt2 <- min_rt * 1.1) < (max_rt2 <- max_rt / 1.2)) {
    rt >= min_rt2 & rt <= max_rt2
  }
  else {
    rt >= min_rt & rt <= max_rt
  }

  ms1err <- predict.lm(fit, newdata = data.frame(ret_time = rt[oks])) / 1E6
  mgfs[["ms1_mass"]][oks] <- mgfs[["ms1_mass"]][oks] * (1 - ms1err)

  uls <- rt[!oks]
  mgfs[["ms1_mass"]][uls] <- mgfs[["ms1_mass"]][uls] - mdiff
  
  # beyond the boundary of RT
  if (FALSE) {
    rts_ok <- rt[oks]
    err_le <- ms1err[which.min(rts_ok)]
    err_gr <- ms1err[which.max(rts_ok)]
    
    ms1_le <- mgfs[["ms1_mass"]][!oks_le]
    ms1_gr <- mgfs[["ms1_mass"]][!oks_gr]
    mgfs[["ms1_mass"]][!oks_le] <- ms1_le - ms1_le * err_le
    mgfs[["ms1_mass"]][!oks_gr] <- ms1_gr - ms1_gr * err_gr
  }
  
  ## update MGF
  # charges <- get_ms1charges(mgfs[["ms1_charge"]])
  # mgfs[["ms1_moverz"]] <- (mgfs[["ms1_mass"]] + 1.00727647 * charges)/charges
  post_calib(mgfs, min_mass, max_mass, mgf_path, filename)
  .savecall <- TRUE

  invisible(NULL)
}


#' Cross-validation of mass error at a given number of knots
#' 
#' @param df A data frame of search results.
#' @param m The number of knots for fitting.
#' @param k The fold of cross-valications
cv_ms1err <- function(m = 3L, k = 5L, df)
{
  if (!is.data.frame(df))
    stop("Input is a not data frame.")
  
  if ((nr <- nrow(df)) < 50L)
    return(NA_real_)
  
  cv_errs <- vector("list", k)
  folds <- create_folds(seq_len(nr), k = k)
  
  for (i in seq_len(k)) {
    fdi <- folds[[i]]
    tei <- df[fdi, ]
    tri <- df[-fdi, ]
    
    ret_time <- tei[["pep_ret_range"]]
    deltas <- (tei[["pep_exp_mr"]] - tei[["theo_ms1"]])/tei[["theo_ms1"]] * 1E6
    fit <- lm(deltas ~ splines::ns(ret_time, m))
    
    if (all(is.na(fit)) || anyNA(coef(fit)))
      cv_errs[i] <- list(NULL)
    
    tri_rt <- tri[["pep_ret_range"]]
    min_rt <- min(tri_rt, na.rm = TRUE)
    max_rt <- max(tri_rt, na.rm = TRUE)
    
    oks <- if ((min_rt2 <- min_rt * 1.1) < (max_rt2 <- max_rt / 1.2)) {
      tri_rt >= min_rt2 & tri_rt <= max_rt2
    }
    else {
      tri_rt >= min_rt & tri_rt <= max_rt
    }
    
    tri_rt <- tri_rt[oks]
    prd <- predict.lm(fit, newdata = data.frame(ret_time = tri_rt)) / 1E6
    cv_errs[[i]] <- mean(prd^2, na.rm = TRUE)
  }
  
  # return NA at all NUll
  mean(unlist(cv_errs, recursive = FALSE, use.names = FALSE), na.rm = TRUE)
}


#' Post MS1 calibrations.
#' 
#' @param mgfs MGF data.
#' @param filename An MGF file name
#' @inheritParams matchMS
post_calib <- function (mgfs, min_mass, max_mass, mgf_path, filename)
{
  mgfs <- mgfs |>
    dplyr::arrange(ms1_mass) |> 
    dplyr::filter(ms1_mass >= min_mass, ms1_mass <= max_mass)
  
  qs::qsave(mgfs, file.path(mgf_path, filename), preset = "fast")
}


#' Finds off-sets in precursor masses.
#'
#' @inheritParams matchMS
#' @return A vector of mass off-sets.
find_ms1_offsets <- function (n_13c = 0L, ms1_notches = 0) 
{
  if (dups <- anyDuplicated(n_13c)) {
    warning("At least one duplicated value in `n_13c`: ", n_13c[dups])
    n_13c <- unique(n_13c)
  }

  if (dups <- anyDuplicated(ms1_notches)) {
    warning("At least one duplicated values in `ms1_offsets`: ", 
            ms1_notches[dups])
    ms1_notches <- unique(ms1_notches)
  }

  offsets_13c <- if (length(n_13c)) n_13c * 1.00335483 else NULL
  ms1_offsets <- unique(c(0, offsets_13c, ms1_notches))
  ms1_offsets <- round(ms1_offsets, digits = 4L)
}


#' Combines off-sets in precursor masses (notches and neutral losses).
#'
#' The return contains no information of Unimod titles and positions since it is
#' only used for pairing with experimental MGF data.
#'
#' @param ms1_offsets Precursor mass off-sets (notches, not neutral losses).
#' @inheritParams matchMS
#' @return A vector of mass off-sets.
comb_ms1_offsets <- function (ms1_offsets = 0, ms1_neulosses = NULL)
{
  if (dups <- anyDuplicated(ms1_neulosses))
    stop("At least one duplicated values in `ms1_neulosses`: ", 
         ms1_neulosses[dups])

  if ((!(nnl <- length(ms1_neulosses))) || (nnl == 1L && nnl == 0)) 
    return(ms1_offsets)
  
  nls <- extract_umods(ms1_neulosses)
  nls <- unique(unlist(lapply(nls, `[[`, "nl")))
  nls <- -nls[nls != 0]
  
  round(unique(c(ms1_offsets, nls)), digits = 4L)
}


#' mzion: A package for proteomic database searches of mass spectrometry data.
#'
#' The mzion package provides utilities for (1) database searches. The
#' companion package proteoQ provides utilities for (2) data preprocessing, (3)
#' annotation, (4) quality assurance assessments and (5) informatic analysis.
#'
#' @section Main utility in database searches: matchMS (additional UI tools:
#'   mapMS2ions, load_fasta2, parse_unimod, table_unimods, add_unimod, 
#'   calc_monopeptide, calc_ms2ionseries)
#'
'_PACKAGE'
#' Helper in preparing mzML inputs.
#' 
#' @param filelist A list of mzML files.
#' @param data_type A data type of either mzML or RAW.
#' @inheritParams load_mgfs
readmzML <- function (filelist = NULL, mgf_path = NULL, data_type = "mzml", 
                      topn_ms2ions = 150L, topn_dia_ms2ions = 2400L, 
                      delayed_diams2_tracing = FALSE, 
                      maxn_dia_precurs = 1000L, 
                      n_dia_ms2bins = 1L, n_dia_scans = 4L, 
                      min_mass = 200L, max_mass = 4500L, 
                      min_ms2mass = 115L, max_ms2mass = 4500L, 
                      min_ms1_charge = 2L, max_ms1_charge = 4L, 
                      min_scan_num = 1L, max_scan_num = .Machine$integer.max, 
                      min_ret_time = 0, max_ret_time = Inf, 
                      ppm_ms1 = 10L, ppm_ms2 = 10L, 
                      tmt_reporter_lower = 126.1, tmt_reporter_upper = 135.2, 
                      exclude_reporter_region = FALSE, 
                      is_ms1_three_frame = TRUE, is_ms2_three_frame = TRUE, 
                      mgf_cutmzs = numeric(), mgf_cutpercs = numeric(), 
                      enzyme = "trypsin_p", 
                      deisotope_ms2 = TRUE, grad_isotope = 1.6, fct_iso2 = 3.0,
                      max_ms2_charge = 3L, use_defpeaks = FALSE, 
                      maxn_mdda_precurs = 1L, n_mdda_flanks = 6L, 
                      ppm_ms1_deisotope = 8L, ppm_ms2_deisotope = 8L, 
                      quant = "none", use_lfq_intensity = TRUE, digits = 4L)
{
  # - hloadMZML (helper)
  #   - loadMZML
  #     - extrDIA
  #     - extrDDA
  # 
  # [Y] is_dia?
  # - hdeisoDIA (helper)
  #   - deisoDIA
  # - hsubDIAMS1 (helper)
  #   - subDIAMS1
  # - htraceDIA (helper)
  #   - traceDIA
  #     -traceLCMS
  # 
  # [Y] is_dda?
  # - hdeisoDDA (helper)
  #   - deisoDDA
  #     - getMS1xyz
  #     - getMS2xyz
  
  
  # traceLCMS
  #   - collapse_xyz
  #     - mapcoll_xyz
  #     - find_gates
  #       - find_gate_edges
  #   - find_lc_gates
  #     - fill_lc_gaps
  #     - find_gate_edges
  # 
  # - find_mdda_mms1s
  #   - collapse_mms1ints
  #     - find_gates
  #       - find_gate_edges
  #   - find_ms1stat
  # 

  # mzML may contains NULL entries and need additional handling
  qs::qsave(data_type, file.path(mgf_path, "data_type.rds"), preset = "fast")
  
  temp_dir <- create_dir(file.path(mgf_path, "temp_dir"))
  
  if (data_type == "raw") {
    message("Processing RAW files")
    peakfiles <- readRAW(mgf_path = mgf_path, filelist = filelist)
  }
  else if (data_type == "mzml") {
    message("Processing mzML files.")
    peakfiles <- hloadMZML(filelist, mgf_path, temp_dir)
    gc() # free up xml pointers
  }
  else {
    is_dia <- FALSE
    peakfiles <- "01CPTAC3_Benchmarking_W_BI_20170508_BL_f02.raw.rds"
    mzml_type <- "pwiz_3d"
    
    is_dia <- FALSE
    peakfiles <- "01CPTAC3_Benchmarking_W_BI_20170508_BL_f02.raw.rds"
    mzml_type <- "raw"
  }
  
  peakfile1 <- peakfiles[[1]]
  is_dia <- attr(peakfile1, "is_dia", exact = TRUE)
  mzml_type <- attr(peakfile1, "mzml_type", exact = TRUE)
  peakfiles <- unlist(peakfiles)
  
  lenf <- length(peakfiles)
  rams <- find_free_mem()/1024
  n_pcs <- detect_cores(64L) - 1L
  n_cores <- max(min(n_pcs, ceiling(rams/5L), lenf), 1L)
  r_cores <- round(n_pcs/n_cores)
  n_para <- max(min(n_pcs, r_cores), 1L)

  if (isTRUE(is_dia)) {
    message("Deisotoping DIA-MS.")

    # `else` is only slightly faster than `if` 
    if (n_cores <= 1L) {
      
      # need to average flanking spectra prior to deisotoping...
      
      if (TRUE) {
        dia_files <- lapply(
          peakfiles, hdeisoDIA,
          temp_dir = temp_dir, 
          min_mass = min_mass, max_mass = max_mass,
          min_ms2mass = min_ms2mass, max_ms2mass = max_ms2mass, 
          maxn_dia_precurs = maxn_dia_precurs, 
          topn_dia_ms2ions = topn_dia_ms2ions, 
          min_ms1_charge = min_ms1_charge, 
          max_ms1_charge = max_ms1_charge, 
          min_ret_time = min_ret_time, 
          max_ret_time = max_ret_time, 
          ppm_ms1_deisotope = ppm_ms1_deisotope, 
          ppm_ms2_deisotope = ppm_ms2_deisotope, 
          deisotope_ms2 = deisotope_ms2, 
          max_ms2_charge = max_ms2_charge, 
          grad_isotope = grad_isotope, 
          fct_iso2 = fct_iso2, 
          quant = quant, 
          tmt_reporter_lower = tmt_reporter_lower, 
          tmt_reporter_upper = tmt_reporter_upper, 
          exclude_reporter_region = exclude_reporter_region, 
          n_para = n_para)
      }
      else {
        dia_files <- "dia_23aug2017_hela_serum_timecourse_wide_1a.raw.rds"
      }
    }
    else {
      cl <- parallel::makeCluster(getOption("cl.cores", n_cores))
      dia_files <- parallel::clusterApply(
        cl, peakfiles, hdeisoDIA,
        temp_dir = temp_dir, 
        min_mass = min_mass, max_mass = max_mass,
        min_ms2mass = min_ms2mass, max_ms2mass = max_ms2mass, 
        maxn_dia_precurs = maxn_dia_precurs, 
        topn_dia_ms2ions = topn_dia_ms2ions, 
        min_ms1_charge = min_ms1_charge, 
        max_ms1_charge = max_ms1_charge, 
        min_ret_time = min_ret_time, 
        max_ret_time = max_ret_time, 
        ppm_ms1_deisotope = ppm_ms1_deisotope, 
        ppm_ms2_deisotope = ppm_ms2_deisotope, 
        deisotope_ms2 = deisotope_ms2, 
        max_ms2_charge = max_ms2_charge, 
        grad_isotope = grad_isotope, 
        fct_iso2 = fct_iso2, 
        quant = quant, 
        tmt_reporter_lower = tmt_reporter_lower, 
        tmt_reporter_upper = tmt_reporter_upper, 
        exclude_reporter_region = exclude_reporter_region, 
        n_para = n_para)
      parallel::stopCluster(cl)
    }

    message("Subset DIA-MS1 by isolation windows.")
    n_para2 <- min(n_para, 8L) # 8L: not rate-limiting
    
    if (n_cores <= 1L) {
      if (TRUE) {
        subfiles <- lapply(dia_files, hsubDIAMS1, temp_dir = temp_dir, 
                           n_para = n_para2)
      }
      else {
        subfiles <- qs::qread(file.path(temp_dir, "subfiles.rds"))
      }
      
    }
    else {
      cl <- parallel::makeCluster(getOption("cl.cores", n_cores))
      subfiles <- parallel::clusterApply(
        cl, dia_files, hsubDIAMS1, temp_dir = temp_dir, n_para = n_para2)
      parallel::stopCluster(cl)
    }
    
    message("Tracing DIA-MS.")
    n_para3 <- max(floor(min(n_para, 26L/lenf)), 1L)
    if (lenf > n_para3) n_para3 <- find_min_ncores(lenf, n_para3)
    
    if (n_cores <= 1L) {
      raws <- mapply(
        htraceDIA, 
        subfiles, seq_along(subfiles), 
        MoreArgs = list(
          temp_dir = temp_dir, 
          mgf_path = mgf_path, 
          min_ret_time = min_ret_time, 
          max_ret_time = max_ret_time, 
          min_mass = min_mass, 
          max_mass = max_mass, 
          min_ms2mass = min_ms2mass, 
          max_ms2mass = max_ms2mass, 
          ppm_ms1 = ppm_ms1_deisotope, 
          ppm_ms2 = ppm_ms2_deisotope, 
          n_dia_ms2bins = n_dia_ms2bins, 
          n_dia_scans = n_dia_scans, 
          topn_dia_ms2ions = topn_dia_ms2ions, 
          delayed_diams2_tracing = delayed_diams2_tracing, 
          mgf_cutmzs = mgf_cutmzs, 
          mgf_cutpercs = mgf_cutpercs, 
          quant = quant, 
          tmt_reporter_lower = tmt_reporter_lower, 
          tmt_reporter_upper = tmt_reporter_upper, 
          exclude_reporter_region = exclude_reporter_region, 
          n_para = n_para3), 
        SIMPLIFY = FALSE, USE.NAMES = FALSE)
    }
    else {
      cl <- parallel::makeCluster(getOption("cl.cores", n_cores))
      raws <- parallel::clusterMap(
        cl, htraceDIA, 
        subfiles, seq_along(subfiles), 
        MoreArgs = list(
          temp_dir = temp_dir, 
          mgf_path = mgf_path, 
          min_ret_time = min_ret_time, 
          max_ret_time = max_ret_time, 
          min_mass = min_mass, 
          max_mass = max_mass, 
          min_ms2mass = min_ms2mass, 
          max_ms2mass = max_ms2mass, 
          ppm_ms1 = ppm_ms1_deisotope, 
          ppm_ms2 = ppm_ms2_deisotope, 
          n_dia_ms2bins = n_dia_ms2bins, 
          n_dia_scans = n_dia_scans,
          topn_dia_ms2ions = topn_dia_ms2ions, 
          delayed_diams2_tracing = delayed_diams2_tracing, 
          mgf_cutmzs = mgf_cutmzs, 
          mgf_cutpercs = mgf_cutpercs, 
          quant = quant, 
          tmt_reporter_lower = tmt_reporter_lower, 
          tmt_reporter_upper = tmt_reporter_upper, 
          exclude_reporter_region = exclude_reporter_region, 
          n_para = n_para3), 
        SIMPLIFY = FALSE, USE.NAMES = FALSE)
      parallel::stopCluster(cl)
    }
  }
  else {
    message("Deisotoping DDA-MS.")

    if (n_cores <= 1L) {
      raws <- mapply(
        hdeisoDDA, 
        peakfiles, seq_along(peakfiles), 
        MoreArgs = list(
          mgf_path = mgf_path, 
          temp_dir = temp_dir, 
          mzml_type = mzml_type, 
          ppm_ms1 = ppm_ms1, ppm_ms2 = ppm_ms2, 
          maxn_mdda_precurs = maxn_mdda_precurs, 
          topn_ms2ions = topn_ms2ions, 
          n_mdda_flanks = n_mdda_flanks, 
          n_dia_scans = n_dia_scans, 
          min_mass = min_mass, max_mass = max_mass, 
          min_ms2mass = min_ms2mass, max_ms2mass = max_ms2mass, 
          min_ms1_charge = min_ms1_charge, max_ms1_charge = max_ms1_charge, 
          min_ret_time = min_ret_time, max_ret_time = max_ret_time, 
          min_scan_num = min_scan_num, max_scan_num = max_scan_num, 
          deisotope_ms2 = deisotope_ms2, max_ms2_charge = max_ms2_charge, 
          ppm_ms1_deisotope = ppm_ms1_deisotope, 
          ppm_ms2_deisotope = ppm_ms2_deisotope, 
          grad_isotope = grad_isotope, fct_iso2 = fct_iso2, 
          mgf_cutmzs = mgf_cutmzs, 
          mgf_cutpercs = mgf_cutpercs, 
          quant = quant, 
          use_lfq_intensity = use_lfq_intensity, 
          tmt_reporter_lower = tmt_reporter_lower, 
          tmt_reporter_upper = tmt_reporter_upper, 
          exclude_reporter_region = exclude_reporter_region, 
          use_defpeaks = use_defpeaks, 
          n_para = n_para
        ), SIMPLIFY = FALSE, USE.NAMES = FALSE)
    }
    else {
      cl <- parallel::makeCluster(getOption("cl.cores", n_cores))
      raws <- parallel::clusterMap(
        cl, hdeisoDDA, 
        peakfiles, seq_along(peakfiles), 
        MoreArgs = list(
          mgf_path = mgf_path, 
          temp_dir = temp_dir, 
          mzml_type = mzml_type, 
          ppm_ms1 = ppm_ms1, ppm_ms2 = ppm_ms2, 
          maxn_mdda_precurs = maxn_mdda_precurs, 
          topn_ms2ions = topn_ms2ions, 
          n_mdda_flanks = n_mdda_flanks, 
          n_dia_scans = n_dia_scans, 
          min_mass = min_mass, max_mass = max_mass, 
          min_ms2mass = min_ms2mass, max_ms2mass = max_ms2mass, 
          min_ms1_charge = min_ms1_charge, max_ms1_charge = max_ms1_charge, 
          min_ret_time = min_ret_time, max_ret_time = max_ret_time, 
          min_scan_num = min_scan_num, max_scan_num = max_scan_num, 
          deisotope_ms2 = deisotope_ms2, max_ms2_charge = max_ms2_charge, 
          ppm_ms1_deisotope = ppm_ms1_deisotope, 
          ppm_ms2_deisotope = ppm_ms2_deisotope, 
          grad_isotope = grad_isotope, fct_iso2 = fct_iso2, 
          mgf_cutmzs = mgf_cutmzs, 
          mgf_cutpercs = mgf_cutpercs, 
          quant = quant, 
          use_lfq_intensity = use_lfq_intensity, 
          tmt_reporter_lower = tmt_reporter_lower, 
          tmt_reporter_upper = tmt_reporter_upper, 
          exclude_reporter_region = exclude_reporter_region, 
          use_defpeaks = use_defpeaks, 
          n_para = n_para
        ), SIMPLIFY = FALSE, USE.NAMES = FALSE)
      parallel::stopCluster(cl)
    }
  }

  message("Completed deisotoping at: ", Sys.time())
  raws <- unlist(raws, recursive = FALSE, use.names = TRUE)
  qs::qsave(raws, file.path(mgf_path, "raw_indexes.rds"), preset = "fast")
  
  type_acqu <- if (is_dia) "dia" else "dda"
}


#' Helper of \link{loadMZML}.
#'
#' @param temp_dir A temporary file folder.
#' @inheritParams readMGF
#' @inheritParams matchMS
hloadMZML <- function (filelist = NULL, mgf_path = NULL, temp_dir = NULL)
{
  if (FALSE) {
    if (maxn_mdda_precurs > 1L && use_defpeaks) {
      warning("Default peaks not used at maxn_mdda_precurs > 1;", 
              "\nCoerce to use_defpeaks = FALSE.")
      use_defpeaks <- FALSE
    }
  }
  
  len <- length(filelist)
  files <- file.path(mgf_path, filelist)
  sizes <- max(unlist(lapply(files, file.size)))/1024^3
  n_cores <- min(detect_cores(32L), 
                 ceiling(find_free_mem()/1024/sizes/7.5 + 1), 
                 len)
  n_cores <- find_min_ncores(len, n_cores) 
  n_cores <- max(1L, n_cores)
  
  if (n_cores <= 1L) {
    out_names <- vector("list", len)
    
    for (i in 1:len) {
      out_names[[i]] <- loadMZML(files[[i]], temp_dir = temp_dir)
    }
  }
  else {
    cl <- parallel::makeCluster(getOption("cl.cores", n_cores))
    out_names <- parallel::clusterApply(cl, files, loadMZML, temp_dir = temp_dir)
    parallel::stopCluster(cl)
  }
  
  invisible(out_names)
}


#' Loads mzML from MSConvert.
#' 
#' For single mzML file.
#'
#' @param xml_file A file name of mzML.
#' @param temp_dir A temporary file folder.
loadMZML <- function (xml_file = NULL, temp_dir = NULL)
{
  ## spectrum
  xml_root <- xml2::read_xml(xml_file)
  mzML <- xml2::xml_child(xml_root)
  mzC <- xml2::xml_children(mzML)
  
  idx_sw <- which(xml2::xml_name(mzC) == "softwareList")
  softwares <- mzC[[idx_sw]]
  softwaresC <- xml2::xml_children(softwares)
  
  ###
  software_ids <- unlist(lapply(softwaresC, xml2::xml_attr, "id"))
  idx_pwiz <- which(software_ids == "pwiz")
  
  if (length(idx_pwiz)) {
    is_pwiz <- TRUE
    is_3d <- TRUE
  } else {
    idx_pwiz <- which(software_ids == "pwiz_Reader_Bruker") # 3L
    
    if (length(idx_pwiz)) {
      is_pwiz <- TRUE
      is_3d <- FALSE # 4-D ion mobility
    } else {
      if (length(idx_msf <- which(software_ids == "MSFragger"))) {
        is_pwiz <- FALSE
        is_3d <- TRUE
        idx_pwiz <- idx_msf
      } else {
        is_pwiz <- TRUE
        is_3d <- FALSE
        idx_pwiz <- 3L
      }
    }
  }
  
  if (is_pwiz) {
    if (is_3d) {
      mzml_type <- "pwiz_3d"
    } else {
      stop("MSConvert timsTOF not yet supported.")
    }
  } else {
    if (is_3d) {
      mzml_type <- "msf_3d" # for timsTOF
    } else {
      stop("MSFragger mzML not yet supported.")
    }
  }

  pwiz <- softwaresC[[idx_pwiz]]
  pwiz_ver <- xml2::xml_attr(pwiz, "version")
  pwiz_ver <- strsplit(pwiz_ver, ".", fixed = TRUE)[[1]]
  
  if ((len_pwiz <- length(pwiz_ver)) >= 2L) {
    pwiz_ver_major <- as.numeric(paste0(pwiz_ver[[1]], ".", pwiz_ver[[2]]))
  } else if (len_pwiz == 1L) {
    pwiz_ver_major <- as.numeric(pwiz_ver)
  } else {
    warning("Unknown MSConvert version.")
    pwiz_ver_major <- 3.0
  }
  
  if (pwiz_ver_major < 3) {
    stop("Use MSConvert version >= 3.0.")
  }
  
  raw_file <- local({
    idx_file <- which(xml2::xml_name(mzC) == "fileDescription")
    file_des <- mzC[[idx_file]]
    idx_srcl <- which(xml2::xml_name(xml2::xml_children(file_des)) == "sourceFileList")
    info_raw <- xml2::xml_children(file_des)[[idx_srcl]]
    idx_srcf <- which(xml2::xml_name(xml2::xml_children(info_raw)) == "sourceFile")
    
    if (length(idx_srcf) == 1L) {
      info_fi  <- xml2::xml_children(info_raw)[[idx_srcf]]
      raw_file <- xml2::xml_attr(info_fi, "name")
    } else { # timsTOF
      idx_srcf <- idx_srcf[[1]]
      info_fi  <- xml2::xml_children(info_raw)[[idx_srcf]]
      raw_file <- xml2::xml_attr(info_fi, "id")
      raw_file <- gsub("(^.*\\.d)_.*\\.tdf$", "\\1", raw_file)
    }
  })
  
  idx_run <- which(xml2::xml_name(mzC) == "run")
  run <- mzC[[idx_run]]
  idx_specs <- which(xml2::xml_name(xml2::xml_children(run)) == "spectrumList")
  spec <- xml2::xml_children(xml2::xml_children(run)[[idx_specs]])
  rm(list = c("mzML", "mzC", "idx_run", "run", "idx_specs", "idx_sw", 
              "softwares", "softwaresC", "idx_pwiz", "pwiz", "pwiz_ver", 
              "pwiz_ver_major", "len_pwiz"))
  
  # - mzML
  #   - ...
  #   - fileDescription
  #     - ...
  #     - sourceFileList
  #       - sourceFile
  
  # - run
  #  - spectrumList
  #   - spectrum # x
  #     - ...
  #     - <cvParam ... name="ms level" value="2"/>
  #     - <cvParam ... name="total ion current" value="2578.8672"/>
  #     - <cvParam ... name="spectrum title" value="23aug2017_hela_serum_timecourse_4mz_narrow_1.1.1. 
  #                    File:"FILENAME.raw", ...originalScan=1 demux=0 scan=1/>
  #     - scanList # xc
  #       - ...
  #       - <scan ... originalScan=3 demux=1 scan=4> # originalScan=3 demux=1 scan=4 only only for MS2
  #         - <cvParam ... name="scan start time" value="0.012728725" .../>
  #         - <cvParam ... name="ion injection time" value="54.999999701977" .../>
  #     - precursorList # xc
  #       - <precursor ... originalScan=3 demux=1 scan=4"> # redundant?
  #         - <cvParam ... name="isolation window target m/z" value="401.432342529297" .../>
  #         - selectedIonList
  #           - selectedIon
  #             -  <cvParam ... name="selected ion m/z" value="401.432342529297" .../>
  #             -  <cvParam ... name="charge state" value="3" .../> # No charge state if DIA
  #             -  <cvParam ... name="peak intensity" value="0" .../> # 0 if DIA
  #     - binaryDataArrayList # xc
  #       - binaryDataArray
  #         - binary
  #       - binaryDataArray
  #         - binary
  #  - chromatogramList
  #   - chromatogram
  #    - binaryDataArrayList
  #     - binaryDataArray # name="time array"
  #     - binaryDataArray # name="intensity array"
  #     - binaryDataArray # name="non-standard data array"
  
  ###
  if (mzml_type == "msf_3d") {
    # find_mzml_indexes(spec)
  }
  ###
  
  
  ## the first scan
  x <- spec[[1]]
  ids <- .Internal(strsplit(xml2::xml_attr(x, "id"), " ", fixed = TRUE, 
                            perl = FALSE, useBytes = FALSE))[[1]]
  ids <- .Internal(strsplit(ids, "=", fixed = TRUE, 
                            perl = FALSE, useBytes = FALSE))
  id_nms <- lapply(ids, `[[`, 1)
  idx_demux <- which(id_nms == "demux")
  is_demux <- if (length(idx_demux)) TRUE else FALSE
  
  if (is_3d) {
    idx_sc <- which(id_nms == "scan")
    if (!length(idx_osc <- which(id_nms == "originalScan"))) idx_osc <- idx_sc
    idx_sc_start <- idx_sc_end <- idx_osc
  } else {
    idx_sc_start <- which(id_nms == "scanStart") # 3
    idx_sc_end <- which(id_nms == "scanEnd") # 4
    idx_osc <- idx_sc <- idx_sc_start
    # c(idx_sc_start, idx_sc_end) # length(2)
  }
  
  xc <- xml2::xml_children(x)
  xcp_attrs <- xml2::xml_attrs(xc[which(xml2::xml_name(xc) == "cvParam")])
  xcp_names <- lapply(xcp_attrs, `[[`, "name")
  xcp_vals <- lapply(xcp_attrs, `[[`, "value")
  idx_mslev <- which(xcp_names == "ms level")
  idx_title <- which(xcp_names == "spectrum title")
  rm(list = c("x", "ids", "xc", "xcp_attrs", "xcp_names", "xcp_vals", "id_nms"))
  
  # MS2 indexes (no MS1 with DDA -> MS2 goes first)
  len <- length(spec)
  rng <- max(floor(len/2L), 1L):len
  allowance <- min(100L, len)
  count <- 0L
  
  if (!len) {
    stop("No spectrum data found.")
  }
  
  for (i in rng) {
    # i=46
    # i = 6000
    x <- spec[[i]]
    xc <- xml2::xml_children(x)
    
    if (xml2::xml_attr(xc[[idx_mslev]], "value") == "2") {
      if (is_3d) {
        idx_scan_lwr_2 <- grep("lowest observed m/z", xc)
        if (!length(idx_scan_lwr_2)) {
          warning("Fields of `lowest observed m/z` not found.")
          idx_scan_lwr_2 <- 8L
        }
      } else {
        idx_scan_lwr_2 <- grep("ion mobility lower limit", xc)
        if (!length(idx_scan_lwr_2)) {
          warning("Fields of `ion mobility lower limit` not found.")
          idx_scan_lwr_2 <- 8L
        }
      }
      
      if (is_3d) {
        idx_scan_upr_2 <- grep("highest observed m/z", xc)
        if (!length(idx_scan_upr_2)) {
          warning("Fields of `highest observed m/z` not found.")
          idx_scan_upr_2 <- 9L
        }
      } else {
        idx_scan_upr_2 <- grep("ion mobility upper limit", xc)
        if (!length(idx_scan_upr_2)) {
          warning("Fields of `ion mobility upper limit` not found.")
          idx_scan_upr_2 <- 9L
        }
      }
      
      idx_precursor_2 <- grep("precursorList", xc)
      if (!length(idx_precursor_2)) {
        warning("Fields of `precursorList` not found.")
        idx_precursor_2 <- if (is_3d) 12L else 11L
      }
      
      idx_scanList_2 <- grep("scanList", xc)
      if (!length(idx_scanList_2)) {
        warning("Fields of `scanList` not found.")
        idx_scanList_2 <- if (is_3d) 11L else 10L
      }
      
      idx_bin_2 <- grep("binaryDataArrayList", xc)
      if (!length(idx_bin_2)) {
        warning("Fields of `binaryDataArrayList` not found.")
        idx_bin_2 <- if (is_3d) 13L else 12L
      }
      
      scanList <- xml2::xml_children(xc[[idx_scanList_2]])
      
      # !!! a range if timsTOF
      idx_rt_2 <- which(xml2::xml_name(scanList) == "scan")
      if (length(idx_rt_2)) {
        idx_rt_2 <- idx_rt_2[[1]]
      } else {
        warning("Fields of `scan` not found.")
        idx_rt_2 <- 2L
      }
      
      scanList_ret <- xml2::xml_children(scanList[[idx_rt_2]])
      scanList_ret_attrs <- xml2::xml_attr(scanList_ret, "name")
      
      idx_scan_start_2 <- which(scanList_ret_attrs == "scan start time") # 1
      if (!length(idx_scan_start_2)) {
        warning("Fields of `scan start time` not found.")
        idx_scan_start_2 <- 1L
      }
      
      if (is_3d) {
        if (is_pwiz) {
          idx_ms2_reso <- which(scanList_ret_attrs == "mass resolving power")
          if (length(idx_ms2_reso)) {
            ms2_reso <- scanList_ret[[idx_ms2_reso]]
            ms2_reso <- as.integer(xml2::xml_attr(ms2_reso, "value"))
          } else {
            warning("Fields of `mass resolving power` not found.")
            ms2_reso <- 120000L
          }
        } else { # MSFragger timsTOF
          idx_ms2_reso <- which(scanList_ret_attrs == "inverse reduced ion mobility")
          if (length(idx_ms2_reso)) {
            ms2_reso <- scanList_ret[[idx_ms2_reso]]
            ms2_reso <- as.numeric(xml2::xml_attr(ms2_reso, "value"))
          } else {
            warning("Fields of `inverse reduced ion mobility` not found.")
            ms2_reso <- 1L
          }
        }
      } else {
        idx_ms2_reso <- which(scanList_ret_attrs == "inverse reduced ion mobility")
        if (length(idx_ms2_reso)) {
          ms2_reso <- scanList_ret[[idx_ms2_reso]]
          ms2_reso <- as.numeric(xml2::xml_attr(ms2_reso, "value"))
        } else {
          warning("Fields of `inverse reduced ion mobility` not found.")
          ms2_reso <- 1
        }
      }
      
      # entire MS2 is empty
      if (length(xc) < idx_precursor_2) {
        next
      }
      
      precursorList <- xml2::xml_children(xc[[idx_precursor_2]])
      precursor <- precursorList[[1]] # assume one precursor
      precursorc <- xml2::xml_children(precursor)
      
      idx_selectedIonList <- grep("selectedIonList", precursorc)
      if (!length(idx_selectedIonList)) {
        warning("Fields of `selectedIonList` not found.")
        idx_selectedIonList <- 2L
      }
      
      idx_isolationWindow <- grep("isolationWindow", precursorc)
      if (!length(idx_isolationWindow)) {
        warning("Fields of `isolationWindow` not found.")
        idx_isolationWindow <- 1L
      }
      
      isolationWindowc <- xml2::xml_children(precursorc[[idx_isolationWindow]])
      iso_nms <- lapply(isolationWindowc, function (x) xml2::xml_attr(x, "name"))
      
      idx_ctrmz <- which(iso_nms == "isolation window target m/z")
      if (!length(idx_ctrmz)) {
        warning("Fields of `isolation window target m/z` not found.")
        idx_ctrmz <- 1L
      }
      
      idx_lwrmz <- which(iso_nms == "isolation window lower offset")
      if (!length(idx_lwrmz)) {
        warning("Fields of `isolation window lower offset` not found.")
        idx_lwrmz <- 2L
      }
      
      idx_uprmz <- which(iso_nms == "isolation window upper offset")
      if (!length(idx_uprmz)) {
        warning("Fields of `isolation window upper offset` not found.")
        idx_uprmz <- 3L
      }
      
      lwr_offset <- 
        as.numeric(xml2::xml_attr(isolationWindowc[[idx_lwrmz]], "value"))
      upr_off_set <- 
        as.numeric(xml2::xml_attr(isolationWindowc[[idx_uprmz]], "value"))
      iso_width <- upr_off_set + lwr_offset
      
      selectedIon <- xml2::xml_child(precursorc[[idx_selectedIonList]], 1)
      selectedIonc <- xml2::xml_children(selectedIon)
      selion_nms <- lapply(selectedIonc, function (x) xml2::xml_attr(x, "name"))
      
      idx_moverz <- which(selion_nms == "selected ion m/z")
      if (!length(idx_moverz)) {
        warning("Fields of `selected ion m/z` not found.")
        idx_moverz <- 1L
      }
      
      # not with timsTOF?
      idx_ms1int <- which(selion_nms == "peak intensity") # DIA: zero intensity; timsTOF: length(0)
      if (!length(idx_ms1int)) {
        if (count <= allowance) {
          count <- count + 1L
          next
        }
        else {
          warning("The field of `peak intensity` not found.")
          idx_ms1int <- 3L
        }
      }
      
      idx_charge <- which(selion_nms == "charge state") # DIA: no "charge state"
      is_dia <- if (length(idx_charge)) FALSE else TRUE
      
      # timsTOF
      if (is_dia && !is_3d) is_dia <- FALSE
      
      rm(list = c("scanList", "scanList_ret", "scanList_ret_attrs", 
                  "precursorList", "precursor", "precursorc", 
                  "selectedIon", "selectedIonc", "selion_nms"))
      break
    }
  }
  
  # MS1 indexes
  for (i in rng) {
    x <- spec[[i]]
    xc <- xml2::xml_children(x)
    
    if (as.integer(xml2::xml_attr(xc[[idx_mslev]], "value")) == 1) {
      if (is_3d) {
        idx_scan_lwr_1 <- grep("lowest observed m/z", xc) # "ion mobility lower limit"
        if (!length(idx_scan_lwr_1)) {
          warning("Fields of `lowest observed m/z` not found.")
          idx_scan_lwr_1 <- 8L
        }
        
        idx_scan_upr_1 <- grep("highest observed m/z", xc) # "ion mobility upper limit"
        if (!length(idx_scan_upr_1)) {
          warning("Fields of `highest observed m/z` not found.")
          idx_scan_upr_1 <- 9L
        }
      } else {
        idx_scan_lwr_1 <- grep("ion mobility lower limit", xc) # "ion mobility lower limit"
        if (!length(idx_scan_lwr_1)) {
          warning("Fields of `ion mobility lower limit` not found.")
          idx_scan_lwr_1 <- 8L
        }
        
        idx_scan_upr_1 <- grep("ion mobility upper limit", xc) # "ion mobility upper limit"
        if (!length(idx_scan_upr_1)) {
          warning("Fields of `ion mobility upper limit` not found.")
          idx_scan_upr_1 <- 9L
        }
      }
      
      idx_scanList_1 <- grep("scanList", xc)
      if (!length(idx_scanList_1)) {
        warning("Fields of `scanList` not found.")
        idx_scanList_1 <- if (is_3d) 11L else 10L
      }
      
      idx_bin_1 <- grep("binaryDataArrayList", xc)
      if (!length(idx_bin_1)) {
        warning("Fields of `binaryDataArrayList` not found.")
        idx_bin_1 <- if (is_3d) 12L else 11L
      }
      
      local({
        # [[1]] name="m/z array"; [[2]] name="intensity array"; [[3]] name="mean inverse reduced ion mobility array"
        binData <- xml2::xml_children(xc[[idx_bin_1]])[[1]]
        binDataC <- xml2::xml_children(binData)
        binDataC <- binDataC[which(xml2::xml_name(binDataC) == "cvParam")]
        
        lapply(binDataC, function (v) {
          attrs <- xml2::xml_attrs(v)
          oks <- grepl("compression", attrs)
          
          if (any(oks))
            if (attrs[oks][[1]] == "zlib compression")
              stop("Please uncheck zlib compression in  mzML generations.")
        })
      })
      
      scanList <- xml2::xml_children(xc[[idx_scanList_1]])
      idx_rt_1 <- which(xml2::xml_name(scanList) == "scan")
      if (!length(idx_rt_1)) {
        warning("Fields of `scan` not found.")
        idx_rt_1 <- 2L
      }
      
      scanList_ret <- xml2::xml_children(scanList[[idx_rt_1]])
      
      scan_ret_attrs <- xml2::xml_attr(scanList_ret, "name")
      ## for later removal of the assumption of a fixed resolution with Astral
      # ms1_reso <- scanList_ret[[which(scan_ret_attrs == "mass resolving power")]]
      # ms1_reso <- as.integer(xml2::xml_attr(ms1_reso, "value"))
      idx_scan_start_1 <- which(scan_ret_attrs == "scan start time")
      if (!length(idx_scan_start_1)) {
        warning("Fields of `scan start time` not found.")
        idx_scan_start_1 <- 1L
      }
      
      # idx_scan_start_im <- which(scan_ret_attrs == "inverse reduced ion mobility")
      
      rm(list = c("scanList", "scanList_ret", "scan_ret_attrs"))
      break
    }
  }
  
  rm(list = c("x", "xc", "i"))
  
  if (is_dia) {
    filename <- extrDIA(
      spec = spec, raw_file = raw_file, 
      temp_dir = temp_dir, is_demux = is_demux, 
      idx_sc = idx_sc, idx_osc = idx_osc, idx_mslev = idx_mslev, 
      idx_title = idx_title, idx_scanList_1 = idx_scanList_1, 
      idx_scanList_2 = idx_scanList_2, idx_rt_1 = idx_rt_1, 
      idx_rt_2 = idx_rt_2, idx_scan_start_1 = idx_scan_start_1, 
      idx_scan_start_2 = idx_scan_start_2, 
      idx_precursor_2 = idx_precursor_2, 
      idx_isolationWindow = idx_isolationWindow, 
      idx_ctrmz = idx_ctrmz, idx_lwrmz = idx_lwrmz, 
      idx_uprmz = idx_uprmz, 
      idx_selectedIonList = idx_selectedIonList, 
      idx_demux = idx_demux, idx_bin_1 = idx_bin_1, 
      idx_bin_2 = idx_bin_2, 
      idx_scan_lwr_1 = idx_scan_lwr_1, 
      idx_scan_upr_1 = idx_scan_upr_1, 
      idx_scan_lwr_2 = idx_scan_lwr_2, 
      idx_scan_upr_2 = idx_scan_upr_2)
  }
  else {
    filename <- extrDDA(
      spec = spec, raw_file = raw_file, temp_dir = temp_dir, 
      idx_sc = idx_sc, idx_osc = idx_osc, 
      idx_mslev = idx_mslev, idx_title = idx_title, 
      idx_scanList_2 = idx_scanList_2, idx_rt_2 = idx_rt_2, 
      idx_scan_start_2 = idx_scan_start_2, 
      idx_precursor_2 = idx_precursor_2, 
      idx_isolationWindow = idx_isolationWindow, 
      idx_ctrmz = idx_ctrmz, idx_lwrmz = idx_lwrmz,
      idx_uprmz = idx_uprmz, 
      idx_selectedIonList = idx_selectedIonList, 
      idx_moverz = idx_moverz, idx_charge = idx_charge, 
      idx_ms1int = idx_ms1int, idx_bin_2 = idx_bin_2, 
      idx_scanList_1 = idx_scanList_1, 
      idx_rt_1 = idx_rt_1, idx_scan_start_1 = idx_scan_start_1, 
      idx_bin_1 = idx_bin_1, 
      idx_scan_lwr_1 = idx_scan_lwr_1, idx_scan_upr_1 = idx_scan_upr_1, 
      idx_scan_lwr_2 = idx_scan_lwr_2, idx_scan_upr_2 = idx_scan_upr_2)
  }
  
  attr(filename, "is_dia") <- is_dia
  attr(filename, "iso_width") <- iso_width
  attr(filename, "mzml_type") <- mzml_type

  invisible(filename)
}


#' Proc mzML data for mDDA workflows.
#'
#' @param spec Spectrum list.
#' @param raw_file A raw file name.
#' @param temp_dir A temporary directory.
#' @param idx_sc Index of scan numbers.
#' @param idx_osc Index of original scan numbers.
#' @param idx_mslev Index of MS levels.
#' @param idx_title Index of scan titles.
#' @param idx_scanList_2 Index of MS2 scanList.
#' @param idx_rt_2 Index of MS2 retention times.
#' @param idx_scan_start_2 Index of MS2 scan start.
#' @param idx_precursor_2 Index of MS2 precursor.
#' @param idx_isolationWindow Index of an isolationWindow.
#' @param idx_ctrmz Index of center m-over-z of an isolationWindow.
#' @param idx_lwrmz Index of lower m-over-z an isolationWindow.
#' @param idx_uprmz Index of upper m-over-z an isolationWindow.
#' @param idx_selectedIonList Index of selectedIonList.
#' @param idx_moverz Index of m-over-z sequences.
#' @param idx_charge Index of charge states.
#' @param idx_ms1int Index of MS1 intensities.
#' @param idx_bin_2 Index of MS2 binary data.
#' @param idx_scan_lwr_1 Index of lowest MS1 mass.
#' @param idx_scan_upr_1 Index of highest MS1 mass.
#' @param idx_scan_lwr_2 Index of lowest MS2 mass.
#' @param idx_scan_upr_2 Index of highest MS2 mass.
#' @param idx_scanList_1 Index of MS1 scanList.
#' @param idx_rt_1 Index of precursor retention times.
#' @param idx_scan_start_1 Index of MS1 scan starts.
#' @param idx_bin_1 Index of MS1 binary data.
#' @param raw_file The RAW file name of an mzML.
#' @param is_regular Logical; TRUE at Thermo's and FALSE at timsTOF's .d.
extrDDA <- function (spec = NULL, raw_file = NULL, temp_dir = NULL, 
                     idx_sc = 3L, idx_osc = 3L, idx_mslev = 2L, 
                     idx_title = 10L, idx_scanList_2 = 11L, idx_rt_2 = 2L, 
                     idx_scan_start_2 = 1L, idx_precursor_2 = 12L, 
                     idx_isolationWindow = 1L, idx_ctrmz = 1L, idx_lwrmz = 2L,
                     idx_uprmz = 3L, idx_selectedIonList = 2L, idx_moverz = 1L, 
                     idx_charge = 2L, idx_ms1int = 3L, idx_bin_2 = 13L, 
                     idx_scanList_1 = 11L, idx_rt_1 = 2L, 
                     idx_scan_start_1 = 1L, idx_bin_1 = 12L, 
                     idx_scan_lwr_1 = 8L, idx_scan_upr_1 = 9L, 
                     idx_scan_lwr_2 = 8L, idx_scan_upr_2 = 9L, is_regular = TRUE)
{
  len <- length(spec)
  
  ret_times <- orig_scans <- scan_nums <- scan_titles <- 
    iso_ctr <- iso_lwr <- iso_upr <- character(len)
  
  # msx_: both MS1 and MS2, differentiated by ms_lev
  # ms0_: precursor info by other peak-pickings, e.g., MSConvert
  
  ms0_moverzs <- ms0_ints <- ms0_charges <- 
    msx_moverzs <- msx_ints <- msx_charges <- vector("list", len)
  ms_levs <- msx_ns <- integer(len)
  
  if (!is_regular) {
    msx_mobils <- vector("list", len)
  }

  for (i in 1:len) {
    x <- spec[[i]]
    ids <- .Internal(strsplit(xml2::xml_attr(x, "id"), " ", fixed = TRUE, 
                              perl = FALSE, useBytes = FALSE))[[1]]
    ids <- .Internal(strsplit(ids, "=", fixed = TRUE, 
                              perl = FALSE, useBytes = FALSE))
    scan_nums[[i]]  <- ids[[idx_sc]][[2]]
    orig_scans[[i]] <- ids[[idx_osc]][[2]]
    
    xc <- xml2::xml_children(x)
    ms_levs[[i]] <- ms_lev <- as.integer(xml2::xml_attr(xc[[idx_mslev]], "value"))
    scan_titles[[i]] <- xml2::xml_attr(xc[[idx_title]], "value")
    
    if (ms_lev == 2L) {
      scanList <- xml2::xml_children(xc[[idx_scanList_2]])
      scanList_ret <- xml2::xml_children(scanList[[idx_rt_2]])
      ret_times[[i]] <- xml2::xml_attr(scanList_ret[[idx_scan_start_2]], "value")
      
      # entire MS2 is empty
      if (length(xc) < idx_precursor_2)
        next
      
      precursorList <- xml2::xml_children(xc[[idx_precursor_2]])
      precursor <- precursorList[[1]] # (assume one precursor by MSConvert)
      precursorc <- xml2::xml_children(precursor)
      
      isolationWindowc <- xml2::xml_children(precursorc[[idx_isolationWindow]])
      iso_ctr[[i]] <- xml2::xml_attr(isolationWindowc[[idx_ctrmz]], "value")
      iso_lwr[[i]] <- xml2::xml_attr(isolationWindowc[[idx_lwrmz]], "value")
      iso_upr[[i]] <- xml2::xml_attr(isolationWindowc[[idx_uprmz]], "value")
      
      selectedIon  <- xml2::xml_child(precursorc[[idx_selectedIonList]], 1)
      selectedIonc <- xml2::xml_children(selectedIon)
      
      # precursor(s) of MS2
      ms0_moverzs[[i]] <- as.numeric(xml2::xml_attr(selectedIonc[[idx_moverz]], "value"))
      ms0_charges[[i]] <- as.numeric(xml2::xml_attr(selectedIonc[[idx_charge]], "value"))
      # no precursor intensity: 01CPTAC3_Benchmarking_P_BI_20170523_BL_f12.mzML; scan=54837
      ms0_ints[[i]] <- if (length(selectedIonc) >= idx_ms1int)
        as.numeric(xml2::xml_attr(selectedIonc[[idx_ms1int]], "value"))
      binData <- xml2::xml_children(xml2::xml_children(xc[[idx_bin_2]]))
    }
    else if (ms_lev == 1L) {
      scanList <- xml2::xml_children(xc[[idx_scanList_1]])
      scanList_ret <- xml2::xml_children(scanList[[idx_rt_1]])
      ret_times[[i]] <- xml2::xml_attr(scanList_ret[[idx_scan_start_1]], "value")
      binData <- xml2::xml_children(xml2::xml_children(xc[[idx_bin_1]]))
    }
    
    # full MS1 or MS2 spectrum
    msData <- xml2::xml_contents(binData)
    len_ms <- length(msData)
    
    if (len_ms == 2L) {
      r1 <- .Call(base64enc:::B64_decode, xml2::xml_text(msData[[1]]))
      r2 <- .Call(base64enc:::B64_decode, xml2::xml_text(msData[[2]]))
      msx_ns[[i]] <- msx_n <- as.integer(length(r1)/8L)
      msx_moverzs[[i]] <- readBin(r1, "double", n = msx_n, size = 8L)
      msx_ints[[i]] <- readBin(r2, "double", n = msx_n, size = 8L)
    } else if (len_ms == 3L) { # timsTOF
      r1 <- .Call(base64enc:::B64_decode, xml2::xml_text(msData[[1]]))
      r2 <- .Call(base64enc:::B64_decode, xml2::xml_text(msData[[2]]))
      r3 <- .Call(base64enc:::B64_decode, xml2::xml_text(msData[[3]]))
      msx_ns[[i]] <- msx_n <- as.integer(length(r1)/8L)
      msx_moverzs[[i]] <- readBin(r1, "double", n = msx_n, size = 8L)
      msx_ints[[i]] <- readBin(r2, "double", n = msx_n, size = 8L)
      msx_mobils[[i]] <- readBin(r3, "double", n = msx_n, size = 8L)
    }
  }
  
  out <- list(
    msx_moverzs = msx_moverzs, 
    msx_ints = msx_ints, 
    msx_ns = msx_ns,
    ms1_moverzs = ms0_moverzs, 
    ms1_charges = ms0_charges, 
    ms1_ints = ms0_ints, 
    
    scan_title = scan_titles,
    raw_file = raw_file, # single
    ms_level = ms_levs, 
    # mzML: ret_times in minutes; MGF: in seconds
    ret_time = as.numeric(ret_times) * 60, 
    scan_num = as.integer(scan_nums), 
    orig_scan = orig_scans,
    iso_ctr = as.numeric(iso_ctr), 
    iso_lwr = as.numeric(iso_lwr), 
    iso_upr = as.numeric(iso_upr)
  )
  
  out_name <- paste0(raw_file, ".rds")
  qs::qsave(out, file.path(temp_dir, out_name), preset = "fast")
  invisible(out_name)
}


#' Helper of \link{deisoDDA}.
#'
#' @param raw_id A raw file id.
#' @param n_para The allowance of parallel processing.
#' @param mgf_cutmzs The cut points in peak lists.
#' @param mgf_cutpercs The percentage of cuts.
#' @inheritParams deisoDDA
#' @inheritParams matchMS
hdeisoDDA <- function (filename, raw_id = 1L, mgf_path = NULL, temp_dir = NULL, 
                       mzml_type = "raw", ppm_ms1 = 10L, ppm_ms2 = 10L, 
                       maxn_mdda_precurs = 5L, 
                       topn_ms2ions = 150L, n_mdda_flanks = 6L, n_dia_scans = 4L, 
                       min_mass = 200L, max_mass = 4500L,
                       min_ms2mass = 115L, max_ms2mass = 4500L, 
                       min_ms1_charge = 2L, max_ms1_charge = 4L, 
                       min_ret_time = 0, max_ret_time = Inf, 
                       min_scan_num = 1L, max_scan_num = .Machine$integer.max, 
                       deisotope_ms2 = TRUE, max_ms2_charge = 3L, 
                       ppm_ms1_deisotope = 8L, ppm_ms2_deisotope = 8L, 
                       grad_isotope = 1.6, fct_iso2 = 3.0, 
                       mgf_cutmzs = numeric(), mgf_cutpercs = numeric(), 
                       quant = "none", use_lfq_intensity = TRUE, 
                       tmt_reporter_lower = 126.1, tmt_reporter_upper = 135.2, 
                       exclude_reporter_region = FALSE, use_defpeaks = FALSE, 
                       n_para = 1L)
{
  df <- deisoDDA(
    filename, 
    temp_dir = temp_dir, 
    mzml_type = mzml_type, 
    ppm_ms1 = ppm_ms1, 
    ppm_ms2 = ppm_ms2, 
    maxn_mdda_precurs = maxn_mdda_precurs, 
    topn_ms2ions = topn_ms2ions, 
    n_mdda_flanks = n_mdda_flanks, 
    n_dia_scans = n_dia_scans, 
    min_mass = min_mass, 
    max_mass = max_mass, 
    min_ms2mass = min_ms2mass, 
    max_ms2mass = max_ms2mass, 
    min_ms1_charge = min_ms1_charge, 
    max_ms1_charge = max_ms1_charge, 
    min_ret_time = min_ret_time, 
    max_ret_time = max_ret_time, 
    min_scan_num = min_scan_num, 
    max_scan_num = max_scan_num, 
    deisotope_ms2 = deisotope_ms2, 
    max_ms2_charge = max_ms2_charge, 
    ppm_ms1_deisotope = ppm_ms1_deisotope, 
    ppm_ms2_deisotope = ppm_ms2_deisotope, 
    grad_isotope = grad_isotope, 
    fct_iso2 = fct_iso2, 
    quant = quant, 
    use_lfq_intensity = use_lfq_intensity, 
    tmt_reporter_lower = tmt_reporter_lower, 
    tmt_reporter_upper = tmt_reporter_upper, 
    exclude_reporter_region = exclude_reporter_region, 
    use_defpeaks = use_defpeaks, 
    n_para = n_para)
  
  # subsets by top-n and min_ms2mass
  # (also convert non reporter-ion MS2 intensities to integers)
  mz_n_int <- sub_mgftopn(ms2_moverzs = df[["ms2_moverzs"]], 
                          ms2_ints = df[["ms2_ints"]], 
                          ms2_charges = df[["ms2_charges"]], 
                          topn_ms2ions = topn_ms2ions, 
                          mgf_cutmzs = mgf_cutmzs, 
                          mgf_cutpercs = mgf_cutpercs, 
                          min_ms2mass = min_ms2mass, 
                          max_ms2mass = max_ms2mass)
  df[["ms2_moverzs"]] <- mz_n_int[["ms2_moverzs"]]
  df[["ms2_ints"]] <- mz_n_int[["ms2_ints"]]
  df[["ms2_charges"]] <- mz_n_int[["ms2_charges"]]
  df[["ms2_n"]] <- mz_n_int[["lens"]]
  
  # fuzzy precursor masses and the corresponding scan_nums are duplicated 
  #  In `calcpepsc`, uniq_id: scan_num + raw_file + ms1_offset
  #  In `calc_pepfdr`, uniq_id: scan_num + raw_file
  #  In `post_pepfdr`, `calc_peploc`, `hcalc_tmtint`, `add_rptrs`
  
  post_readmgf(df, raw_id = raw_id, mgf_path = mgf_path)
}


#' Deisotopes DDA.
#' 
#' @param filename A peaklist filename.
#' @param temp_dir A temp_dir to the filename.
#' @param mzml_type The type of peak lists. To trigger MS1 deisotoping at
#'   \code{mzml_type == "raw"} (MS1 X, y and Z are NA with Mzion).
#' @param n_para The allowance of parallel processing. 
#' @inheritParams matchMS
deisoDDA <- function (filename = NULL, temp_dir = NULL, mzml_type = "raw", 
                      ppm_ms1 = 10L, ppm_ms2 = 10L, 
                      maxn_mdda_precurs = 5L, topn_ms2ions = 150L, 
                      n_mdda_flanks = 6L, n_dia_scans = 4L, 
                      min_mass = 200L, max_mass = 4500L,
                      min_ms2mass = 115L, max_ms2mass = 4500L, 
                      min_ms1_charge = 2L, max_ms1_charge = 4L, 
                      min_ret_time = 0, max_ret_time = Inf, 
                      min_scan_num = 1L, max_scan_num = .Machine$integer.max, 
                      deisotope_ms2 = TRUE, max_ms2_charge = 3L, 
                      ppm_ms1_deisotope = 8L, ppm_ms2_deisotope = 8L, 
                      grad_isotope = 1.6, fct_iso2 = 3.0, 
                      quant = "none", use_lfq_intensity = TRUE, 
                      tmt_reporter_lower = 126.1, tmt_reporter_upper = 135.2, 
                      exclude_reporter_region = FALSE, use_defpeaks = FALSE, 
                      n_para = 1L)
{
  ###
  # msx_: full spectra of ms1 and ms2, differentiated by ms_lev
  ###
  
  if (TRUE) {
    # reads parsed peak lists
    ans <- qs::qread(file.path(temp_dir, filename))
    msx_moverzs <- ans$msx_moverzs
    msx_ints <- ans$msx_ints
    msx_ns <- ans$msx_ns
    ms1_moverzs <- ans$ms1_moverzs # by MSConvert; Mzion: NA
    ms1_ints <- ans$ms1_ints # by MSConvert; Mzion: NA
    ms1_charges <- ans$ms1_charges # by MSConvert; Mzion: NA
    scan_title <- ans$scan_title
    raw_file <- ans$raw_file # scalar
    ms_level <- ans$ms_level
    ret_time <- ans$ret_time 
    scan_num <- ans$scan_num
    orig_scan <- ans$orig_scan
    iso_ctr <- ans$iso_ctr
    iso_lwr <- ans$iso_lwr
    iso_upr <- ans$iso_upr
    rm(list = "ans")
    
    restmt <- extract_mgf_rptrs(
      msx_moverzs, 
      msx_ints, 
      quant = quant, 
      tmt_reporter_lower = tmt_reporter_lower, 
      tmt_reporter_upper = tmt_reporter_upper, 
      exclude_reporter_region = exclude_reporter_region)
    
    msx_moverzs <- restmt[["xvals"]]
    msx_ints <- restmt[["yvals"]]
    rptr_moverzs <- restmt[["rptr_moverzs"]]
    rptr_ints <- restmt[["rptr_ints"]]
    rm(list = "restmt")
    
    msx_charges <- vector("list", length(msx_moverzs))
    
    ##
    # try to subset early by min_ and max_ masses...
    # even at unknown z, not very likely to have z >= 2 at small m/z...
    ##
    
    if (deisotope_ms2) {
      if (n_para > 1L) {
        n_cores <- n_para
        n_chunks <- n_cores * 4L
        
        oks <- ms_level == 2L
        msx_moverzx <- msx_moverzs[oks]
        msx_intx <- msx_ints[oks]
        grps <- sep_vec(msx_moverzx, n_chunks)
        
        cl <- parallel::makeCluster(getOption("cl.cores", n_cores))
        out <- parallel::clusterMap(
          cl, getMS2xyz, 
          split(msx_moverzx, grps), split(msx_intx, grps), 
          MoreArgs = list(
            topn_ms2ions = topn_ms2ions, 
            max_ms2_charge = max_ms2_charge, 
            ppm_ms2_deisotope = ppm_ms2_deisotope, 
            grad_isotope = grad_isotope, 
            fct_iso2 = fct_iso2, 
            quant = quant, 
            tmt_reporter_lower = tmt_reporter_lower, 
            tmt_reporter_upper = tmt_reporter_upper, 
            exclude_reporter_region = exclude_reporter_region 
          ), SIMPLIFY = FALSE, USE.NAMES = FALSE, .scheduling = "dynamic")
        parallel::stopCluster(cl)
        
        msx_moverzs[oks] <- unlist(lapply(out, function (x) x[[1]]), 
                                   recursive = FALSE, use.names = FALSE)
        msx_ints[oks] <- unlist(lapply(out, function (x) x[[2]]), 
                                recursive = FALSE, use.names = FALSE)
        msx_charges[oks] <- unlist(lapply(out, function (x) x[[3]]), 
                                   recursive = FALSE, use.names = FALSE)
        rm(list = c("out", "n_chunks", "cl", "grps", "oks", 
                    "msx_moverzx", "msx_intx"))
      }
      else {
        oks <- ms_level == 2L
        
        out <- getMS2xyz(
          msx_moverzs[oks], msx_ints[oks], 
          topn_ms2ions = topn_ms2ions, 
          max_ms2_charge = max_ms2_charge, 
          ppm_ms2_deisotope = ppm_ms2_deisotope, 
          grad_isotope = grad_isotope, 
          fct_iso2 = fct_iso2, 
          quant = quant, 
          tmt_reporter_lower = tmt_reporter_lower, 
          tmt_reporter_upper = tmt_reporter_upper, 
          exclude_reporter_region = exclude_reporter_region)
        
        msx_moverzs[oks] <- out[[1]]
        msx_ints[oks] <- out[[2]]
        msx_charges[oks] <- out[[3]]
        rm(list = c("out", "oks"))
      }
    }
    
    # MS1 X, Y and Z are NA from Mzion::readRAW; need to trigger deisotoping
    if (mzml_type == "raw" && maxn_mdda_precurs < 1L) {
      maxn_mdda_precurs <- 1L
    }
    
    if (maxn_mdda_precurs) {
      if (FALSE) { # slower but keep the codes for group split examples
        n_cores <- n_para
        n_chunks <- n_cores^2
        grps <- find_ms2ends(ms_level, n_chunks)
        
        cl <- parallel::makeCluster(getOption("cl.cores", n_cores))
        ans <- parallel::clusterMap(
          cl, getMS1xyz, 
          split(msx_moverzs, grps), split(msx_ints, grps), split(ms_level, grps), 
          split(iso_ctr, grps), split(iso_lwr, grps), split(ms1_moverzs, grps), 
          split(ms1_charges, grps), split(ms1_ints, grps), 
          MoreArgs = list(
            maxn_mdda_precurs = maxn_mdda_precurs, n_mdda_flanks = n_mdda_flanks,  
            topn_ms2ions = topn_ms2ions, quant = quant, 
            tmt_reporter_lower = tmt_reporter_lower, 
            tmt_reporter_upper = tmt_reporter_upper, 
            exclude_reporter_region = exclude_reporter_region, 
            max_ms1_charge = max_ms1_charge, ppm_ms1_deisotope = ppm_ms1_deisotope, 
            grad_isotope = grad_isotope, fct_iso2 = fct_iso2, 
            use_defpeaks = use_defpeaks
          ), SIMPLIFY = FALSE, USE.NAMES = FALSE, .scheduling = "dynamic")
        parallel::stopCluster(cl)
        
        ms1_moverzs <- unlist(lapply(ans, function (x) x[["ms1_moverzs"]]), 
                              recursive = FALSE, use.names = FALSE)
        ms1_masses <- unlist(lapply(ans, function (x) x[["ms1_masses"]]), 
                             recursive = FALSE, use.names = FALSE)
        ms1_charges <- unlist(lapply(ans, function (x) x[["ms1_charges"]]), 
                              recursive = FALSE, use.names = FALSE)
        ms1_ints <- unlist(lapply(ans, function (x) x[["ms1_ints"]]), 
                           recursive = FALSE, use.names = FALSE)
        ms1_stas <- unlist(lapply(ans, function (x) x[["ms1_stas"]]), 
                           recursive = FALSE, use.names = FALSE)
        ms2_stas <- unlist(lapply(ans, function (x) x[["ms2_stas"]]), 
                           recursive = FALSE, use.names = FALSE)
        ms2_ends <- unlist(lapply(ans, function (x) x[["ms2_ends"]]), 
                           recursive = FALSE, use.names = FALSE)
        rm(list = c("ans", "grps", "cl"))
        gc()
      }
      
      ans <- getMS1xyz(
        msx_moverzs = msx_moverzs, msx_ints = msx_ints, 
        ms_level = ms_level, iso_ctr = iso_ctr, iso_lwr = iso_lwr, 
        ms1_moverzs = ms1_moverzs, ms1_charges = ms1_charges, ms1_ints = ms1_ints, 
        maxn_mdda_precurs = maxn_mdda_precurs, n_mdda_flanks = n_mdda_flanks,  
        topn_ms2ions = topn_ms2ions, quant = quant, 
        tmt_reporter_lower = tmt_reporter_lower, 
        tmt_reporter_upper = tmt_reporter_upper, 
        exclude_reporter_region = exclude_reporter_region, 
        max_ms1_charge = max_ms1_charge, ppm_ms1_deisotope = ppm_ms1_deisotope, 
        grad_isotope = grad_isotope, fct_iso2 = fct_iso2, 
        use_defpeaks = use_defpeaks)
      
      # list(NULL) at ms_level == 1L
      ms1_moverzs <- ans$ms1_moverzs
      ms1_masses <- ans$ms1_masses
      ms1_charges <- ans$ms1_charges
      ms1_ints <- ans$ms1_ints
      # for LFQ MS1
      # may compiles ms1_ends later: multiple MS1s followed by multiple MS2s... 
      ms1_stas <- ans$ms1_stas
      ms2_stas <- ans$ms2_stas
      ms2_ends <- ans$ms2_ends
      rm(list = "ans")
      
      # look up ms2 for undetermined precursor charge states
      if (deisotope_ms2) {
        rows1 <- lapply(ms1_moverzs, is.null) # all MS1 and some MS2
        rows1 <- .Internal(unlist(rows1, recursive = FALSE, use.names = FALSE))
        rows2 <- ms_level == 2L
        rows <- .Internal(which(rows2 & rows1)) # MS2 without precursor info
        nrows <- length(rows)
        
        if (nrows) {
          # msx_moverzs[rows] and msx_ints[rows] not NULL; msx_charges[rows]: NULL
          # msx_charges[rows] <- NA_real_
          ans2 <- mapply(find_ms1byms2, 
                         moverzs = msx_moverzs[rows], msxints = msx_ints[rows], 
                         charges = msx_charges[rows], center = iso_ctr[rows], 
                         iso_lwr = iso_lwr[rows], iso_upr = iso_upr[rows], 
                         SIMPLIFY = FALSE, USE.NAMES = FALSE)
          
          ans2 <- dplyr::bind_rows(ans2)
          ans2$ms1_moverzs <- as.list(ans2$ms1_moverzs)
          ans2$ms1_masses <- as.list(ans2$ms1_masses)
          ans2$ms1_charges <- as.list(ans2$ms1_charges)
          ans2$ms1_ints <- as.list(ans2$ms1_ints)
          
          # outputs contain NA and revert them back to list(NULL)
          nas <- which(is.na(ans2$ms1_moverzs))
          
          if (length(nas)) {
            ans2$ms1_ints[nas] <- ans2$ms1_charges[nas] <- 
              ans2$ms1_masses[nas] <- ans2$ms1_moverzs[nas] <- list(NULL)
          }
          
          ms1_moverzs[rows] <- ans2$ms1_moverzs
          ms1_masses[rows] <- ans2$ms1_masses
          ms1_charges[rows] <- ans2$ms1_charges
          ms1_ints[rows] <- ans2$ms1_ints
          rm(list = c("ans2", "nas"))
        }
        
        rm(list = c("rows1", "rows2", "rows"))
      }
      
      ###
      # Up to this point, ms1_moverzs are list(NULL) at ms_level == 1L;
      # Not to trace all MS1 features but only the monoisotopic 
      #  that have been assigned to MS2 scans.
      ###
      
      # Pools precursors at ms_level == 2 to the preceding ms_level == 1 for LFQ MS1;
      for (i in seq_along(ms1_stas)) {
        rng1 <- ms1_stas[[i]]
        rng2 <- ms2_stas[[i]]:ms2_ends[[i]]
        
        # isolation windows can have overlaps -> 
        #   the same precursor at multiple windows -> duplicated MS1 entries
        xs <- .Internal(unlist(ms1_moverzs[rng2], recursive = FALSE, use.names = FALSE))
        ys <- .Internal(unlist(ms1_ints[rng2], recursive = FALSE, use.names = FALSE))
        zs <- .Internal(unlist(ms1_charges[rng2], recursive = FALSE, use.names = FALSE))
        ms <- .Internal(unlist(ms1_masses[rng2], recursive = FALSE, use.names = FALSE))
        
        if (length(xs)) {
          ord <- order(xs)
          ms1_moverzs[[rng1]] <- xs[ord]
          ms1_ints[[rng1]] <- ys[ord]
          ms1_charges[[rng1]] <- zs[ord]
          ms1_masses[[rng1]] <- ms[ord]
          rm(list = "ord")
        }
      }
      rm(list = c("rng1", "rng2", "xs", "ys", "zs", "ms"))
    }
    else {
      ms1_masses <- mapply(function (x, y) (x - 1.00727647) * y, 
                           ms1_moverzs, ms1_charges, 
                           SIMPLIFY = FALSE, USE.NAMES = FALSE)
    }
    
    # msx_moverzs at ms_level == 1L correspond to full-spectrum ms1_moverzs
    # msx_charges at ms_level == 1L are list(NULL)
    df <- tibble::tibble(
      scan_title = scan_title,
      raw_file = raw_file,
      ms_level = ms_level, 
      ms1_moverz = ms1_moverzs, 
      ms1_mass = ms1_masses,
      ms1_charge = ms1_charges, 
      ms1_int = ms1_ints, 
      # mzML: ret_times in minutes; MGF: ret_times in seconds
      ret_time = ret_time, 
      scan_num = scan_num, 
      orig_scan = orig_scan,
      msx_moverzs = msx_moverzs, 
      msx_ints = msx_ints, 
      msx_charges = msx_charges, 
      msx_n = msx_ns, 
      rptr_moverzs = rptr_moverzs, 
      rptr_ints = rptr_ints)
  } else {
    df <- qs::qread("~/df_deisoDDA.rds")
  }
  

  ## LFQ: replaces intensities with apex values
  # No MS1 info at maxn_mdda_precurs == 0L
  if (use_lfq_intensity && maxn_mdda_precurs) {
    # df[["orig_ms1_ints"]] <- df[["ms1_int"]]
    step <- ppm_ms1 * 1e-6
    
    # estimated number of MS1 scans at a 2-min range of retention times
    rt_gap <- local({
      df1 <- df[with(df, ms_level == 1), ]
      len <- nrow(df1)
      rts <- df1$ret_time
      df1 <- dplyr::arrange(df1, ret_time)
      max_rt <- rts[len]
      
      mid_len <- max(as.integer(len/2), 1L)
      mid_rt <- rts[mid_len]
      
      d <- 180
      grs <- which(rts > mid_rt + d)
      upr <- if (length(grs)) grs[[1]] else len
      rt_gap <- max(upr - mid_len, 1L)
    })
    
    ans_prep <- pretraceXY(
      df[, c("ms1_mass", "ms1_moverz", "ms1_int", "ms1_charge", "ms_level", 
             "msx_moverzs", "msx_ints", "msx_charges", "orig_scan")], 
      from = min_mass, step = step, 
      # 1024L: more RAM, same speed 
      n_chunks = ceiling(sum(df$ms_level == 1L)/512L), 
      gap = rt_gap)
    
    dfs <- ans_prep$dfs
    df1s <- ans_prep$df1s
    gaps <- unlist(ans_prep$gaps, use.names = FALSE, recursive = FALSE)
    rm(list = c("ans_prep", "rt_gap"))
    gc()
    
    cols <- c("ms_level", "ms1_moverz", "ms1_int")
    lenv <- length(df1s)
    gaps_bf <- c(0L, gaps[1:(lenv-1L)])
    gaps_af <- c(gaps[2:lenv], 0L)

    if (TRUE) {
      cl <- parallel::makeCluster(getOption("cl.cores", 2L))
      out <- parallel::clusterMap(
        cl, htraceXY, 
        lapply(df1s, `[[`, "msx_moverzs"), 
        lapply(df1s, `[[`, "msx_ints"), 
        lapply(df1s, `[[`, "orig_scan"), 
        lapply(dfs, `[`, cols), 
        gaps_bf, 
        gaps_af, 
        MoreArgs = list(
          n_mdda_flanks = n_mdda_flanks, from = min_mass, step = step
        ), SIMPLIFY = FALSE, USE.NAMES = FALSE, .scheduling = "dynamic")
      parallel::stopCluster(cl)
    }
    else {
      vxs <- lapply(df1s, `[[`, "msx_moverzs")
      vys <- lapply(df1s, `[[`, "msx_ints")
      vdf <- lapply(dfs, `[`, cols)
      vss <- lapply(df1s, `[[`, "orig_scan") # for troubling shooting
      out <- vector("list", lenv)

      for (i in 1:lenv) {
        # nrow(out[[i]]) == nrow(vdf[[i]])
        out[[i]] <- htraceXY(
          xs = vxs[[i]], ys = vys[[i]], ss = vss[[i]], df = vdf[[i]], 
          gap_bf <- gaps_bf[[i]], gap_af = gaps_af[[i]], 
          n_mdda_flanks = n_mdda_flanks, from = min_mass, step = step)
        
        if (FALSE) {
          if (all(lengths(vxs[[i]]) == 0L)) {
            li <- length(vxs[[i]]) - gaps_bf[[i]] - gaps_af[[i]] + 1L
            null <- rep_len(list(NULL), li)
            
            out[[i]] <- tibble::tibble(
              ms_level = vdf[[i]]$ms_level, 
              ms1_moverz = null, 
              ms1_int = null, 
              apex_scan_num = null)
          } else {
            out[[i]] <- htraceXY(
              xs = vxs[[i]], ys = vys[[i]], ss = vss[[i]], df = vdf[[i]], 
              gap_bf <- gaps_bf[[i]], gap_af = gaps_af[[i]], 
              # may be > n_mdda_flanks
              n_mdda_flanks = n_mdda_flanks, from = min_mass, step = step)
          }
        }
        
      }
      rm(list = c("vxs", "vys", "vdf", "gaps", "lenv"))
    }

    out <- dplyr::bind_rows(out)
    df[, cols] <- out[, cols]
    ###
    df$apex_scan_num <- out$apex_scan_num
    empties <- lengths(df$apex_scan_num) == 0L
    df$apex_scan_num[empties] <- df$orig_scan[empties]
    df <- reloc_col_after(df, "apex_scan_num", "orig_scan")
    ###
    rm(list = "out")
    
    ## Obtains ms1_int from the corresponding full MS1 (msx_ints)
    # cols <- c("ms1_moverz", "ms1_int", "msx_moverzs", "msx_ints")
    # df[rows, cols] <- getMS1Int(df[rows, cols], from = min_mass, step = step)
    
    # later use apex values to update retention times...
  }
  else {
    df$apex_scan_num <- df$orig_scan
  }

  ## cleans up
  df <- reloc_col_after(df, "apex_scan_num", "orig_scan")
  rows <- df$ms_level == 1L
  df <- df[!rows, ]
  bads <- unlist(lapply(df$ms1_moverz, is.null))
  df <- df[!bads, ]
  
  ans_rts <- reset_rettimes(
    ret_times = df$ret_time, 
    min_ret_time = min_ret_time, 
    max_ret_time = max_ret_time)
  
  min_ret_time <- ans_rts$min_ret_time
  max_ret_time <- ans_rts$max_ret_time
  
  df <- dplyr::filter(df, ret_time >= min_ret_time, ret_time <= max_ret_time)
  
  if (maxn_mdda_precurs >= 1L) {
    bads <- lapply(df$ms1_mass, function (x) length(x) == 1L && is.na(x))
    bads <- unlist(bads)
    df <- df[!bads, ]
    
    oks <- lapply(df$ms1_mass, function (x) .Internal(which(x >= min_mass & x <= max_mass)))

    df$ms1_mass <- mapply(function (x, y) x[y], df$ms1_mass, oks, 
                          SIMPLIFY = FALSE, USE.NAMES = FALSE)
    df$ms1_moverz <- mapply(function (x, y) x[y], df$ms1_moverz, oks, 
                            SIMPLIFY = FALSE, USE.NAMES = FALSE)
    df$ms1_charge <- mapply(function (x, y) x[y], df$ms1_charge, oks, 
                            SIMPLIFY = FALSE, USE.NAMES = FALSE)
    df$ms1_int <- mapply(function (x, y) x[y], df$ms1_int, oks, 
                         SIMPLIFY = FALSE, USE.NAMES = FALSE)
    # ms1_mass may again contain numeric(0) following the above filtration
    df <- df[lengths(df$ms1_mass) > 0L, ]
  }
  else {
    df <- df[with(df, !is.na(ms1_mass)), ]
    df <- dplyr::filter(
      df, 
      ms1_charge >= min_ms1_charge, ms1_charge <= max_ms1_charge, 
      ms1_mass >= min_mass, ms1_mass <= max_mass)
    df <- dplyr::arrange(df, ms1_mass)
  }
  
  df <- dplyr::rename(
    df, 
    ms2_moverzs = msx_moverzs, 
    ms2_ints = msx_ints, 
    ms2_charges = msx_charges, 
    ms2_n = msx_n)
}


#' Obtains the indexes of MS1 and MS2 starts and ends.
#' 
#' @param ms_level A vector of MS levels.
#' @param pad_nas Logical; if TRUE, adds padding values to keep the same length.
getMSrowIndexes <- function (ms_level, pad_nas = FALSE)
{
  # add a trailing `1`
  len <- length(ms_level)
  
  if (ms_level[len] == 2L) {
    ms_level <- c(ms_level, 1L)
    len <- len + 1L
    add_trailing <- TRUE
  }
  else {
    add_trailing <- FALSE
  }
  
  idxes_ms1 <- which(ms_level == 1L)
  diff_ms1 <- c(0L, diff(idxes_ms1))
  oks <- which(diff_ms1 > 1L) # non-consecutive MS1s
  ms1_stas <- idxes_ms1[oks - 1L] # excludes the last non-consecutive MS1 index
  ms2_stas <- ms1_stas + 1L
  ms2_ends <- idxes_ms1[oks] - 1L
  
  if (pad_nas) {
    if (add_trailing) {
      idxes_ms1 <- idxes_ms1[-length(idxes_ms1)]
    }
    
    bads <- idxes_ms1[!idxes_ms1 %in% ms1_stas]
    nas <- rep_len(NA_integer_, length(bads))
    ms1_stas <- c(bads, ms1_stas)
    ms2_stas <- c(nas, ms2_stas)
    ms2_ends <- c(nas, ms2_ends)
    
    ord <- order(ms1_stas)
    ms1_stas <- ms1_stas[ord]
    ms2_stas <- ms2_stas[ord]
    ms2_ends <- ms2_ends[ord]
  }

  list(ms1_stas = ms1_stas, ms2_stas = ms2_stas, ms2_ends = ms2_ends)
}


#' Finds group indexes with end points at \code{vals = 2L}.
#' 
#' For chunk-splitting with each chuck ending at value 2.
#' 
#' @param vals An integer vector of (MS levels of) 1 or 2.
#' @param n_chunks The number of chunks.
#' 
#' @examples
#' vals1 <- c(rep(1, 2), rep(2, 5), 1, rep(2, 4), rep(1, 3), rep(2, 4), 1)
#' grps1 <- mzion:::find_ms2ends(vals1, 3)
#' 
#' vals2 <- c(rep(1, 2), rep(2, 5), 1, rep(2, 4), rep(1, 3), rep(2, 4))
#' grps2 <- mzion:::find_ms2ends(vals2, 3)
find_ms2ends <- function (vals, n_chunks = 3L)
{
  if (n_chunks <= 1L)
    return(rep_len(1L, length(vals)))

  ms2_ends <- getMSrowIndexes(vals)$ms2_ends
  brs <- floor(length(ms2_ends)/n_chunks) * 1:(n_chunks - 1L)
  findInterval(seq_along(vals), ms2_ends[brs] + 1L)
}


#' Deisotoping DDA-MS1.
#' 
#' @param ms_level Vectors of MS levels
#' @param iso_ctr A vector of isolation centers.
#' @param iso_lwr A vecor of isolation lowers.
#' @param ms1_moverzs MS1 moverz values.
#' @param ms1_ints MS1 intensity values.
#' @param ms1_charges MS1 charge states.
#' @inheritParams find_mdda_mms1s
#' @inheritParams matchMS
getMS1xyz <- function (msx_moverzs = NULL, msx_ints = NULL, 
                       ms_level = NULL, iso_ctr = NULL, iso_lwr = NULL, 
                       ms1_moverzs = NULL, ms1_charges = NULL, ms1_ints = NULL, 
                       maxn_mdda_precurs = 1L, n_mdda_flanks = 6L, 
                       topn_ms2ions = 150L, quant = "none", 
                       tmt_reporter_lower = 126.1, tmt_reporter_upper = 135.2, 
                       exclude_reporter_region = FALSE, 
                       max_ms1_charge = 4L, ppm_ms1_deisotope = 8L, 
                       grad_isotope = 1.6, fct_iso2 = 3.0, 
                       use_defpeaks = FALSE)
{
  ## Low priority: no data filtration by scan_nums; 
  #  plus, as.integer(scan_nums) may be invalid with Bruker's
  #  better filter data by retention times
  
  if (!use_defpeaks) {
    ms1_moverzs <- ms1_charges <- ms1_ints <- vector("list", length(msx_moverzs))
  }
  
  pos_levs <- getMSrowIndexes(ms_level)
  ms1_stas <- pos_levs$ms1_stas
  ms2_stas <- pos_levs$ms2_stas
  ms2_ends <- pos_levs$ms2_ends
  rm(list = "pos_levs")
  
  # go from z = min_ms1_charge:max_ms1_charge first,  
  # then if (max_ms1_charge < 6) max_ms1_charge:6
  
  len <- length(ms1_stas)
  
  # get MS2 precursor xyz values from multiple adjacent MS1 scans
  for (i in 1:len) {
    rng1 <- ms1_stas[max(1L, i - n_mdda_flanks):min(len, i + n_mdda_flanks)]
    rng2 <- ms2_stas[i]:ms2_ends[i]
    
    ans <- find_mdda_mms1s(
      msx_moverzs = msx_moverzs[rng1], 
      msx_ints = msx_ints[rng1], 
      iso_ctr = iso_ctr[rng2], iso_lwr = iso_lwr[rng2], 
      ppm = ppm_ms1_deisotope, maxn_precurs = maxn_mdda_precurs, 
      max_ms1_charge = max_ms1_charge, n_fwd = 20L, 
      grad_isotope = grad_isotope, fct_iso2 = fct_iso2, 
      use_defpeaks = use_defpeaks)
    
    # Precursor x, y and z values for each MS2
    xs <- ans[["x"]]
    ys <- ans[["y"]]
    zs <- ans[["z"]]
    
    # updates corresponding MS1 x, y and z for each MS2
    oks <- .Internal(which(lengths(xs) > 0L))
    ms1_moverzs[rng2][oks] <- xs[oks]
    ms1_ints[rng2][oks] <- ys[oks]
    ms1_charges[rng2][oks] <- zs[oks]
  }
  rm(list = c("rng1", "rng2", "xs", "ys", "zs", "oks"))
  
  ms1_masses <- mapply(function (x, y) (x - 1.00727647) * y, 
                       ms1_moverzs, ms1_charges, 
                       SIMPLIFY = FALSE, USE.NAMES = FALSE)
  
  list(ms1_moverzs = ms1_moverzs, ms1_masses = ms1_masses, 
       ms1_charges = ms1_charges, ms1_ints = ms1_ints, 
       ms1_stas = ms1_stas, ms2_stas = ms2_stas, ms2_ends = ms2_ends)
}


#' Deisotoping DDA-MS2.
#' 
#' @param msx_moverzs MS2 moverzs.
#' @param msx_ints MS2 intensities.
#' @inheritParams matchMS
getMS2xyz <- function (msx_moverzs = NULL, msx_ints = NULL, 
                       topn_ms2ions = 150L, quant = "none", 
                       tmt_reporter_lower = 126.1, tmt_reporter_upper = 135.2, 
                       exclude_reporter_region = FALSE, 
                       max_ms2_charge = 3L, ppm_ms2_deisotope = 10L, 
                       grad_isotope = 1.6, fct_iso2 = 3.0)
{
  if (!(len <- length(msx_moverzs)))
    return(NULL)
  
  msx_charges <- vector("list", len)
  is_tmt <- if (isTRUE(grepl("^tmt.*\\d+", quant))) TRUE else FALSE
  
  for (i in 1:len) {
    xi <- msx_moverzs[[i]]
    yi <- msx_ints[[i]]
    ni <- rep_len(1L, length(xi))
    
    mic <- find_ms1stat(
      moverzs = xi, msxints = yi, n_ms1s = ni, center = 0, 
      tmt_reporter_lower = tmt_reporter_lower, 
      tmt_reporter_upper = tmt_reporter_upper, 
      # no deisotoping for TMT-MS2 reporter ions
      exclude_reporter_region = is_tmt, 
      ppm = ppm_ms2_deisotope, ms_lev = 2L, 
      maxn_feats = topn_ms2ions, 
      max_charge = max_ms2_charge,
      # smaller values for DDA-MS2
      n_fwd = 10L, offset_upr = 30L, offset_lwr = 30L, 
      grad_isotope = grad_isotope, fct_iso2 = fct_iso2, 
      order_mz = FALSE)
    
    msx_moverzs[[i]] <- mic[["masses"]]
    msx_ints[[i]] <- mic[["intensities"]]
    msx_charges[[i]] <- mic[["charges"]]
  }
  
  list(msx_moverzs = msx_moverzs, msx_ints = msx_ints, msx_charges = msx_charges)
}


#' Extracts DIA mzML.
#' 
#' @param is_demux Is demux DIA or not.
#' @param idx_demux Index of demux.
#' @inheritParams hdeisoDIA
#' @inheritParams extrDDA
extrDIA <- function (spec = NULL, raw_file = NULL, temp_dir = NULL, 
                     is_demux = FALSE, 
                     idx_sc = 5L, idx_osc = 3L, 
                     idx_mslev = 2L, idx_title = 10L, idx_scanList_1 = 11L, 
                     idx_scanList_2 = 11L, idx_rt_1 = 2L, idx_rt_2 = 2L, 
                     idx_scan_start_1 = 1L, idx_scan_start_2 = 1L, 
                     idx_precursor_2 = 12L, idx_isolationWindow = 1L, 
                     idx_ctrmz = 1L, idx_lwrmz = 2L, idx_uprmz = 3L, 
                     idx_selectedIonList = 2L, idx_demux = 4L, 
                     idx_bin_1 = 12L, idx_bin_2 = 13L, 
                     idx_scan_lwr_1 = 8L, idx_scan_upr_1 = 9L, 
                     idx_scan_lwr_2 = 8L, idx_scan_upr_2 = 9L)
{
  if (!(len <- length(spec)))
    return(NULL)
  
  ret_times <- orig_scans <- scan_nums <- scan_titles <- 
    iso_ctr <- iso_lwr <- iso_upr <- character(len)
  ms_levs <- msx_ns <- integer(len)
  msx_moverzs <- msx_ints <- vector("list", len)
  demux <- if (is_demux) rep_len("0", len) else NULL
  
  for (i in 1:len) {
    x <- spec[[i]]
    ids <- .Internal(strsplit(xml2::xml_attr(x, "id"), " ", fixed = TRUE, 
                              perl = FALSE, useBytes = FALSE))[[1]]
    ids <- .Internal(strsplit(ids, "=", fixed = TRUE, 
                              perl = FALSE, useBytes = FALSE))
    scan_nums[[i]] <- ids[[idx_sc]][[2]]
    orig_scans[[i]] <- ids[[idx_osc]][[2]]
    
    xc <- xml2::xml_children(x)
    ms_levs[[i]] <- ms_lev <- as.integer(xml2::xml_attr(xc[[idx_mslev]], "value"))
    scan_titles[[i]] <- xml2::xml_attr(xc[[idx_title]], "value")
    
    scanList <- xml2::xml_children(xc[[idx_scanList_1]])
    scanList_ret <- xml2::xml_children(scanList[[idx_rt_1]])
    ret_times[[i]] <- xml2::xml_attr(scanList_ret[[idx_scan_start_1]], "value")
    
    if (ms_lev == 2L) {
      # entire MS2 is empty
      if (length(xc) < idx_precursor_2) 
        next
      
      if (is_demux) 
        demux[[i]] <- ids[[idx_demux]][[2]]
      
      precursorList <- xml2::xml_children(xc[[idx_precursor_2]])
      precursor <- precursorList[[1]] # (assume always one precursor?)
      precursorc <- xml2::xml_children(precursor)
      isolationWindowc <- xml2::xml_children(precursorc[[idx_isolationWindow]])
      iso_ctr[[i]] <- xml2::xml_attr(isolationWindowc[[idx_ctrmz]], "value")
      iso_lwr[[i]] <- xml2::xml_attr(isolationWindowc[[idx_lwrmz]], "value")
      iso_upr[[i]] <- xml2::xml_attr(isolationWindowc[[idx_uprmz]], "value")
      binData <- xml2::xml_children(xml2::xml_children(xc[[idx_bin_2]]))
    }
    else if (ms_lev == 1L) {
      # iso_lwr[[i]] <- as.numeric(xml2::xml_attr(xc[[idx_scan_lwr_1]], "value"))
      # iso_upr[[i]] <- as.numeric(xml2::xml_attr(xc[[idx_scan_upr_1]], "value"))
      binData <- xml2::xml_children(xml2::xml_children(xc[[idx_bin_1]]))
    }
    
    msData <- xml2::xml_contents(binData)
    
    if (length(msData) == 2L) {
      r1 <- .Call(base64enc:::B64_decode, xml2::xml_text(msData[[1]]))
      r2 <- .Call(base64enc:::B64_decode, xml2::xml_text(msData[[2]]))
      msx_ns[[i]] <- msx_n <- as.integer(length(r1)/8L)
      msx_moverzs[[i]] <- readBin(r1, "double", n = msx_n, size = 8L)
      msx_ints[[i]] <- readBin(r2, "double", n = msx_n, size = 8L)
    }
  }
  
  # mzML: ret_times in minutes; MGF: in seconds
  ret_times <- as.numeric(ret_times) * 60
  scan_nums <- as.integer(scan_nums)
  iso_ctr <- as.numeric(iso_ctr)
  iso_lwr <- as.numeric(iso_lwr) 
  iso_upr <- as.numeric(iso_upr) 
  demux <- as.integer(demux)
  
  out <- list(
    # either MS1 or MS2
    msx_moverzs = msx_moverzs, 
    msx_ints = msx_ints, 
    msx_ns = msx_ns,
    scan_title = scan_titles,
    raw_file = raw_file, # single
    ms_level = ms_levs, # NA for MS1
    ret_time = ret_times, 
    scan_num = scan_nums, 
    orig_scan = orig_scans,
    iso_ctr = iso_ctr, 
    iso_lwr = iso_lwr, 
    iso_upr = iso_upr, 
    demux = demux
  )

  out_name <- paste0(raw_file, ".rds")
  qs::qsave(out, file.path(temp_dir, out_name), preset = "fast")
  invisible(out_name)
}


#' Helper of \link{deisoDIA}.
#' 
#' @param filename A peaklist filename.
#' @param temp_dir A temp_dir to the filename.
#' @param n_para The allowance of parallel processing.
#' @inheritParams extrDDA
#' @inheritParams matchMS
hdeisoDIA <- function (filename = NULL, temp_dir = NULL, 
                       min_mass = 200L, max_mass = 4500L,
                       min_ms2mass = 115L, max_ms2mass = 4500L, 
                       maxn_dia_precurs = 500L, topn_dia_ms2ions = 5000L, 
                       min_ms1_charge = 2L, max_ms1_charge = 4L, 
                       min_ret_time = 0, max_ret_time = Inf, 
                       ppm_ms1_deisotope = 8L, ppm_ms2_deisotope = 8L, 
                       deisotope_ms2 = TRUE, max_ms2_charge = 3L, 
                       grad_isotope = 1.6, fct_iso2 = 3.0, 
                       quant = "none", 
                       tmt_reporter_lower = 126.1, tmt_reporter_upper = 135.2, 
                       exclude_reporter_region = FALSE, n_para = 1L)
{
  ans <- qs::qread(file.path(temp_dir, filename))
  msx_ns <- ans$msx_ns
  scan_title <- ans$scan_title
  raw_file <- ans$raw_file # scalar
  ms_level <- ans$ms_level
  ret_time <- ans$ret_time 
  scan_num <- ans$scan_num
  orig_scan <- ans$orig_scan
  iso_ctr <- ans$iso_ctr
  iso_lwr <- ans$iso_lwr
  iso_upr <- ans$iso_upr
  demux <- ans$demux
  msx_moverzs <- ans$msx_moverzs
  msx_ints <- ans$msx_ints
  rm(list = "ans")
  
  # need first disotope to learn charge states before data cleaning by 
  #  min_ms2mass and max_ms2mass
  if (n_para <= 1L) {
    out <- deisoDIA(
      msx_moverzs, msx_ints, ms_level, 
      min_mass = min_mass, max_mass = max_mass,
      min_ms2mass = min_ms2mass, max_ms2mass = max_ms2mass, 
      maxn_dia_precurs = maxn_dia_precurs, 
      topn_dia_ms2ions = topn_dia_ms2ions, 
      min_ms1_charge = min_ms1_charge, 
      max_ms1_charge = max_ms1_charge, 
      ppm_ms1_deisotope = ppm_ms1_deisotope, 
      ppm_ms2_deisotope = ppm_ms2_deisotope, 
      deisotope_ms2 = deisotope_ms2, 
      max_ms2_charge = max_ms2_charge, 
      grad_isotope = grad_isotope, 
      fct_iso2 = fct_iso2, 
      quant = quant, 
      tmt_reporter_lower = tmt_reporter_lower, 
      tmt_reporter_upper = tmt_reporter_upper, 
      exclude_reporter_region = exclude_reporter_region)
    
    msx_moverzs <- out[[1]]
    msx_ints <- out[[2]]
    msx_charges <- out[[3]]
    msx_masses <- out[[4]] # new
    rm(list = "out")
  }
  else {
    grps <- sep_vec(msx_moverzs, n_para * 4L)
    
    cl <- parallel::makeCluster(getOption("cl.cores", n_para))
    out <- parallel::clusterMap(
      cl, deisoDIA, 
      split(msx_moverzs, grps), split(msx_ints, grps), split(ms_level, grps), 
      MoreArgs = list(
        min_mass = min_mass, 
        max_mass = max_mass,
        min_ms2mass = min_ms2mass, 
        max_ms2mass = max_ms2mass, 
        maxn_dia_precurs = maxn_dia_precurs, 
        topn_dia_ms2ions = topn_dia_ms2ions, 
        min_ms1_charge = min_ms1_charge, 
        max_ms1_charge = max_ms1_charge, 
        ppm_ms1_deisotope = ppm_ms1_deisotope, 
        ppm_ms2_deisotope = ppm_ms2_deisotope, 
        deisotope_ms2 = deisotope_ms2, 
        max_ms2_charge = max_ms2_charge, 
        grad_isotope = grad_isotope, 
        fct_iso2 = fct_iso2, 
        quant = quant, 
        tmt_reporter_lower = tmt_reporter_lower, 
        tmt_reporter_upper = tmt_reporter_upper, 
        exclude_reporter_region = exclude_reporter_region
      ), SIMPLIFY = FALSE, USE.NAMES = FALSE, .scheduling = "dynamic")
    parallel::stopCluster(cl)
    
    msx_moverzs <- lapply(out, `[[`, 1L)
    msx_ints <- lapply(out, `[[`, 2L)
    msx_charges <- lapply(out, `[[`, 3L)
    msx_masses <<- lapply(out, `[[`, 4L) # new
    rm(list = "out")
    
    msx_moverzs <- unlist(msx_moverzs, recursive = FALSE, use.names = FALSE)
    msx_ints <- unlist(msx_ints, recursive = FALSE, use.names = FALSE)
    msx_charges <- unlist(msx_charges, recursive = FALSE, use.names = FALSE)
    msx_masses <- unlist(msx_masses, recursive = FALSE, use.names = FALSE) # new
  }
  
  ms1_moverzs <- ms1_ints <- ms1_charges <- vector("list", length(msx_moverzs))
  
  df <- tibble::tibble(
    scan_title = scan_title,
    raw_file = raw_file,
    ms_level = ms_level, 
    ret_time = ret_time, 
    scan_num = scan_num, 
    orig_scan = orig_scan,
    # full MS1 or MS2
    msx_moverzs = msx_moverzs, 
    msx_ints = msx_ints, 
    msx_charges = msx_charges, 
    msx_masses = msx_masses, # new
    msx_ns = msx_ns, 
    
    # MS1 placeholder
    ms1_moverzs = ms1_moverzs, 
    ms1_ints = ms1_ints, 
    # MS1: vector or empty vector; MS2: NULL
    ms1_charges = ms1_charges, 
    
    iso_ctr = iso_ctr, 
    iso_lwr = iso_lwr, 
    iso_upr = iso_upr, 
    demux = demux)
  
  out_name <- paste0("dia_", filename)
  qs::qsave(df, file.path(temp_dir, out_name), preset = "fast")
  invisible(out_name)
}


#' Deisotopes DIA-MS from MSConvert peaklists.
#' 
#' @param msx_moverzs Vectors of moverzs.
#' @param msx_ints Vectors of intensities.
#' @param ms_level Vectors of MS levels.
#' @inheritParams hdeisoDIA
#' @inheritParams matchMS
deisoDIA <- function (msx_moverzs = NULL, msx_ints = NULL, ms_level = NULL, 
                      min_mass = 200L, max_mass = 4500L,
                      min_ms2mass = 115L, max_ms2mass = 4500L, 
                      maxn_dia_precurs = 500L, topn_dia_ms2ions = 5000L, 
                      min_ms1_charge = 2L, max_ms1_charge = 4L, 
                      ppm_ms1_deisotope = 8L, ppm_ms2_deisotope = 8L, 
                      deisotope_ms2 = TRUE, max_ms2_charge = 3L, 
                      grad_isotope = 1.6, fct_iso2 = 3.0, quant = "none", 
                      tmt_reporter_lower = 126.1, tmt_reporter_upper = 135.2, 
                      exclude_reporter_region = FALSE)
{
  if (!(len <- length(msx_moverzs)))
    return(NULL)
  
  msx_masses <- msx_charges <- vector("list", len)
  is_tmt <- if (isTRUE(grepl("^tmt.*\\d+", quant))) TRUE else FALSE
  # if (is_tmt) stop("TMT not yet supported with DIA workflows.")
  
  ### need to collapse MS1 or DIA-MS2
  # ans <- collMS(xs = msx_moverzs, ys = msx_ints, lwr = 115L, step = 1e-5, coll = TRUE)
  ###
  

  for (i in 1:len) {
    ms_lev <- ms_level[[i]]
    
    if (ms_lev == 2L && deisotope_ms2) {
      # to collapse MS2 if is DIA...
      
      xi <- msx_moverzs[[i]]
      yi <- msx_ints[[i]]
      ni <- rep_len(1L, length(xi))
      
      mic <- find_ms1stat(
        moverzs = xi, msxints = yi, n_ms1s = ni, 
        center = 0, exclude_reporter_region = is_tmt, 
        tmt_reporter_lower = tmt_reporter_lower, 
        tmt_reporter_upper = tmt_reporter_upper, 
        is_dda = FALSE, ppm = ppm_ms2_deisotope, 
        ms_lev = 2L, maxn_feats = topn_dia_ms2ions, 
        max_charge = max_ms2_charge, n_fwd = 10L, 
        offset_upr = 30L, offset_lwr = 30L, 
        grad_isotope = grad_isotope, fct_iso2 = fct_iso2, 
        order_mz = FALSE)
      
      xs <- mic[["masses"]]
      ys <- mic[["intensities"]]
      zs <- mic[["charges"]]
      ms <- (xs - 1.00727647) * zs
      oks <- is.na(zs) | (ms >= min_ms2mass & ms <= max_ms2mass)

      msx_moverzs[[i]] <- xs[oks]
      msx_ints[[i]] <- ys[oks]
      msx_charges[[i]] <- zs[oks]
      # no need at ms_lev == 2L
      msx_masses[[i]] <- ms[oks]
    }
    else if (ms_lev == 1L) {
      xi <- msx_moverzs[[i]]
      yi <- msx_ints[[i]]
      ni <- rep_len(1L, length(xi))
      
      mic <- find_ms1stat(
        moverzs = xi, msxints = yi, n_ms1s = ni, 
        center = 0, exclude_reporter_region = FALSE, 
        is_dda = FALSE, ppm = ppm_ms1_deisotope, 
        ms_lev = 1L, 
        # by the width of MS1: 395 - 1005???
        maxn_feats = maxn_dia_precurs, 
        max_charge = max_ms1_charge, 
        n_fwd = 20L, offset_upr = 30L, offset_lwr = 30L, 
        grad_isotope = grad_isotope, 
        fct_iso2 = fct_iso2, order_mz = FALSE)
      
      xs <- mic[["masses"]]
      ys <- mic[["intensities"]]
      zs <- mic[["charges"]] # MS2: NULL; MS1: integer vectors
      ms <- (xs - 1.00727647) * zs
      oks <- is.na(zs) | (ms >= min_mass & ms <= max_mass)

      msx_moverzs[[i]] <- xs[oks]
      msx_ints[[i]] <- ys[oks]
      msx_charges[[i]] <- zs[oks]
      msx_masses[[i]] <- ms[oks]
    }
  }
  
  # msx_charges and msx_masses can be NA for MS2
  list(msx_moverzs = msx_moverzs, msx_ints = msx_ints, 
       msx_charges = msx_charges, msx_masses = msx_masses)
}


#' Helper of \link{subDIAMS1} for parallel processing.
#' 
#' @param filename A filename.
#' @param temp_dir A temporary file folder.
#' @param n_para The allowance of parallel processing.
hsubDIAMS1 <- function (filename = NULL, temp_dir = NULL, n_para = 1L)
{
  df <- qs::qread(file.path(temp_dir, filename))
  
  if (n_para <= 1L)
    return(subDIAMS1(df))
  
  idxes <- findInterval(1:nrow(df), which(df$ms_level == 1L))
  ends2 <- find_group_breaks(idxes, n_para, by_rngs = FALSE)
  stas1 <- c(1L, ends2[1:(n_para - 1L)] + 1L)
  
  dfs <- mapply(function (x, y) df[x:y, ], stas1, ends2, 
                SIMPLIFY = FALSE, USE.NAMES = FALSE)
  rm(list = c("df", "idxes", "ends2", "stas1"))
  
  cl <- parallel::makeCluster(getOption("cl.cores", n_para))
  ans <- parallel::clusterApply(cl, dfs, subDIAMS1)
  parallel::stopCluster(cl)
  rm(list = "dfs")
  
  df <- dplyr::bind_rows(ans)
  out_name <- paste0("sub", filename)
  qs::qsave(df, file.path(temp_dir, out_name), preset = "fast")
  invisible(out_name)
}


#' Gets precursor mass candidates for each DIA window.
#' 
#' Subsets by MS2 isolation windows.
#' 
#' @param df A data frame.
subDIAMS1 <- function (df)
{
  nr <- nrow(df)
  idxes_ms1 <- which(df$ms_level == 1L)
  len <- length(idxes_ms1)

  # adds a non-consecutive trailing index
  idxes_ms1x <- c(idxes_ms1, idxes_ms1[len] + 2L)
  
  # Keep the last MS1 for each segment of consecutive MS1 scans
  diff_ms1 <- c(0L, diff(idxes_ms1x))
  oks <- which(diff_ms1 > 1L)
  ms1_stas <- idxes_ms1x[oks - 1L]
  ms2_stas <- ms1_stas + 1L # the last value can be arbitrary if ends with MS1
  ms2_ends <- idxes_ms1x[oks] - 1L # the last is arbitrary
  
  if (nr > idxes_ms1[len]) { # with MS2s after the last MS1
    ms2_ends[len] <- nr
  }
  else { # no MS2s after the last MS1
    len1 <- length(ms1_stas)
    ms1_stas <- ms1_stas[-len1]
    ms2_stas <- ms2_stas[-len1]
    ms2_ends <- ms2_ends[-len1]
  }
  rm(list = c("oks", "diff_ms1", "idxes_ms1", "idxes_ms1x"))
  
  for (i in seq_along(ms1_stas)) {
    idx <- ms1_stas[i]
    df1 <- df[idx, ]
    xs <- df1$msx_moverzs[[1]]
    
    if ((nx <- length(xs)) == 0L || (nx == 1L && is.na(xs)))
      next
    
    ys  <- df1$msx_ints[[1]]
    css <- df1$msx_charges[[1]]
    
    sta <- ms2_stas[i]
    end <- ms2_ends[i]
    rows2 <- sta:end
    df2 <- df[rows2, ]
    
    half  <- df2$iso_upr[[1]]
    cents <- df2$iso_ctr
    
    # the first center not the smallest: up first then down
    if ((imin <- which.min(cents)) > 1L) {
      edg_b <- c(cents[[1]] - half, cents[1:(imin-1L)] + half)
      len_b <- length(edg_b)
      # edg_b[[1]] <- edg_b[[1]] - .5
      # edg_b[[len_b]] <- edg_b[[len_b]] + .5
      
      cuts_b <- findInterval(xs, edg_b)
      xs_b <- split(xs, cuts_b)
      ys_b <- split(ys, cuts_b)
      css_b <- split(css, cuts_b)
      
      bins_b <- as.integer(names(xs_b))
      oks_b <- bins_b > 0L & bins_b < len_b
      # bins_b <- bins_b[oks_b]
      xs_b <- xs_b[oks_b]
      ys_b <- ys_b[oks_b]
      css_b <- css_b[oks_b]
      
      edg_a <- c(cents[[imin]] - half, cents[imin:length(cents)] + half)
      len_a <- length(edg_a)
      # edg_a[[1]] <- edg_a[[1]] - .5
      # edg_a[[len_a]] <- edg_a[[len_a]] + .5
      
      cuts_a <- findInterval(xs, edg_a)
      xs_a <- split(xs, cuts_a)
      ys_a <- split(ys, cuts_a)
      css_a <- split(css, cuts_a)
      
      bins_a <- as.integer(names(xs_a))
      oks_a <- bins_a > 0L & bins_a < len_a
      # bins_a <- bins_a[oks_a]
      xs_a <- xs_a[oks_a]
      ys_a <- ys_a[oks_a]
      css_a <- css_a[oks_a]
      
      bins <- c(as.integer(names(xs_b)), as.integer(names(xs_a)) + imin - 1L)
      df$ms1_moverzs[rows2][bins] <- c(xs_b, xs_a)
      df$ms1_ints[rows2][bins] <- c(ys_b, ys_a)
      df$ms1_charges[rows2][bins] <- c(css_b, css_a)
    }
    else {
      edges <- c(cents[[1]] - half, cents + half)
      len_ab <- length(edges)
      # edges[[1]] <- edges[[1]] - .5
      # edges[[len_ab]] <- edges[[len_ab]] + .5
      
      cuts <- findInterval(xs, edges)
      xs_cuts <- split(xs, cuts)
      ys_cuts <- split(ys, cuts)
      css_cuts <- split(css, cuts)
      
      # excludes precursors outside the isolation window
      bins <- as.integer(names(xs_cuts))
      oks <- bins > 0L & bins < len_ab
      bins <- bins[oks]
      df$ms1_moverzs[rows2][bins] <- xs_cuts[oks]
      df$ms1_ints[rows2][bins] <- ys_cuts[oks]
      df$ms1_charges[rows2][bins] <- css_cuts[oks]
    }
  }
  
  df
}


#' Helper of tracing DIA.
#' 
#' @param filename A filename.
#' @param raw_id A raw file id.
#' @param temp_dir A temporary directory. 
#' @param n_para The allowance of parallel processing.
#' @inheritParams load_mgfs
htraceDIA <- function (filename, raw_id, temp_dir, mgf_path, 
                       min_ret_time = 0L, max_ret_time = Inf, 
                       min_mass = 200L, max_mass = 4500L, 
                       min_ms2mass = 115L, max_ms2mass = 4500L, 
                       ppm_ms1 = 8L, ppm_ms2 = 8L, 
                       n_dia_ms2bins = 1L, n_dia_scans = 4L, 
                       delayed_diams2_tracing = FALSE, topn_dia_ms2ions = 2400L, 
                       mgf_cutmzs = numeric(), mgf_cutpercs = numeric(), 
                       quant = "none", 
                       tmt_reporter_lower = 126.1, tmt_reporter_upper = 135.2, 
                       exclude_reporter_region = FALSE, n_para = 1L)
{
  ### cleanDIAMS
  df <- qs::qread(file.path(temp_dir, filename))
  df$msx_masses <- NULL
  
  # NULL: no MS1 in the bins
  df <- df[with(df, ms_level != 1L), ]
  bads <- unlist(lapply(df$ms1_moverzs, is.null), recursive = FALSE, 
                 use.names = FALSE)
  df <- df[!bads, ]
  rm(list = "bads")
  
  df <- dplyr::rename(df, ms2_moverzs = msx_moverzs, ms2_ints = msx_ints, 
                      ms2_charges = msx_charges, ms2_n = msx_ns, 
                      ms1_moverz = ms1_moverzs, ms1_int = ms1_ints, 
                      ms1_charge = ms1_charges)
  rts <- reset_rettimes(ret_times = df$ret_time, min_ret_time = min_ret_time, 
                        max_ret_time = max_ret_time)
  min_ret_time <- rts$min_ret_time
  max_ret_time <- rts$max_ret_time
  df <- dplyr::filter(df, ret_time >= min_ret_time, ret_time <= max_ret_time)
  rm(list = "rts")
  
  ## traces MS2
  ws <- dnorm(-n_dia_scans:n_dia_scans, mean = 0, sd = 2)
  ws <- ws/ws[n_dia_scans+1L]
  
  cols <- c("ms1_moverz", "ms1_int", "ms1_charge", 
            "ms2_moverzs", "ms2_ints", "ms2_charges")
  
  if (!all(cols %in% names(df)))
    stop("Not all required columns found for tracing MS features.")
  
  dfs <- split(df, df$iso_ctr)
  rm(list = "df")
  
  subdir <- create_dir(file.path(temp_dir, paste0("sub_", raw_id)))
  
  if (n_para <= 1L) {
    dfs <- mapply(
      traceDIA, dfs, seq_along(dfs), 
      MoreArgs = list(
        ws = ws, n_dia_scans = n_dia_scans, n_dia_ms2bins = n_dia_ms2bins, 
        temp_dir = subdir, min_mass = min_mass, min_ms2mass = min_ms2mass, 
        step1 = ppm_ms1/1e6, step2 = ppm_ms2/1e6, 
        delayed_diams2_tracing = delayed_diams2_tracing
      ), SIMPLIFY = FALSE, USE.NAMES = FALSE)
  }
  else {
    cl <- parallel::makeCluster(getOption("cl.cores", n_para))
    
    dfs <- parallel::clusterMap(
      cl, traceDIA, dfs, seq_along(dfs),
      MoreArgs = list(
        ws = ws, n_dia_scans = n_dia_scans, n_dia_ms2bins = n_dia_ms2bins, 
        temp_dir = subdir, 
        min_mass = min_mass, 
        min_ms2mass = min_ms2mass, 
        step1 = ppm_ms1/1e6, step2 = ppm_ms2/1e6, 
        delayed_diams2_tracing = delayed_diams2_tracing
      ), SIMPLIFY = FALSE, USE.NAMES = FALSE)
    
    parallel::stopCluster(cl)
  }
  
  df <- dplyr::bind_rows(dfs)
  rm(list = "dfs")
  unlink(subdir, recursive = TRUE)
  
  ## Clean up
  lens <- lengths(df$ms1_moverz)
  df <- df[lens > 0L, ]
  # use singular names for consistency with DDA
  df$ms1_mass <- mapply(function (x, y) (x - 1.00727647) * y, 
                        df$ms1_moverz, df$ms1_charge, 
                        SIMPLIFY = FALSE, USE.NAMES = FALSE)
  df <- reloc_col_before(df, "ms1_mass", "ms1_moverz")
  
  restmt <- extract_mgf_rptrs(df$ms2_moverzs, 
                              df$ms2_ints, 
                              quant = quant, 
                              tmt_reporter_lower = tmt_reporter_lower, 
                              tmt_reporter_upper = tmt_reporter_upper, 
                              exclude_reporter_region = exclude_reporter_region)
  df$ms2_moverzs <- restmt[["xvals"]]
  df$ms2_ints <- restmt[["yvals"]]
  df$rptr_moverzs <- restmt[["rptr_moverzs"]]
  df$rptr_ints <- restmt[["rptr_ints"]]
  df$iso_lwr <- df$iso_upr <- df$iso_ctr <- NULL
  
  mz_n_int <- sub_mgftopn(ms2_moverzs = df[["ms2_moverzs"]], 
                          ms2_ints = df[["ms2_ints"]], 
                          ms2_charges = df[["ms2_charges"]], 
                          
                          topn_ms2ions = topn_dia_ms2ions, 
                          
                          mgf_cutmzs = mgf_cutmzs, 
                          mgf_cutpercs = mgf_cutpercs, 
                          min_ms2mass = min_ms2mass, 
                          max_ms2mass = max_ms2mass)
  df[["ms2_moverzs"]] <- mz_n_int[["ms2_moverzs"]]
  df[["ms2_ints"]] <- mz_n_int[["ms2_ints"]]
  df[["ms2_charges"]] <- mz_n_int[["ms2_charges"]]
  df[["ms2_n"]] <- mz_n_int[["lens"]]
  
  # fuzzy precursor masses and the corresponding scan_nums are duplicated 
  #  In `calcpepsc`, uniq_id: scan_num + raw_file + ms1_offset
  #  In `calc_pepfdr`, uniq_id: scan_num + raw_file
  #  In `post_pepfdr`, `calc_peploc`, `hcalc_tmtint`, `add_rptrs`
  
  post_readmgf(df, raw_id = raw_id, mgf_path = mgf_path)
}


#' Traces DIA-MS2 against MS1.
#'
#' For a single MS1 isolation range, e.g., 592.5 to 604.5.
#'
#' @param df A data frame.
#' @param icenter The index of an isolation center.
#' @param ws Weights.
#' @param temp_dir A temporary directory.
#' @param n_dia_scans The number of adjacent MS scans for constructing a peak
#'   profile and thus for determining the apex scan number of an moverz value
#'   along LC.
#' @param step1 A step size for MS1.
#' @param step2 A step size for MS2.
#' @param join_ms Logical; if TRUE, combine adjacent entries.
#' @param spread_ohw logical; if TRUE, spread one-hit wonders to the nearest
#'   neighbors.
#' @inheritParams load_mgfs
traceDIA <- function (df = NULL, icenter = 1L, ws = NULL, n_dia_scans = 4L, 
                      n_dia_ms2bins = 1L, min_mass = 200L, min_ms2mass = 115L, 
                      step1 = 1E-5, step2 = 1E-5, temp_dir = NULL, 
                      join_ms = FALSE, spread_ohw = FALSE, 
                      delayed_diams2_tracing = FALSE)
{
  len <- nrow(df)

  mat1 <- traceLCMS(
    xs = df[["ms1_moverz"]], 
    ys = df[["ms1_int"]], 
    zs = df[["ms1_charge"]], 
    n_dia_scans = n_dia_scans, 
    from = min_mass, 
    step = step1, 
    icenter = icenter, 
    ms_lev = 1L, 
    temp_dir = temp_dir)
  
  mat1x <- mat1[["x"]] # columns: masses; rows: scans
  mat1y <- mat1[["y"]]
  mat1z <- mat1[["z"]]
  ns1 <- mat1[["n"]]
  ps1 <- mat1[["p"]] # e.g., matx[ps[[4]], 4] to bypass which(!is.na(matx[, 4]))
  rm(list = "mat1")
  gc()
  
  # may only borrow ps1 >= 2L
  
  ans1 <- flattenMSxyz(matx = mat1x, maty = mat1y, matz = mat1z, 
                       join_ms = join_ms)
  ansx1 <- ans1[["x"]]
  ansy1 <- ans1[["y"]]
  ansz1 <- ans1[["z"]]
  rm(list = "ans1")
  
  if (spread_ohw) {
    ans1_1 <- spreadMSohw(matx = mat1x, maty = mat1y, matz = mat1z, ns = ns1, 
                          ps = ps1, gap = 1L, join_ms = join_ms)
    ansx1_1 <- ans1_1[["x"]]
    ansy1_1 <- ans1_1[["y"]]
    ansz1_1 <- ans1_1[["z"]]
    rm(list = "ans1_1")
    
    for (i in seq_along(ansx1)) {
      ansx1[[i]] <- c(ansx1[[i]], ansx1_1[[i]])
      ansy1[[i]] <- c(ansy1[[i]], ansy1_1[[i]])
      ansz1[[i]] <- c(ansz1[[i]], ansz1_1[[i]])
    }
    rm(list = c("ansx1_1", "ansy1_1", "ansz1_1"))
  }

  if (delayed_diams2_tracing) {
    df$ms1_moverz <- ansx1
    df$ms1_int <- ansy1
    df$ms1_charge <- ansz1
    
    return(df)
  }

  mat2 <- traceLCMS(
    xs = df[["ms2_moverzs"]], 
    ys = df[["ms2_ints"]], 
    zs = df[["ms2_charges"]], 
    n_dia_scans = n_dia_scans, 
    from = min_ms2mass, 
    step = step2, 
    icenter = icenter, 
    ms_lev = 2L, 
    temp_dir = temp_dir)
  
  mat2x <- mat2[["x"]]
  mat2y <- mat2[["y"]]
  mat2z <- mat2[["z"]]
  ns2 <- mat2[["n"]]
  ps2 <- mat2[["p"]]
  rm(list = "mat2")
  gc()
  
  # need weights?
  # need to remove duplicated entries? should not occur
  
  # exclude high-confidence peak apexes, only join_ms from neighbors at ps2 <= 2L...
  
  # may only borrow ps1 >= 2L
  
  ans2 <- flattenMSxyz(matx = mat2x, maty = mat2y, matz = mat2z, 
                       join_ms = join_ms)
  ansx2 <- ans2[["x"]]
  ansy2 <- ans2[["y"]]
  ansz2 <- ans2[["z"]]
  rm(list = "ans2")
  gc()
  
  if (spread_ohw) {
    ans2_1 <- spreadMSohw(matx = mat2x, maty = mat2y, matz = mat2z, ns = ns2, 
                          ps = ps2, gap = 1L, join_ms = join_ms)
    ansx2_1 <- ans2_1[["x"]]
    ansy2_1 <- ans2_1[["y"]]
    ansz2_1 <- ans2_1[["z"]]
    rm(list = "ans2_1", "mat2x", "mat2y", "mat2z")
    gc()
    
    for (i in seq_along(ansx2)) {
      ansx2[[i]] <- c(ansx2[[i]], ansx2_1[[i]])
      ansy2[[i]] <- c(ansy2[[i]], ansy2_1[[i]])
      ansz2[[i]] <- c(ansz2[[i]], ansz2_1[[i]])
    }
    rm(list = c("ansx2_1", "ansy2_1", "ansz2_1"))
  }

  df$ms2_moverzs <- ansx2
  df$ms2_ints <- ansy2
  df$ms2_charges <- ansz2
  rm(list = c("ansx2", "ansy2", "ansz2"))

  # need to order or not???
  ords <- lapply(df$ms2_moverzs, order)
  df$ms2_moverzs <- mapply(function (x, y) x[y], df$ms2_moverzs, ords,
                           SIMPLIFY = FALSE, USE.NAMES = FALSE)
  df$ms2_ints <- mapply(function (x, y) x[y], df$ms2_ints, ords,
                        SIMPLIFY = FALSE, USE.NAMES = FALSE)
  df$ms2_charges <- mapply(function (x, y) x[y], df$ms2_charges, ords,
                           SIMPLIFY = FALSE, USE.NAMES = FALSE)
  
  df
}


#' Flattens MS data.
#' 
#' Joins data across adjacent scans af \code{combine = TRUE}.
#' 
#' @param matx The data matrix of moverzs.
#' @param maty The data matrix of intensities.
#' @param matz The data matrix of charge states.
#' @param join_ms Logical; if TRUE, combine adjacent entries.
flattenMSxyz <- function (matx, maty, matz, join_ms = FALSE)
{
  n_scans <- nrow(matx)
  n_masses <- ncol(matx)
  
  zs <- ys <- xs <- vector("list", n_scans)

  for (i in seq_len(n_scans)) {
    xi <- matx[i, ]
    yi <- maty[i, ]
    zi <- matz[i, ]
    oks <- .Internal(which(!is.na(xi)))
    xs[[i]] <- xi[oks]
    ys[[i]] <- yi[oks]
    zs[[i]] <- zi[oks]
  }
  rm(list = c("xi", "yi", "zi"))

  if (n_scans <= 3L || !join_ms)
    return(list(x = xs, y = ys, z = zs))

  ansz <- ansy <- ansx <- vector("list", n_scans)
  
  xbf <- xs[[1]]
  ybf <- ys[[1]]
  zbf <- zs[[1]]
  ansx[[1]] <- xbf
  ansy[[1]] <- ybf
  ansz[[1]] <- zbf
  
  for (i in 2:(n_scans-1)) {
    ix <- i+1
    xcr <- xs[[i]]
    ycr <- ys[[i]]
    zcr <- zs[[i]]
    xaf <- xs[[ix]]
    yaf <- ys[[ix]]
    zaf <- zs[[ix]]
    ansx[[i]] <- c(xbf, xcr, xaf)
    ansy[[i]] <- c(ybf, ycr, yaf)
    ansz[[i]] <- c(zbf, zcr, zaf)
    
    xbf <- xcr
    ybf <- ycr
    zbf <- zcr
  }
  
  list(x = ansx, y = ansy, z = ansz)
}


#' Spreads one-hit wonders to adjacent scans.
#'
#' @param matx The data matrix of moverzs.
#' @param maty The data matrix of intensities.
#' @param matz The data matrix of charge states.
#' @param ns The number of observing spectra that have contributed to an MS
#'   feature. One-hit wonders correspond to \code{ns == 1L}.
#' @param ps The row positions (along LC scans) of features.
#' @param gap The gap width for one-hit wonders.
#' @param join_ms Logical; if TRUE, combine adjacent entries.
spreadMSohw <- function (matx, maty, matz, ns, ps, gap = 2L, join_ms = FALSE)
{
  # stopifnot((gap >= 1L))
  
  n_scans <- nrow(matx)
  n_masses <- ncol(matx)
  # 2L: since the first neighbor already jointed in flattenMSxyz
  n_nearest <- if (join_ms) 2L else 1L
  
  zout <- yout <- xout <- vector("list", n_scans)

  # across columns of masses
  for (i in 1:n_masses) {
    ni <- ns[[i]]
    pi <- ps[[i]]
    rows1 <- pi[ni == 1L]
    
    # goes through one-hit wonders
    for (j in seq_along(rows1)) {
      rj1 <- rows1[[j]]
      x <- matx[rj1, i]
      y <- maty[rj1, i]
      z <- matz[rj1, i]

      rng1 <- c(max((rj1 - gap), 1):max((rj1 - n_nearest), 1), 
                min((rj1 + n_nearest), n_scans):min((rj1 + gap), n_scans))
      
      # go through the k neighbors of a one-hit wonder
      for (k in seq_along(rng1)) {
        rng1k <- rng1[[k]]
        xout[[rng1k]] <- c(xout[[rng1k]], x)
        yout[[rng1k]] <- c(yout[[rng1k]], y)
        zout[[rng1k]] <- c(zout[[rng1k]], z)
      }
    }
  }
  
  list(x = xout, y = yout, z = zout)
}


#' Spreads MS data across adjacent scans.
#' 
#' Not used.
#' 
#' @param matx The data matrix of moverzs.
#' @param maty The data matrix of intensities.
#' @param matz The data matrix of charge states.
#' @param ns The number of observing spectra that have contributed to an MS
#'   feature.
#' @param ps The row positions (along LC scans) of features.
spreadMS_v1 <- function (matx, maty, matz, ns, ps)
{
  n_scans <- nrow(matx)
  n_masses <- ncol(matx)
  
  if (n_scans <= 2L)
    return(list(x = matx, y = maty, z = matz))
  
  gap1 <- 2L
  gap2 <- 2L
  gap0 <- 1L
  
  for (i in 1:n_masses) {
    ni <- ns[[i]]
    pi <- ps[[i]]
    
    rows0 <- pi[ni >= 3L]
    rows1 <- pi[ni == 1L]
    rows2 <- pi[ni == 2L]
    
    for (j in seq_along(rows1)) {
      rj1 <- rows1[[j]]
      rng1 <- max((rj1 - gap1), 1L):min((rj1 + gap1), n_scans)
      
      # what if !is.na(matx[rng1, i])??? do not overwrite...

      matx[rng1, i] <- matx[rj1, i]
      maty[rng1, i] <- maty[rj1, i]
      matz[rng1, i] <- matz[rj1, i]
    }
    
    for (j in seq_along(rows2)) {
      rj2 <- rows2[[j]]
      rng2 <- max((rj2 - gap2), 1L):min((rj2 + gap2), n_scans)
      matx[rng2, i] <- matx[rj2, i]
      maty[rng2, i] <- maty[rj2, i]
      matz[rng2, i] <- matz[rj2, i]
    }
    
    for (j in seq_along(rows0)) {
      rj0 <- rows0[[j]]
      rng0 <- max((rj0 - gap0), 1L):min((rj0 + gap0), n_scans)
      matx[rng0, i] <- matx[rj0, i]
      maty[rng0, i] <- maty[rj0, i]
      matz[rng0, i] <- matz[rj0, i]
    }
  }
  
  list(x = matx, y = maty, z = matz)
}


#' Combines adjacent MS2 traces.
#' 
#' Not used.
#' 
#' @param xs Vectors of MS2 moverzs.
#' @param ys Vectors of MS2 intensities.
#' @param zs Vectors of MS2 charge states.
#' @param ws Weights.
#' @inheritParams matchMS
#' @importFrom fastmatch %fin% 
comb_mstraces <- function (xs, ys, zs, ws, n_dia_ms2bins = 1L)
{
  if (!n_dia_ms2bins)
    return(list(x = xs, y = ys, z = zs))
  
  ansz <- ansy <- ansx <- vector("list", len <- length(xs))
  
  for (i in 1:n_dia_ms2bins) {
    ansx[[i]] <- xs[[i]]
    ansy[[i]] <- ys[[i]]
    ansz[[i]] <- zs[[i]]
  }
  
  sta <- n_dia_ms2bins + 1L
  end <- len - n_dia_ms2bins
  
  for (i in sta:end) {
    bf <- i - n_dia_ms2bins
    af <- i + n_dia_ms2bins
    rng <- bf:af
    # xbf <- .Internal(unlist(xs[bf:(i-1)], recursive = FALSE, use.names = FALSE))
    # xaf <- .Internal(unlist(xs[(i+1):af], recursive = FALSE, use.names = FALSE))
    # xcr <- xs[[i]]
    # ixbf <- index_mz(xbf, from, step)
    # ixaf <- index_mz(xaf, from, step)
    # ixcr <- index_mz(xcr, from, step)
    # oks_bf <- ixbf %fin% ixcr | (ixbf - 1L) %fin% ixcr | (ixbf + 1L) %fin% ixcr

    ansx[[i]] <- .Internal(unlist(xs[rng], recursive = FALSE, use.names = FALSE))
    ansy[[i]] <- .Internal(unlist(mapply(function (y, w) y * w, ys[rng], ws), 
                                  recursive = FALSE, use.names = FALSE))
    ansz[[i]] <- .Internal(unlist(zs[rng], recursive = FALSE, use.names = FALSE))
  }
  
  for (i in (end+1):len) {
    ansx[[i]] <- xs[[i]]
    ansy[[i]] <- ys[[i]]
    ansz[[i]] <- zs[[i]]
  }
  
  list(x = ansx, y = ansy, z = ansz)
}


#' Finds the positions of logical gates.
#' 
#' @param vals A logical vector.
#' 
#' @examples
#' library(mzion)
#' 
#' # starts at low and ends at low
#' # find_gates(c(100, 102, 104:108, 110, 112, 114:117, 119))
#' 
#' # low-high
#' # find_gates(c(100, 102, 104:108, 110, 112, 114:117))
#' 
#' # high-low
#' # find_gates(c(95:100, 102, 104:108, 110:111, 114:117, 119))
#' 
#' # high-high
#' # find_gates(c(95:100, 102, 104:108, 110, 112:113, 116:119))
#' 
#' # all-zeros (discrete)
#' # find_gates(c(6L, 12L, 18L, 164L))
#' 
#' # all-ones
#' # find_gates(1:5)
#' 
#' # up-width == 1L
#' # find_gates(c(143L, 159L, 310L, 311L, 316L))
#' 
#' # all discrete
#' # find_gates(c(143L, 159L, 310L, 316L))
#' 
#' # single TRUE
#' # find_gates(c(310L, 311L))
#' 
#' #' # single value
#' # find_gates(c(310L))
#' 
#' # find_gates(c(281, 326, 335, 336, 337, 437, 447, 448, 449, 450, 553, 554, 557))
find_gates <- function (vals)
{
  # all discrete
  if (is.null(edges <- find_gate_edges(vals)))
    return(NULL)
  
  ups <- edges[["ups"]]
  dns <- edges[["dns"]]
  
  ps <- mapply(function (x, y) x:y, ups, dns, SIMPLIFY = FALSE, USE.NAMES = FALSE)
  lens <- lengths(ps)
  oks <- lens > 2L
  
  if (any(oks)) {
    oks <- .Internal(which(oks))
    ps0 <- ps[-oks]
    ps1 <- ps[oks]
    lens1 <- lens[oks]
    
    for (i in seq_along(ps1)) {
      psi <- ps1[[i]]
      
      if ((li <- lens1[[i]]) %% 2L) {
        psi <- c(ps1[[i]], 0L)
        li <- li + 1L
      }
      
      fcts <- rep(1:(li/2L), each = 2L)
      ps1[[i]] <- split(psi, fcts)
    }
    
    ps1 <- .Internal(unlist(ps1, recursive = FALSE, use.names = FALSE))
    ps <- c(ps0, ps1)
    
    ord <- lapply(ps, `[[`, 1)
    ord <- .Internal(unlist(ord, recursive = FALSE, use.names = FALSE))
    ord <- order(ord)
    ps <- ps[ord]
  }
  
  ps
}


#' Helper to find the positions of logical gates.
#' 
#' @param vals A logical vector.
find_gate_edges <- function (vals)
{
  if (length(vals) <= 1L)
    return(NULL)
  
  vec <- diff(vals, 1L) == 1L
  lenv <- length(vec)
  
  if (vec[lenv]) {
    vec <- c(vec, FALSE)
    lenv <- lenv + 1L
  }
  
  # all discrete
  if (!any(vec)) 
    return(NULL)
  
  ds <- diff(vec)
  ups <- which(ds == 1L) + 1L
  dns <- which(ds == -1L) + 1L
  lenu <- length(ups)
  lend <- length(dns)
  
  if (lenu == lend) {
    if (ups[[1]] > dns[[1]]) {
      ups <- c(1L, ups)
      dns <- c(dns, lenv)
    }
  }
  else if (lenu < lend)
    ups <- c(1L, ups)
  else if (lenu > lend) # should not occur with ensured trailing FALSE
    dns <- c(dns, ups[lenu])
  
  list(ups = ups, dns = dns)
}


#' Traces LCMS peaks.
#'
#' For both moverzs and intensities.
#'
#' @param xs Vectors of moverzs at a given isolation center (\code{icenter}).
#'   Each entry corresponds to a full vector of MS1 or MS2.
#' @param ys Vectors of intensities.
#' @param zs Vectors of charge states.
#' @param temp_dir A temporary directory.
#' @param icenter The index of an isolation center.
#' @param ms_lev The level of MS.
#' @param from The starting value for mass binning.
#' @param step A step size for mass binning.
#' @param n_dia_scans The number of adjacent MS scans for constructing a peak
#'   profile and thus for determining the apex scan number of an moverz value
#'   along LC.
#' @param reord Logical; re-order data or not.
#' @param cleanup Logical; cleans up xs, ys and zs or not. Set the value to
#'   FALSE to maintain one-to-one correspondence between input (data frame) and
#'   the outputs. This will help, e.g., keep track of scan numbers in the input.
#' @param replace_ms1_by_apex Logical; if TRUE, fill all entries within a gate
#'   by its apex values.
#' @param direct_out Logical; if TRUE, return outputs directly.
#' @param filename A peaklist filename.
#' @param temp_dir A temp_dir to the filename.
traceLCMS <- function (xs, ys, zs, n_dia_scans = 4L, from = 115L, step = 8E-6, 
                       icenter = 1L, ms_lev = 2L, temp_dir = NULL, filename = NULL, 
                       reord = TRUE, cleanup = TRUE, replace_ms1_by_apex = FALSE, 
                       direct_out = FALSE)
{
  lens <- lengths(xs)
  
  if (reord) {
    ords <- lapply(xs, order)

    for (i in seq_along(xs)) {
      if (lens[[i]]) {
        ordi <- ords[[i]]
        xs[[i]] <- xs[[i]][ordi]
        ys[[i]] <- ys[[i]][ordi]
        zs[[i]] <- zs[[i]][ordi]
      }
    }
    rm(list = "ords", "ordi")
  }
  
  ## collapses MS data by the indexes of mass bins; 
  # matrix outputs; rows: scans; columns: masses at "x", intensities at "y" ...
  ans <- collapse_xyz(
    xs = xs, ys = ys, zs = zs, temp_dir = temp_dir, icenter = icenter, 
    ms_lev = ms_lev, lwr = from, step = step, cleanup = cleanup, 
    direct_out = direct_out)
  
  ansx <- ans[["x"]]
  ansy <- ans[["y"]]
  ansz <- ans[["z"]]
  rm(list = c("ans"))
  gc()
  
  ## traces MS data matrices across LC scans; rows: scans; columns: masses
  nrc <- dim(ansy)
  nr <- nrc[[1]]
  nc <- nrc[[2]]

  xout <- yout <- matrix(rep_len(NA_real_, nc * nr), ncol = nc)
  zout <- matrix(rep_len(NA_integer_, nc * nr), ncol = nc)
  ranges <- apexes <- ns <- vector("list", nc)
  
  if (replace_ms1_by_apex) {
    for (i in 1:nc) {
      gates <- find_lc_gates(ansy[, i], n_dia_scans = n_dia_scans)
      apexes[[i]] <- rows <- gates[["apex"]]
      ns[[i]] <- gates[["ns"]] # number of observing scans
      ranges[[i]] <- rngs <- gates[["ranges"]]
      
      for (j in seq_along(rows)) {
        rgj <- rngs[[j]]
        rwj <- rows[[j]]
        xout[rgj, i] <- ansx[rwj, i]
        yout[rgj, i] <- ansy[rwj, i]
        zout[rgj, i] <- ansz[rwj, i]
      }
    }
  }
  else {
    for (i in 1:nc) {
      gates <- find_lc_gates(ansy[, i], n_dia_scans = n_dia_scans)
      apexes[[i]] <- rows <- gates[["apex"]]
      ns[[i]] <- gates[["ns"]] # number of observing scans
      ranges[[i]] <- rngs <- gates[["ranges"]]

      xout[rows, i] <- ansx[rows, i]
      yout[rows, i] <- ansy[rows, i]
      zout[rows, i] <- ansz[rows, i]
    }
  }

  rm(list = c("ansx", "ansy", "ansz"))
  gc()
  
  list(x = xout, y = yout, z = zout, n = ns, p = apexes, range = ranges)
}


#' Collapse MS data.
#'
#' Similar to \link{collapse_mms1ints} with the addition of zs.
#'
#' Values of \code{xs} can be smaller than \code{lwr} since no ms2_mass cut-offs
#' (some z undetermined).
#'
#' @param xs Vectors of moverzs at a given isolation center (\code{icenter}).
#'   Each entry corresponds to a full vector of MS1 or MS2.
#' @param ys Vectors of intensities.
#' @param zs Vectors of charge states.
#' @param temp_dir A temporary directory.
#' @param icenter The index of an isolation center.
#' @param ms_lev The level of MS.
#' @param lwr A lower bound as the starting point in mass binning.
#' @param step A step size for mass binning.
#' @param cleanup Logical; cleans up xs, ys and zs or not. Set the value to
#'   FALSE to maintain one-to-one correspondence between input (data frame) and
#'   the outputs. This will help, e.g., keep track of scan numbers in the input.
#' @param direct_out Logical; if TRUE, return outputs directly.
#' @importFrom fastmatch %fin%
#' @return Matrices of moverzs, intensities and charge states. Columns: masses;
#'   rows: scans.
collapse_xyz <- function (xs = NULL, ys = NULL, zs = NULL, temp_dir = NULL, 
                          icenter = 1L, ms_lev = 2L, lwr = 115L, step = 1e-5, 
                          cleanup = TRUE, direct_out = FALSE)
{
  if (cleanup) {
    null_out <- list(x = NULL, y = NULL, z = NULL)
    
    # all xs are NULL
    if (!any(oksx <- lengths(xs) > 0L))
      return(null_out)
    
    oksx <- .Internal(which(oksx))
    xs <- xs[oksx]
    ys <- ys[oksx]
    zs <- zs[oksx]
    rm(list = "oksx")
    
    # remove zero intensities
    for (i in seq_along(oky <- lapply(ys, `>`, 0))) {
      oki <- .Internal(which(oky[[i]]))
      xs[[i]] <- xs[[i]][oki]
      ys[[i]] <- ys[[i]][oki]
      zs[[i]] <- zs[[i]][oki]
    }
    rm(list = "oky", "oki")
    
    # does this again after ys removals
    if (!any(oks <- lengths(xs) > 0L))
      return(null_out)
    
    oks <- .Internal(which(oks))
    xs <- xs[oks]
    ys <- ys[oks]
    zs <- zs[oks]
    rm(list = "oks")
  }

  ixs <- lapply(xs, index_mz, lwr, step)
  
  # remove duplicated ixs
  for (i in seq_along(ixs)) {
    ix <- ixs[[i]]
    oks <- .Internal(which(!duplicated(ix)))
    ixs[[i]] <- ix[oks]
    xs[[i]]  <- xs[[i]][oks]
    ys[[i]]  <- ys[[i]][oks]
    zs[[i]]  <- zs[[i]][oks]
  }
  rm(list = c("oks", "ix"))
  
  unv <- .Internal(unlist(ixs, recursive = FALSE, use.names = FALSE))
  unv <- sort(unique(unv))
  lenu <- length(unv)
  lenx <- length(xs)
  ups <- lapply(ixs, function (x) unv %in% x)
  
  xout <- mapcoll_xyz(vals = xs, ups = ups, lenx = lenx, lenu = lenu, 
                      temp_dir = temp_dir, icenter = icenter, ms_lev = ms_lev, 
                      type = "xs", direct_out = direct_out)
  rm(list = "xs")
  gc()
  
  yout <- mapcoll_xyz(vals = ys, ups = ups, lenx = lenx, lenu = lenu, 
                      temp_dir = temp_dir, icenter = icenter, ms_lev = ms_lev, 
                      type = "ys", direct_out = direct_out)
  rm(list = "ys")
  gc()
  
  zout <- mapcoll_xyz(vals = zs, ups = ups, lenx = lenx, lenu = lenu, 
                      temp_dir = temp_dir, icenter = icenter, ms_lev = ms_lev, 
                      type = "zs", direct_out = direct_out)
  rm(list = c("zs", "ups"))
  gc()
  
  if (!direct_out) {
    x_nm <- paste0("xs", ms_lev, "_diauniv_", icenter, ".rds")
    y_nm <- paste0("ys", ms_lev, "_diauniv_", icenter, ".rds")
    z_nm <- paste0("zs", ms_lev, "_diauniv_", icenter, ".rds")
    xout <- qs::qread(file.path(temp_dir, x_nm))
    yout <- qs::qread(file.path(temp_dir, y_nm))
    zout <- qs::qread(file.path(temp_dir, z_nm))
  }

  ### collapses adjacent entries
  ps <- find_gates(unv)
  lenp <- length(ps)
  
  # all discrete values
  if (is.null(ps))
    return(list(x = xout, y = yout, z = zout))

  ps2 <- lapply(ps, `[[`, 2)
  ps2 <- .Internal(unlist(ps2, recursive = FALSE, use.names = FALSE))
  
  for (i in 1:lenp) {
    c12 <- ps[[i]]
    c2 <- c12[[2]]
    
    # with values in both columns, simply overwrite: 1 <- 2; 
    # c2 can be 0
    if (!c2)
      next
    
    c1 <- c12[[1]]
    oks <- .Internal(which(!is.na(xout[, c2])))
    xout[oks, c1] <- xout[oks, c2]
    yout[oks, c1] <- yout[oks, c2]
    zout[oks, c1] <- zout[oks, c2]
  }
  
  xout <- xout[, -ps2, drop = FALSE]
  yout <- yout[, -ps2, drop = FALSE]
  zout <- zout[, -ps2, drop = FALSE]
  
  list(x = xout, y = yout, z = zout)
}


#' Maps data onto the universe.
#'
#' For RAM efficiency.
#'
#' @param vals Data in one of moverzs, intensities or charge states.
#' @param ups Positions of \code{vals} in universe. Should be the same for among
#'   moverzs, intensities and charge states.
#' @param lenx The length of \code{vals}.
#' @param lenu The number of entries in the universe.
#' @param temp_dir A temporary directory.
#' @param icenter The index of an isolation center.
#' @param ms_lev The level of MS.
#' @param type The type of data in one of xs, ys and zs.
#' @param direct_out Logical; if TRUE, return outputs directly.
#' @return A matrix where rows correspond to \code{vals} and columns to
#'   \code{ups}.
mapcoll_xyz <- function (vals, ups, lenx, lenu, temp_dir, icenter = 1L, 
                         ms_lev = 2L, type = "xs", direct_out = FALSE)
{
  if (!length(vals))
    return(NULL)
  
  out <- if (type == "zs")
    rep_len(list(rep_len(NA_integer_, lenu)), lenx)
  else if (type %in% c("xs", "ys"))
    rep_len(list(rep_len(NA_real_, lenu)), lenx)
  else
    rep_len(list(rep_len(NA_real_, lenu)), lenx)
  
  for (i in 1:lenx) {
    cols <- ups[[i]]
    out[[i]][cols] <- vals[[i]]
  }
  
  out <- do.call(rbind, out)
  
  if (direct_out)
    return(out)
  
  out_name <- paste0(type, ms_lev, "_diauniv_", icenter, ".rds")
  qs::qsave(out, file.path(temp_dir, out_name), preset = "fast")
  
  invisible(NULL)
}


#' Finds the gates of retention times.
#'
#' @param ys A vector of intensity value for the same (approximate) mass along
#'   LC.
#' @param n_dia_scans The number of adjacent MS scans for constructing a peak
#'   profile and thus for determining the apex scan number of an moverz value
#'   along LC.
#' @examples
#' mzion:::find_lc_gates(c(10,0,0,0,11,15,15,0,0,12,0,10,0,0,10), 2)
#' mzion:::find_lc_gates(c(rep(0, 7), 100, 101, rep(0, 2), seq(200, 500, 100), rep(0, 1), 20, 50))
#' mzion:::find_lc_gates(c(rep(0, 7), 100, 101, rep(0, 2), seq(200, 500, 100), rep(0, 4), 20, 50))
#'
#' # all discrete
#' mzion:::find_lc_gates(c(rep(0, 5), 100, rep(0, 6), 200, rep(0, 4), 50))
#' @return Scan indexes of LC peaks.
find_lc_gates <- function (ys, n_dia_scans = 4L)
{
  # should not occur
  # if (n_dia_scans <= 0L) return(.Internal(which(ys > 0)))
  
  ys <- fill_lc_gaps(ys, n_dia_scans)
  xs <- .Internal(which(ys > 0))
  nx <- length(xs)
  
  # a case of one one-hit wonder across LC
  if (nx == 1L)
    return(list(apex = xs, ns = 1L, ranges = xs))
  
  ysub <- ys[xs]
  edges <- find_gate_edges(xs)
  
  # all discrete one-hit wonders
  if (is.null(edges))
    return(list(apex = xs, ns = rep_len(1L, nx), ranges = xs))
  
  ups <- edges[["ups"]]
  dns <- edges[["dns"]]
  rm(list = "edges")
  
  xus <- xs[ups]
  xds <- xs[dns]
  widths <- xds - xus + 1L
  
  len <- length(ups)
  ps <- ranges <- vector("list", len)
  
  for (i in 1:len) {
    ui <- ups[[i]]
    di <- dns[[i]]
    ps[[i]] <- ui:di
    ranges[[i]] <- xs[ui:di]
  }

  # ps <- mapply(function (x, y) x:y, ups, dns, SIMPLIFY = FALSE, USE.NAMES = FALSE)
  xs1 <- xs[-.Internal(unlist(ps, recursive = FALSE, use.names = TRUE))]
  
  nps <- length(ps)
  xps <- rep_len(NA_integer_, nps)
  # yps <- rep_len(NA_real_, nps)
  
  for (i in seq_len(nps)) {
    pi <- ps[[i]]
    xi <- xs[pi]
    yi <- ysub[pi]
    mi <- which.max(yi)
    xps[[i]] <- xi[[1]] + mi - 1L
    # yps[[i]] <- yi[[mi]]
  }
  
  if (FALSE) {
    if (nps > 1L) {
      for (i in 2:nps) {
        ix <- i - 1
        
        if ((xus[[i]] - xds[[ix]]) <= n_dia_scans) {
          if (yps[[i]] >= yps[[ix]])
            xus[[ix]] <- NA_integer_
          else
            xus[[i]] <- NA_integer_
        }
      }
    }
    
    oks <- !is.na(xus)
    xps <- xps[oks]
  }
  
  list(apex = c(xs1, xps), ns = c(rep_len(1L, length(xs1)), widths), 
       ranges = c(xs1, ranges))
}


#' Fills LC gaps.
#'
#' @param ys A vector of intensity values.
#' @param n_dia_scans The number of adjacent MS scans for constructing a peak
#'   profile and thus for determining the apex scan number of an moverz value
#'   along LC.
#' @examples
#' ys <- c(10,0,0,0,11,0,15,0,0,12,0,10,0,0,10)
#' mzion:::fill_lc_gaps(ys, 3)
#' mzion:::fill_lc_gaps(ys, 2)
#'
#' ys <- c(10,0,0,0,11,15,15,0,0,12,0,10,0,0,10)
#' mzion:::fill_lc_gaps(ys, 3)
#' mzion:::fill_lc_gaps(ys, 2)
fill_lc_gaps <- function (ys, n_dia_scans = 4L)
{
  if (n_dia_scans <= 1L)
    return(ys)
  
  xs <- .Internal(which(ys > 0))
  ds <- diff(xs)
  oks <- ds <= n_dia_scans & ds > 1L
  ps <- .Internal(which(oks))
  ng <- length(ps)
  
  if (!ng)
    return(ys)
  
  for (i in seq_along(ps)) {
    p <- ps[i]
    rng <- (xs[p]+1L):(xs[p+1]-1L)
    ys[rng] <- 1.0
  }
  
  ys
}


#' Collapse MS1 intensities.
#'
#' Allow adjacent values in unv and later collapse adjacent columns/values.
#'
#' @param xs Vectors of SORTED m-over-z values.
#' @param ys Vectors of intensity values corresponding to xs.
#' @param lwr The lower mass limit.
#' @param step The bin size in converting numeric m-over-z values to integers.
#' @param reord Logical; re-order data or not.
#' @param coll Logical; to further collapse results or not.
#' @param cleanup Logical; to perform data row clean-ups or not. Rows may drop
#'   at \code{cleanup = TRUE}.
#' @param add_colnames Logical; if TRUE, add the indexes of mass bins to the
#'   column names of \code{matx}.
#' @importFrom fastmatch %fin%
#' @examples
#' # Twos adjacent bins of xs: 392.1796, 392.1845
#' # xs longer than the universe
#' xs <- list(c(391.1883,391.2848,391.6627,391.6995,392.1646,392.1796,392.1845,
#'            392.2030,392.2887,392.6641,392.7812,393.0833,393.2975))
#' ys <- list(c(12827.41,337002.19,617819.69,18045.10,205851.53,15194.98,11318.61,
#'              12970.02,118604.48,75726.89,11676.51,23723.18,55749.93))
#' mzion:::collapse_mms1ints(xs, ys, lwr = 389.6529)
#'
#' xs <- list(c(400.6596,401.7076,402.1813,402.1944,402.1969,402.2094,402.5438,402.7112,403.1812,404.1777),
#'            c(400.6599,401.7075,402.1954,402.1975,402.7112,403.1822,404.2777))
#' ys <- list(c(24003.98,53431.96,110619.26,10988.55,12291.00,140045.06,67601.16,11413.04,21651.61,16686.06),
#'            c(10000.1,40000.1,20000.1,50000.1,2500.2,5000.1,30000.1))
#' mzion:::collapse_mms1ints(xs, ys, lwr = 400.1994)
#'
#' xs <- ys <- vector("list", 13L)
#' xs[[7]] <- 954.607849; xs[[8]] <- 954.630249; xs[[10]] <- 954.622925
#' ys[[7]] <- 15706.2627; ys[[8]] <- 19803.5879; ys[[10]] <- 31178.9648
#' mzion:::collapse_mms1ints(xs, ys, lwr = 951.089731)
collapse_mms1ints <- function (xs = NULL, ys = NULL, lwr = 115L, step = 1e-5, 
                               reord = FALSE, coll = TRUE, cleanup = TRUE, 
                               add_colnames = FALSE)
{
  ### 
  # the utility is often called heavily;
  # DO NOT gc() that will slow things down
  ### 
  
  null_out <- if (coll)
    list(x = NULL, y = NULL, n = NULL)
  else
    list(x = NULL, y = NULL)
  
  if (cleanup) {
    # 1. all xs are NULL
    if (!any(oks <- lengths(xs) > 0L))
      return(null_out)
    
    oks <- .Internal(which(oks))
    xs <- xs[oks]
    ys <- ys[oks]
    
    # 2. remove zero intensities
    oky <- lapply(ys, `>`, 0)
    
    for (i in seq_along(xs)) {
      oki <- .Internal(which(oky[[i]]))
      xs[[i]] <- xs[[i]][oki]
      ys[[i]] <- ys[[i]][oki]
    }
    
    # 2.1 checks again
    if (!any(oks <- lengths(xs) > 0L))
      return(null_out)
    
    oks <- .Internal(which(oks))
    xs <- xs[oks]
    ys <- ys[oks]
  }
  
  if (reord) {
    lens <- lengths(xs)
    
    for (i in seq_along(xs)) {
      xi <- xs[[i]]
      
      if (lens[[i]]) {
        ord <- order(xi)
        xs[[i]] <- xi[ord]
        ys[[i]] <- ys[[i]][ord]
      }
    }
    # rm(list = c("xi", "ord", "lens"))
  }

  ixs <- lapply(xs, index_mz, lwr, step)
  
  # 3. remove duplicated ixs
  for (i in seq_along(ixs)) {
    ix <- ixs[[i]]
    x <- xs[[i]]
    y <- ys[[i]]
    oks <- .Internal(which(!duplicated(ix)))
    ixs[[i]] <- ix[oks]
    xs[[i]]  <- x[oks]
    ys[[i]]  <- y[oks]
  }
  # rm(list = c("x", "y", "ix", "oks"))
  
  ## maps ixs vectors to unv (presence or absence)
  unv <- .Internal(unlist(ixs, recursive = FALSE, use.names = FALSE))
  unv <- sort(unique(unv))
  lenu <- length(unv)
  lenx <- length(xs)
  ups <- lapply(ixs, function (x) unv %fin% x)
  
  # note one-to-one correspondence between ixs and xs
  xmat <- mapcoll_xyz(vals = xs, ups = ups, lenx = lenx, lenu = lenu, 
                      direct_out = TRUE)
  # rm(list = "xs")

  ymat <- mapcoll_xyz(vals = ys, ups = ups, lenx = lenx, lenu = lenu, 
                      direct_out = TRUE)
  # rm(list = c("ys", "ups"))
  
  if (add_colnames)
    colnames(xmat) <- colnames(ymat) <- unv

  ## collapses adjacent entries
  ps <- find_gates(unv)
  lenp <- length(ps)
  
  # all discrete values
  if (is.null(ps)) {
    if (coll)
      return(calc_ms1xys(xmat, ymat))
    else
      return(list(x = xmat, y = ymat))
  }
  
  ps2 <- vector("integer", lenp) # matrix columns to be removed

  # collapses matrix columns with +/-1 in bin indexes
  for (i in 1:lenp) {
    c12 <- ps[[i]]
    c2 <- c12[[2]]
    
    # with values in both columns, simply overwrite: 1 <- 2; 
    # c2 can be 0
    if (!c2)
      next
    
    # with values in both columns but simply overwrite: 1 <- 2
    ps2[[i]] <- c2
    c1 <- c12[1]
    rows <- .Internal(which(!is.na(xmat[, c2])))
    xmat[rows, c1] <- xmat[rows, c2]
    ymat[rows, c1] <- ymat[rows, c2]
  }

  # note `-ps2` ok in that at least one ps2 is not 0
  # identical(xmat[, -c(0, 2:3), drop = FALSE], xmat[, -c(2:3), drop = FALSE])
  # !identical(xmat[, 0, drop = FALSE], xmat)
  xmat <- xmat[, -ps2, drop = FALSE]
  ymat <- ymat[, -ps2, drop = FALSE]
  
  if (coll)
    calc_ms1xys(xmat, ymat)
  else
    list(x = xmat, y = ymat)
}


#' Makes MS1 matrices of moverzs and intensities
#'
#' @param matx A matrix of moverzs onto the data universe.
#' @param maty Vectors of intensities onto the data universe.
#' @return A list of x: the weighted means of moverzs; y: the means of
#'   intensities; n: the numbers of observations.
calc_ms1xys <- function (matx, maty)
{
  ysums <- colSums(maty, na.rm = TRUE)
  xmeans <- colSums(matx * maty, na.rm = TRUE)/ysums
  ns <- colSums(!is.na(maty), na.rm = TRUE)
  # use tallied ysums, not ysums/ns, for deisotoping
  list(x = xmeans, y = ysums, n = ns)
}


#' Finds mDDA precursors.
#'
#' Averages of multiple MS1 scans.
#'
#' @param msx_moverzs Vectors of bracketing (e.g. +/-6 scans) full-spectrum
#'   moverzs.
#' @param msx_ints Vectors of bracketing full-spectrum intensities.
#' @param iso_ctr Vectors of isolation centers (e.g. top-12 scans) for MS2.
#' @param iso_lwr Vectors of isolation lowers for MS2.
#' @param ppm Mass error tolerance.
#' @param step A step size.
#' @param maxn_precurs Maximum number of precursors for consideration.
#' @param max_ms1_charge Maximum charge state of precursors for consideration.
#' @param width The width of an MS1 window. A wide window is used for containing
#'   isotope envelops.
#' @param n_fwd Forward looking up to \code{n_fwd} mass entries.
#' @param use_defpeaks Use default peak info or not.
#' @inheritParams matchMS
#' @return A list. x: monoisotopic moverzs (weighted mean statistics); y:
#'   intensities (mean); z: charge states.
find_mdda_mms1s <- function (msx_moverzs = NULL, msx_ints = NULL, 
                             iso_ctr = NULL, iso_lwr = NULL, 
                             ppm = 10L, maxn_precurs = 5L, max_ms1_charge = 4L, 
                             n_fwd = 20L, grad_isotope = 1.6, fct_iso2 = 3.0, 
                             use_defpeaks = FALSE, width = 2.01, step = ppm/1e6)
{
  # for all (6+1+6) MS1 frames subset by one MS2 iso-window
  ansx1 <- ansy1 <- vector("list", len1 <- length(msx_moverzs))
  # for all MS2s from averaged (6+1+6 -> 1) MS1s 
  ansn2 <- ansx2 <- ansy2 <- vector("list", len2 <- length(iso_ctr))
  
  # go through MS2 entries
  for (i in 1:len2) {
    m2  <- iso_ctr[[i]]
    lwr <- m2 - width
    upr <- m2 + width
    
    # gather e.g. +/-6 MS1s
    for (j in 1:len1) {
      x1s <- msx_moverzs[[j]]
      y1s <- msx_ints[[j]]
      oks <- .Internal(which(x1s > lwr & x1s < upr))
      ansx1[[j]] <- x1s[oks]
      ansy1[[j]] <- y1s[oks]
    }
    
    # collapsed MS1s
    # assume xs are already ordered from low to high
    # often coll == cleanup
    ans <- collapse_mms1ints(xs = ansx1, ys = ansy1, lwr = lwr, step = step, 
                             reord = FALSE, coll = TRUE, cleanup = TRUE)
    ansx <- ans[["x"]] # the weighted-mean of precursor moverzs
    ansy <- ans[["y"]] # the mean of precursor intensities
    ansn <- ans[["n"]] # the numbers of precursor observations

    # assign precursor info to the corresponding MS2 entry
    if (is.null(ansx))
      next
    
    ansx2[[i]] <- ansx
    ansy2[[i]] <- ansy
    ansn2[[i]] <- ansn
  }
  rm(list = c("ansx1", "ansy1", "ansx", "ansy", "ansn", "ans", "len1", 
              "m2", "lwr", "upr", "x1s", "y1s", "oks"))

  ## Deisotopes precursors for each MS2 scan
  # ansx2[[i]] can be NULL (no precursor found in the isolation window)
  mics <- mapply(
    find_ms1stat, 
    moverzs = ansx2, msxints = ansy2, n_ms1s = ansn2, center = iso_ctr, 
    MoreArgs = list(
      exclude_reporter_region = FALSE, 
      ppm = ppm, ms_lev = 1L, maxn_feats = maxn_precurs, 
      max_charge = max_ms1_charge, n_fwd = n_fwd, offset_upr = 30L, 
      offset_lwr = 30L, order_mz = FALSE, grad_isotope = grad_isotope, 
      fct_iso2 = fct_iso2, use_defpeaks = use_defpeaks
    ), SIMPLIFY = FALSE, USE.NAMES = FALSE)

  # (2) subset by isolation window
  # ( `width = 2.01` contains isotope envelope and now need subsetting)
  xs <- ys <- zs <- vector("list", len2)
  
  for (i in seq_len(len2)) {
    mic <- mics[[i]]
    masses <- mic[["masses"]]
    intensities <- mic[["intensities"]]
    charges <- mic[["charges"]]
    
    m <- iso_ctr[[i]]
    w <- iso_lwr[[i]]
    oks <- masses > m - w & masses < m + w
    oks <- .Internal(which(oks))
    
    # accepts all
    if (!length(oks))
      oks <- seq_along(masses)
    
    xs[[i]] <- masses[oks]
    ys[[i]] <- intensities[oks]
    zs[[i]] <- charges[oks]
  }
  # impurities <- lapply(ys, function (x) x/sum(x))
  
  list(x = xs, y = ys, z = zs)
}


#' Finds precursors using MS2 data.
#' 
#' For absolutely no precursor identification based on MS1 data.
#' 
#' @param charges MS2 charges.
#' @param iso_lwr The lower width of an isolation window.
#' @param iso_upr The upper width of an isolation window.
#' @inheritParams find_ms1stat
find_ms1byms2 <- function (moverzs = NULL, msxints = NULL, charges = NULL, 
                           center, iso_lwr, iso_upr)
{
  na_out <- list(ms1_moverzs = NA_real_, ms1_masses = NA_real_, 
                 ms1_charges = NA_integer_, ms1_ints = NA_real_)
  
  if (!(len_ms <- length(moverzs)))
    return(na_out)
  
  oks <- (moverzs >= center - iso_lwr) & (moverzs <= center + iso_upr)
  oks <- .Internal(which(oks))
  moverzs <- moverzs[oks]
  
  if (!(len_ms <- length(moverzs)))
    return(na_out)
  
  msxints <- msxints[oks]
  charges <- charges[oks]
  
  charges[is.null(charges)] <- NA_integer_
  charges[is.na(charges)] <- 2L # arbitrary
  masses <- (moverzs - 1.00727647) * charges
  
  if (len_ms == 1L)
    return(list(ms1_moverzs = moverzs, ms1_masses = masses, 
                ms1_charges = charges, ms1_ints = msxints))
  
  okc <- !is.na(charges)
  okc <- .Internal(which(okc))
  charges <- charges[okc]
  
  if (!(len_ms <- length(charges)))
    return(na_out)
  
  moverzs <- moverzs[okc]
  msxints <- msxints[okc]
  masses <- masses[okc]
  
  if (len_ms == 1L)
    return(list(ms1_moverzs = moverzs, ms1_masses = masses, 
                ms1_charges = charges, ms1_ints = msxints))
  
  idx <- .Internal(which.max(msxints))
  moverzs <- moverzs[idx]
  charges <- charges[idx]
  msxints <- msxints[idx]
  masses <- masses[idx]
  
  list(ms1_moverzs = moverzs, ms1_masses = masses, 
       ms1_charges = charges, ms1_ints = msxints)
}


#' Makes an mzTab file.
#'
#' With \code{mzion} searches and \code{proteoQ} post-processing.
#'
#' @param mzion_path The parent parthwhere \code{mzion} search was performed.
#' @param proteoq_path A parent path where the \code{proteoQ} post-processing
#'   was performed.
#' @import dplyr
make_mztab <- function (mzion_path = stop("Provide the path.", call. = FALSE), 
                        proteoq_path = mzion_path) 
{
  ## MTD
  load(file.path(mzion_path, "Calls", "matchMS.rda"))

  # Header
  hdrs <- local({
    nms <- c("mzTab-version", "mzTab-mode", "mzTab-type", "title", "description") 
    vals <- c("1", "Complete", "Identification", "null", "null")
    data.frame(nm = nms, val = vals)
  })

  # Instrument and MGF format
  ans_mgfs <- local({
    mgf_path <- call_pars$mgf_path
    
    fi_fmt <- file.path(mgf_path, "info_format.rds")
    
    if (file.exists(fi_fmt)) {
      info_mgfs <- qs::qread(fi_fmt)
    }
    else {
      # the only non-MGF is MSConvert-mzML
      info_mgfs <- list(data_format = "Thermo-RAW", mgf_format = "MSconvert")
    }

    data_format <- info_mgfs$data_format
    val_data_format <- paste0("[MS, , ", data_format, ", ]")
    mgf_format <- info_mgfs$mgf_format
    val_mgf_format <- paste0("[MS, , ", mgf_format, ", ]")
    
    query_files <- list.files(mgf_path, pattern = "^mgf_queries_.*\\.rds", 
                              full.names = TRUE)
    mgf_queries <- lapply(query_files, qs::qread) |>
      dplyr::bind_rows()
    raw_files <- names(qs::qread(file.path(mgf_path, "raw_indexes.rds")))
    
    ans_mgfs <- vector("list", length(raw_files))
    
    for (i in seq_along(ans_mgfs)) {
      nm_format <- paste0("ms_run[", i, "]-format")
      nm_location <- paste0("ms_run[", i, "]-location")
      nm_id_format <- paste0("ms_run[", i, "]-id_format")
      val_location <- raw_files[i]
      nms <- c(nm_format, nm_location, nm_id_format)
      vals <- c(val_data_format, val_location, val_mgf_format)
      
      ans_mgfs[[i]] <- data.frame(nm = nms, val = vals)
    }
    
    data.frame(do.call(rbind, ans_mgfs))
  })
  
  # Software settings
  load(file.path(mzion_path, "Calls", "mzion.rda"))
  pkgs <- devtools::session_info()
  mzion_ver <- pkgs$packages["mzion", "loadedversion"]

  ans_software_1 <- local({
    ln_software_1 <- data.frame(nm = "software[1]", 
                                val = paste0("[MS, MS:0000000, mzion,", 
                                             mzion_ver, "]"))
    
    idxes <- which(unlist(lapply(call_pars, is.null)))
    call_pars[idxes] <- "NULL"
    rm(list = "idxes")
    
    fixedmods <- call_pars$fixedmods
    varmods <- call_pars$varmods
    fixedmods <- lapply(fixedmods, mzion::find_unimod)
    varmods <- lapply(varmods, mzion::find_unimod)
    
    call_pars <- lapply(call_pars, paste, collapse = ", ")
    call_pars <- data.frame(do.call(rbind, call_pars))
    
    vals <- mapply(paste, rownames(call_pars), call_pars[, 1], sep = "=", 
                   USE.NAMES = FALSE)
    nms <- rep("software[1]-setting", length(call_pars))
    ans_call_pars <- data.frame(nm = nms, val = vals)

    ans_fixedmods <- local({
      ans_fixedmods <- vector("list", length(fixedmods))
      
      for (i in seq_along(fixedmods)) {
        fixedmod <- fixedmods[[i]]
        title <- fixedmod$title
        monomass <- fixedmod$monomass
        site <- fixedmod$position_site
        position <- names(site)
        
        nm_t <- paste0("fixedmods[", i, "]")
        nm_p <- paste0(nm_t, "-position")
        nm_s <- paste0(nm_t, "-site")
        nms <- c(nm_t, nm_p, nm_s)
        
        vals <- c(paste0("[CHEMMOD, CHEMMOD:", monomass, ", ", title, ",]"), 
                  position, unname(site))
        
        ans_fixedmods[[i]] <- data.frame(nm = nms, val = vals)
      }
      
      data.frame(do.call(rbind, ans_fixedmods))
    })
    
    ans_varmods <- local({
      ans_varmods <- vector("list", length(varmods))
      
      for (i in seq_along(varmods)) {
        varmod <- varmods[[i]]
        title <- varmod$title
        monomass <- varmod$monomass
        site <- varmod$position_site
        position <- names(site)

        nm_t <- paste0("varmods[", i, "]")
        nm_p <- paste0(nm_t, "-position")
        nm_s <- paste0(nm_t, "-site")
        nms <- c(nm_t, nm_p, nm_s)

        vals <- c(paste0("[CHEMMOD, CHEMMOD:", monomass, ", ", title, ",]"), 
                  position, unname(site))
        
        ans_varmods[[i]] <- data.frame(nm = nms, val = vals)
      }
      
      data.frame(do.call(rbind, ans_varmods))
    })
    
    do.call(rbind, list(ln_software_1, ans_call_pars, 
                        ans_fixedmods, ans_varmods))
  })
  
  mtd <- do.call(rbind, list(hdrs, ans_mgfs, ans_software_1))
  mtd <- cbind(field = "MTD", mtd)

  ## Proteins
  df_prots <- readr::read_tsv(file.path(proteoq_path, "Protein", "Protein.txt"), 
                              show_col_types = FALSE) 

  df_peps <- readr::read_tsv(file.path(proteoq_path, "Peptide", "Peptide.txt"), 
                             show_col_types = FALSE) 

  df_shared_prot_accs <- local({
    df <- unique(df_peps[, c("prot_acc", "shared_prot_accs")]) |> 
      dplyr::mutate(len = stringr::str_count(shared_prot_accs, ",")) |> 
      dplyr::arrange(prot_acc, -len) |> 
      dplyr::group_by(prot_acc) |> 
      dplyr::mutate(group_count = dplyr::n())
    
    df_1 <- df |> 
      dplyr::filter(group_count == 1L) |> 
      dplyr::mutate(shared_prot_accs = "null")
    
    df_n <- df |> 
      dplyr::filter(group_count > 1L) |> 
      dplyr::filter(row_number() == 1L)
    
    dplyr::bind_rows(df_1, df_n) |> 
      dplyr::select(-len, -group_count)
  })

  cols_prt <- c(
    "PRH", "accession", "description", "taxid", "species", "database", 
    "database_version", "search_engine", "best_search_engine_score[1]", 
    "ambiguity_members", "modifications", "protein_coverage", 
    "search_engine_score[1]_ms_run[1]", 
    "num_psms_ms_run[1]", "num_psms_unique_ms_run[1]", 
    "num_peptides_distinct_ms_run[1]", "num_peptides_unique_ms_run[1]",
    "opt_global_mass",
    "reliability"
  )

  prt <- matrix(ncol = length(cols_prt), nrow = nrow(df_prots)) |> 
    data.frame(check.names = FALSE) |> 
    setNames(cols_prt)
  
  for (i in seq_along(prt)) 
    prt[[i]] <- "null"

  prt <- prt |> 
    dplyr::mutate(PRH = "PRT", 
                  accession = df_prots$prot_acc, 
                  description = df_prots$prot_desc, 
                  taxid = "null", 
                  species = df_prots$species, 
                  database = "null", 
                  database_version = "null", 
                  search_engine = "mzion", 
                  "best_search_engine_score[1]" = df_prots$prot_es, 
                  ) |> 
    dplyr::left_join(df_shared_prot_accs, by = c("accession" = "prot_acc")) |> 
    dplyr::mutate(ambiguity_members = shared_prot_accs) |> 
    dplyr::select(-shared_prot_accs)
  
  prt <- prt |> 
    dplyr::mutate(modifications = "null") |> 
    dplyr::left_join(df_prots[, c("prot_acc", "prot_cover")], 
                     by = c("accession" = "prot_acc")) |> 
    dplyr::mutate(protein_coverage = prot_cover) |> 
    dplyr::select(-prot_cover)
  
  prt <- prt |> 
    dplyr::left_join(df_prots[, c("prot_acc", "prot_mass")], 
                     by = c("accession" = "prot_acc")) |> 
    dplyr::mutate(opt_global_mass = prot_mass) |> 
    dplyr::select(-prot_mass)
  
  prt <- prt |> 
    dplyr::mutate(reliability = 1L)
  
  prt <- prt |> 
    dplyr::left_join(df_prots[, c("prot_acc", "prot_n_psm", "prot_n_uniqpsm", 
                              "prot_n_pep", "prot_n_uniqpep")], 
                     by = c("accession" = "prot_acc")) |> 
    dplyr::mutate("num_psms_distinct_ms_run[1]" = prot_n_psm, 
                  "num_psms_unique_ms_run[1]" = prot_n_uniqpsm, 
                  "num_peptides_distinct_ms_run[1]" = prot_n_pep, 
                  "num_peptides_unique_ms_run[1]" = prot_n_uniqpep) |> 
    dplyr::select(-c("prot_n_psm", "prot_n_uniqpsm", 
                     "prot_n_pep", "prot_n_uniqpep"))
  
  prt <- local({
    df <- df_prots[, grepl("^I[0-9]+", names(df_prots))]
    colnames(df) <- paste0("protein_abundance_study_variable[", 1:ncol(df), "]")
    df <- data.frame(cbind(prot_acc = df_prots$prot_acc, df), check.names = FALSE)
    dplyr::left_join(prt, df, by = c("accession" = "prot_acc"))
  })
  
  ## Peptides
  cols_pep <- c(
    "PEH", "sequence", "accession", "unique", "database", "database_version", 
    "search_engine", "best_search_engine_score[1]", 
    "modifications", "retention_time", "charge", "mass_to_charge",
    # "num_psms_ms_run[1]", "num_psms_unique_ms_run[1]", 
    "opt_global_mass", "opt_global_missed_cleavages",
    "reliability"
  )
  
  pep <- matrix(ncol = length(cols_pep), nrow = nrow(df_peps)) |> 
    data.frame(check.names = FALSE) |> 
    setNames(cols_pep)
  
  for (i in seq_along(pep)) 
    pep[[i]] <- "null"
  
  df_peps$sequence <- if ("pep_seq" %in% names(df_peps)) 
    df_peps$pep_seq
  else if ("pep_seq_mod" %in% names(df_peps))
    df_peps$pep_seq_mod
  
  pep <- pep |> 
    dplyr::mutate(PEH = "PEP", 
                  sequence = df_peps$sequence,
                  accession = df_peps$prot_acc, 
                  unique = df_peps$pep_isunique, 
                  database = "null", 
                  database_version = "null", 
                  search_engine = "mzion", 
                  "best_search_engine_score[1]" = df_peps$pep_score, 
                  modifications = df_peps$pep_seq_mod, 

                  opt_global_missed_cleavages = df_peps$pep_miss, 
                  reliability = 1L, )
  
  pep <- local({
    df <- df_peps[, grepl("^I[0-9]+", names(df_peps))]
    colnames(df) <- paste0("peptide_abundance_study_variable[", 1:ncol(df), "]")
    data.frame(cbind(pep, df), check.names = FALSE)
  })
  
  ## PSMs
  psm_files <- list.files(path = file.path(proteoq_path, "PSM"),
                          pattern = "TMTset[0-9]+_LCMSinj[0-9]+_PSM_N\\.txt$",
                          all.files = TRUE)

  df_psms <- lapply(psm_files, 
                    function (x) readr::read_tsv(file.path(proteoq_path, "PSM", x), 
                                                 show_col_types = FALSE)) |> 
    dplyr::bind_rows()

  cols_psm <- c(
    "PSH", "sequence", "PSM_ID", "accession", "unique", "database", "database_version", 
    "search_engine", "best_search_engine_score[1]", "modifications", "retention_time", 
    "charge", "exp_mass_to_charge", "calc_molecular_weight", "opt_global_mass", 
    "opt_global_missed_cleavages", "opt_global_spectrum_file", 
    "opt_global_scan_number", "pre", "post", "start", "end",
    "reliability")

  local({
    # redundancy kept at "prot_acc" and "pep_ivmod"
    uniq_id <- c("raw_file", "pep_scan_num", "prot_acc", "pep_ivmod")
  })

  psm <- matrix(ncol = length(cols_psm), nrow = nrow(df_psms)) |> 
    data.frame(check.names = FALSE) |> 
    setNames(cols_psm)
  
  for (i in seq_along(psm)) 
    psm[[i]] <- "null"

  psm <- psm |> 
    dplyr::mutate(PSH = "PSM", 
                  sequence = df_psms$pep_seq,
                  # PSM_ID = seq_len(nrow(df_psms)), 
                  accession = df_psms$prot_acc, 
                  unique = df_psms$pep_isunique, 
                  database = "null", 
                  database_version = "null", 
                  search_engine = "mzion", 
                  "best_search_engine_score[1]" = df_psms$pep_score, 
                  modifications = df_psms$pep_vmod, 
                  retention_time = df_psms$pep_ret_range, 
                  charge = df_psms$pep_exp_z, 
                  exp_mass_to_charge = df_psms$pep_exp_mz, 
                  calc_molecular_weight = df_psms$pep_calc_mr, 
                  opt_global_mass = df_psms$pep_exp_mr,
                  opt_global_missed_cleavages = df_psms$pep_miss, 
                  opt_global_spectrum_file = df_psms$raw_file, 
                  opt_global_scan_number = df_psms$pep_scan_num, 
                  pre = df_psms$pep_res_before,
                  post = df_psms$pep_res_after,
                  start = df_psms$pep_start,
                  end = df_psms$pep_end,
                  reliability = 1L, ) 

  psm <- local({
    df <- df_psms[, grepl("^I[0-9]+", names(df_psms))]
    colnames(df) <- paste0("peptide_abundance_study_variable[", 1:ncol(df), "]")
    data.frame(cbind(psm, df), check.names = FALSE)
  })
  
  ## Outputs
  lines_mtd <- capture.output(write.table(mtd, stdout(), sep = "\t", quote = FALSE, 
                                          row.names = FALSE, col.names = FALSE))
  lines_mtd <- paste(lines_mtd, collapse = "\n")
  lines_mtd <- paste(lines_mtd, "\n")
  
  lines_prt <- capture.output(write.table(prt, stdout(), sep = "\t", quote = FALSE, 
                                          row.names = FALSE))
  lines_prt <- paste(lines_prt, collapse = "\n")
  lines_prt <- paste(lines_prt, "\n")
  
  lines_pep <- capture.output(write.table(pep, stdout(), sep = "\t", quote = FALSE, 
                                          row.names = FALSE))
  lines_pep <- paste(lines_pep, collapse = "\n")
  lines_pep <- paste(lines_pep, "\n")
  
  lines_psm <- capture.output(write.table(psm, stdout(), sep = "\t",quote = FALSE,  
                                          row.names = FALSE))
  lines_psm <- paste(lines_psm, collapse = "\n")
  lines_psm <- paste(lines_psm, "\n")

  dir.create(file.path(proteoq_path, "mzTab"), showWarnings = FALSE, recursive = TRUE)
  out_file <- file.path(proteoq_path, "mzTab", "mztab.mzTab")
  
  out <- Reduce(append, list(lines_mtd, lines_prt, lines_pep, lines_psm))
  writeLines(out, out_file)

  invisible(NULL)
}


#' Creates folds for cross validation.
#' 
#' From package caret.
#' 
#' @param y The labels.
#' @param k The number of folds.
#' @param list Logical; should the result be a list or not.
#' @param returnTrain Logical; return training sets or not (test sets).
create_folds <- function (y, k = 10L, list = TRUE, returnTrain = FALSE) 
{
  if ((n <- length(y)) >= k) {
    y <- factor(as.character(y))
    numInClass <- table(y)
    foldVector <- vector("integer", n)
    
    for (i in seq_along(numInClass)) {
      min_reps <- numInClass[i] %/% k
      
      if (min_reps) {
        spares <- numInClass[i] %% k
        seqVector <- rep(1:k, min_reps)
        
        if (spares) 
          seqVector <- c(seqVector, sample(1:k, spares))
        
        foldVector[which(y == names(numInClass)[i])] <- 
          sample(seqVector)
      }
      else {
        foldVector[which(y == names(numInClass)[i])] <- 
          sample(1:k, size = numInClass[i])
      }
    }
  }
  else 
    foldVector <- seq_along(y)
  
  if (list) {
    out <- split(seq_along(y), foldVector)
    names(out) <- paste("Fold", gsub(" ", "0", format(seq_along(out))), sep = "")
    
    if (returnTrain) 
      out <- lapply(out, function(data, y) y[-data], y = seq_along(y))
  }
  else 
    out <- foldVector
  
  out
}


#' Calculates cross-validation errors.
#' 
#' Optimizes the regularization cost for svm.
#' 
#' @param train Training set.
#' @param test Test set.
#' @param costs A vector of costs.
#' @param ... Additional arguments for svm.
cv_svm <- function (train, test, costs = c(10E-2, 10E-1, 1, 5, 50), ...)
{
  len  <- length(costs)
  tabs <- errs <- vector("list", len)
  
  for (i in 1:len) {
    m <- e1071::svm(y. ~ ., data = train, cost = costs[i], ...)
    tab_i <- tabs[[i]] <- table(pred = predict(m, test), true = test[["y."]])
    tot <- tab_i[1, 1] + tab_i[1, 2] + tab_i[2, 1] + tab_i[2, 2]
    errs[[i]] <- (tab_i[1, 1] + tab_i[1, 2])/tot
  }

  list(tab = tabs, err = errs)
}


#' Percolator
#'
#' @param df A data frame of \code{psmC.txt}.
#' @param prob_cos Probability cot-offs (as a function of pep_len).
#' @param fct_score The factor in converting probability p-values to scores. 
#' @param k The k-folds for cross validation.
#' @param cross_valid Logical; to perform cross validations or not.
#' @param costs The costs for cross validations.
#' @param def_cost The default cost.
#' @param svm_tol Tolerance in FDR.
#' @param svm_iters The number of iterations.
#' @param ... Additional parameters for \link[e1071]{svm}.
#' @inheritParams matchMS
perco_svm <- function (prob_cos = NULL, out_path = NULL, df = NULL, 
                       target_fdr = .01, fdr_type = "protein", 
                       min_len = 7L, max_len = 40L, max_pepscores_co = 70, 
                       min_pepscores_co = 0, enzyme = "trypsin_p", 
                       fdr_group = "base", nes_fdr_group = "base", 
                       fct_score = 5, k = 10, cross_valid = FALSE, 
                       costs = c(.1, .3, 1, 3, 10), def_cost = 1L, 
                       svm_kernel = "radial",
                       svm_feats  = c("pep_score", "pep_ret_range", 
                                      "pep_delta", "pep_n_ms2", 
                                      "pep_expect", # "pep_len", 
                                      "pep_exp_mz", "pep_exp_mr", 
                                      "pep_tot_int", # "pep_mod_group", 
                                      "pep_n_matches2", 
                                      "pep_ms2_deltas_mean"), 
                       svm_iters = 10L, svm_tol = 1E-4, ...)
{
  if (!all(costs > 0))
    costs <- c(.1, .3, 1, 3, 10)
  
  if (def_cost <= 0)
    def_cost <- 1L
  
  if (svm_iters <= 0L)
    svm_iters <- 10L
  
  if (svm_tol <= 0)
    svm_tol <- 1E-4
  
  fileC <- file.path(out_path, "psmC.txt")
  fileP <- file.path(out_path, "temp", "prob_cos.rds")
  
  # --- preparation 
  if (is.null(df)) {
    if (is.null(out_path)) 
      stop("Argument \"out_path\" cannot be NULL.")
    
    if (!file.exists(fileC))
      stop("File not found: ", fileC)
    
    df <- readr::read_tsv(fileC)
  }
  
  if (is.null(prob_cos)) {
    if (!file.exists(fileP))
      stop("File not found: ", fileP)
    
    prob_cos <- qs::qread(fileP)
  }
  prob_cos0 <- prob_cos

  if (FALSE) {
    if (nrow(df) <= 500L) {
      message("No SVM post-processing with fewer than 500 observations.")
      return(df)
    }
  }

  if (!"pep_delta" %in% names(df)) 
    df$pep_delta <- df$pep_exp_mr - df$pep_calc_mr
  
  cnms <- names(df)
  
  if (!"pep_issig" %in% cnms) {
    warning("No SVM post-processing without data column \"pep_issig\".")
    return(df)
  }
  
  if (!all(c("raw_file", "pep_scan_num") %in% cnms)) {
    warning("Require columns \"raw_file\" and \"pep_scan_num\" for SVM.")
    return(df)
  }
  
  if (!"pep_score" %in% cnms) {
    warning("Column \"pep_score\" required for SVM not found.")
    return(df)
  }
  
  # information already used in getting initial `prob_cos`
  if ("pep_len" %in% svm_feats) {
    warning("Excluded feature \"pep_len\" (information already used).")
    svm_feats <- svm_feats[svm_feats != "pep_len"]
  }
  
  if (FALSE) {
    if ("pep_z_expect" %in% svm_feats && !"pep_z_expect" %in% cnms) {
      df <- df %>% 
        dplyr::left_join(calc_z_pepfdr(out_path = out_path), by = "pep_exp_z") %>% 
        dplyr::mutate(pep_z_expect = 10^((pep_z_prob_co - pep_score)/10) * target_fdr)
    }
  }

  rm(list = c("cnms"))

  # --- initialization
  # metric for selecting high-quality training PSMs
  if (!"pep_expect" %in% svm_feats)
    svm_feats <- c("pep_expect", svm_feats)
  
  if (!"pep_score" %in% svm_feats)
    svm_feats <- c("pep_score", svm_feats)
  
  if (!"pep_expect" %in% names(df))
    df <- dplyr::mutate(df, pep_expect = 10^((pep_score_co - pep_score)/10) * target_fdr)

  if (!"pep_prob" %in% names(df))
    df <- dplyr::mutate(df, pep_prob = 10^(-pep_score/fct_score))
  
  # note: `df` being altered
  if ("pep_exp_z" %in% names(df)) 
    df[["pep_exp_z"]] <- as.integer(factor(df[["pep_exp_z"]]))
  
  td <- prep_pepfdr_td(df, 
                       out_path = out_path, 
                       enzyme = enzyme, 
                       nes_fdr_group = nes_fdr_group, 
                       fdr_group = fdr_group)
  td <- keep_pepfdr_best(td, cols = c("pep_scan_num", "raw_file"))
  td[["y."]] <- as.factor(td[["pep_issig"]])
  
  if (!all(oks <- svm_feats %in% names(df))) {
    warning("SVM features not found: ", svm_feats[!oks])
    svm_feats <- svm_feats[oks]
  }
  
  if (!all(oks <- unlist(lapply(df[svm_feats], is.numeric)))) {
    warning("Non-numeric features excluded: ", svm_feats[!oks])
    svm_feats <- svm_feats[oks]
  }
  
  for (pf in svm_feats)
    td[[paste0(pf, ".")]] <- td[[pf]]
  
  rm(list = c("pf", "oks"))
  
  (svm_feats <- paste0(svm_feats, "."))
  
  if ("pep_expect." %in% svm_feats)
    td[["pep_expect."]] <- -log10(td[["pep_expect."]])
  
  if (FALSE) {
    if ("pep_z_expect." %in% svm_feats)
      td[["pep_z_expect."]] <- -log10(td[["pep_z_expect."]])
  }

  nas <- lapply(svm_feats, function (x) is.na(td[[x]]))
  nas <- Reduce(`|`, nas)
  td0 <- td[nas, ]
  td1 <- td[!nas, ]
  
  rows <- td1[["pep_isdecoy"]]
  ta <- td1[!rows, c("y.", svm_feats), drop = FALSE]
  de <- td1[ rows, c("y.", svm_feats), drop = FALSE]
  rm(list = c("rows"))
  
  ## (2) train and test for each of target and decoy sets
  oks <- ta[["pep_expect."]] >= median(ta[["pep_expect."]], na.rm = TRUE)
  ttrain <- ta[oks, ]
  ttest  <- ta[!oks, ]
  
  rows <- sample(c(TRUE, FALSE), nrow(de), replace = TRUE)
  dtrain <- de[rows, ]
  dtest  <- de[rows, ]
  train  <- dplyr::bind_rows(ttrain, dtrain)
  rm(list = c("dtrain", "rows", "oks"))
  
  if (cross_valid) {
    mses  <- vector("numeric", length(costs))
    folds <- create_folds(ta[["y."]], k = k)
    tests <- trains <- vector("list", k)
    
    for (i in seq_len(k)) {
      tests[[i]]  <- ta[folds[[i]], ]
      trains[[i]] <- ta[-folds[[i]], ]
    }
    
    n_cores <- min(detect_cores(16L), k)
    cl  <- parallel::makeCluster(getOption("cl.cores", n_cores))
    cvs <- parallel::clusterMap(cl, cv_svm, trains, tests, 
                                MoreArgs = list(costs = costs), 
                                SIMPLIFY = FALSE, USE.NAMES = FALSE)
    parallel::stopCluster(cl)
    errs <- lapply(cvs, `[[`, "err")
    
    for (i in seq_along(costs))
      mses[[i]] <- mean(unlist(lapply(errs, `[[`, i)))
    
    best_co <- costs[which.min(mses)]
  }
  else 
    best_co <- def_cost
  
  message("Regularization cost: ", best_co)
  
  fit <- tryCatch(
    e1071::svm(y. ~ ., data = train, kernel = svm_kernel, 
               cost = best_co, ...), 
    error = function (e) NULL)
  
  if (is.null(fit))
    return(prob_cos)

  pred <- tryCatch(
    as.logical(predict(fit, td1[, svm_feats])), 
    error = function (e) NULL)
  
  if (is.null(pred))
    return(prob_cos)

  ###
  # tdr_bare - target-decoy rate (TDR) based on one feature (pep_len)
  # tdr_svm  - TDR based on multiple features; initially tdr_svm < tdr_bare ->
  #            ^target_fdr -> ^tdr_svm ... tdr_svm == tdr_bare
  ###
  
  tdr_bare <- sum(td1[td1$pep_isdecoy, "pep_issig"])/sum(td1[!td1$pep_isdecoy, "pep_issig"])
  td1[, "pep_issig"] <- as.logical(pred)
  tdr_svm <- sum(td1[td1$pep_isdecoy, "pep_issig"])/sum(td1[!td1$pep_isdecoy, "pep_issig"])
  delta <- tdr_svm - tdr_bare
  rm(list = c("tdr_svm"))
  
  # if ((delta > 0) || (abs(delta) <= svm_tol)) return(prob_cos)

  # --- iteration 
  fdr0 <- target_fdr
  fdr1 <- target_fdr * 5
  fdrm <- (fdr0 + fdr1)/2
  step <- fdr1 - fdr0
  
  while((svm_iters > 0L) && (abs(delta) > svm_tol)) {
    prob_cos <- calc_pepfdr(target_fdr = fdrm, 
                            fdr_type = fdr_type, 
                            min_len = min_len, 
                            max_len = max_len, 
                            max_pepscores_co = max_pepscores_co, 
                            min_pepscores_co = min_pepscores_co, 
                            enzyme = enzyme, 
                            fdr_group = fdr_group, 
                            nes_fdr_group = nes_fdr_group, 
                            out_path = out_path)
    df <- post_pepfdr(prob_cos, out_path) # also updates pepfdr.rds
    
    if (!"pep_delta" %in% names(df)) 
      df$pep_delta <- df$pep_exp_mr - df$pep_calc_mr
    
    if (!"pep_expect" %in% names(df))
      df <- dplyr::mutate(df, pep_expect = 
                            10^((pep_score_co - pep_score)/fct_score) * fdrm)
    
    if (!"pep_prob" %in% names(df))
      df <- dplyr::mutate(df, pep_prob = 10^(-pep_score/fct_score))
    
    td <- prep_pepfdr_td(df, 
                         out_path = out_path, 
                         enzyme = enzyme, 
                         nes_fdr_group = nes_fdr_group, 
                         fdr_group = fdr_group)
    td <- keep_pepfdr_best(td, cols = c("pep_scan_num", "raw_file"))
    td[["y."]] <- as.factor(td[["pep_issig"]])
    
    svm_feats <- gsub("\\.", "", svm_feats)
    
    for (pf in svm_feats)
      td[[paste0(pf, ".")]] <- td[[pf]]
    
    rm(list = c("pf"))
    svm_feats <- paste0(svm_feats, ".")
    
    if ("pep_expect." %in% svm_feats)
      td[["pep_expect."]] <- -log10(td[["pep_expect."]])

    nas <- lapply(svm_feats, function (x) is.na(td[[x]]))
    nas <- Reduce(`|`, nas)
    
    if (length(nas)) {
      td0 <- td[nas, ]
      td1 <- td[!nas, ]
    }
    else {
      td0 <- NULL
      td1 <- td
    }
    
    rows <- td1[["pep_isdecoy"]]
    ta <- td1[!rows, c("y.", svm_feats), drop = FALSE]
    de <- td1[ rows, c("y.", svm_feats), drop = FALSE]
    rm(list = c("rows"))
    
    ## (2) train and test for each of target and decoy sets
    oks <- ta[["pep_expect."]] >= median(ta[["pep_expect."]], na.rm = TRUE)
    ttrain <- ta[oks, ]
    ttest  <- ta[!oks, ]
    
    rows <- sample(c(TRUE, FALSE), nrow(de), replace = TRUE)
    dtrain <- de[rows, ]
    dtest  <- de[rows, ]
    train  <- dplyr::bind_rows(ttrain, dtrain)
    rm(list = c("dtrain", "rows", "oks"))
    
    fit <- tryCatch(e1071::svm(y. ~ ., data = train, kernel = svm_kernel, 
                               cost = best_co, ...), 
                    error = function (e) NULL)
    
    if (is.null(fit))
      return(if (all(prob_cos[, 2] >= prob_cos0[, 2])) prob_cos else prob_cos0)
    
    pred <- tryCatch(
      as.logical(predict(fit, td1[, svm_feats])), 
      error = function (e) NULL)
    
    if (is.null(pred))
      return(if (all(prob_cos[, 2] >= prob_cos0[, 2])) prob_cos else prob_cos0)

    td1[, "pep_issig"] <- as.logical(pred)
    tdr_svm <- sum(td1[td1$pep_isdecoy, "pep_issig"])/sum(td1[!td1$pep_isdecoy, "pep_issig"])
    delta <- tdr_svm - tdr_bare
    
    if (delta < 0) {
      # next grid
      fdr0 <- fdrm
      fdrm <- (fdr0 + fdr1)/2
    }
    else {
      # left-half grid
      fdr1 <- fdrm
      fdrm <- (fdr0 + fdr1)/2
      step <- fdrm - fdr0
    }
    
    message("Range of adjusted FDR: ", fdr0, " : ", fdr1)
    svm_iters <- svm_iters - 1L
  }
  
  if (all(prob_cos[, 2] >= prob_cos0[, 2])) prob_cos else prob_cos0
}


#' Helper of calc_tmtint
#' 
#' @param df A data frame.
#' @param idx The i-th chunk
#' @inheritParams matchMS
#' @inheritParams calc_pepscores
hcalc_tmtint <- function (df, quant = "tmt10", ppm_reporters = 10L, idx = 1L, 
                          out_path = NULL)
{
  df <- df[, c("raw_file", "pep_mod_group", "pep_scan_num", "rptr_moverzs", 
               "rptr_ints")]
  df <- unique(df)
  df <- calc_tmtint(df, quant = quant, ppm_reporters = ppm_reporters)
  df[["uniq_id"]] <- with(df, paste(raw_file, pep_mod_group, pep_scan_num, 
                                    sep = "."))
  df[["raw_file"]] <- df[["pep_mod_group"]] <- df[["pep_scan_num"]] <- NULL
  
  qs::qsave(df, file.path(out_path, paste0("reporters_", idx, ".rds")), 
            preset = "fast")

  invisible(df)
}


#' Reporter-ion quantitation.
#' 
#' Not yet used: \code{`134C` = 134.154565}, \code{`135N` = 135.15160}
#'  
#' @param data An upstream result from \link{matchMS}.
#' @param quant A quantitation method. The default is "none". Additional choices
#'   include \code{tmt6} etc. For other multiplicities of \code{tmt}, use the
#'   compatible higher plexes, for example, \code{tmt16} for \code{tmt12} etc.
#'   and \code{tmt10} for \code{tmt8} etc.
#' @param ppm_reporters The mass tolerance of MS2 reporter ions.
calc_tmtint <- function (data = NULL, quant = "tmt16", ppm_reporters = 10L) 
{
  if (quant == "none")
    return(data)

  nms_tmt6  <- c("126", "127N", "128N", "129N", "130N", "131N")
  nms_tmt10 <- c("126", "127N", "127C", "128N", "128C", "129N", "129C",
                 "130N", "130C", "131N")
  nms_tmt11 <- c("126", "127N", "127C", "128N", "128C", "129N", "129C",
                 "130N", "130C", "131N", "131C")
  nms_tmt16 <- c("126", "127N", "127C", "128N", "128C", "129N", "129C",
                 "130N", "130C", "131N", "131C", "132N", "132C",
                 "133N", "133C", "134N")
  nms_tmt18 <- c("126", "127N", "127C", "128N", "128C", "129N", "129C",
                 "130N", "130C", "131N", "131C", "132N", "132C",
                 "133N", "133C", "134N", "134C", "135N")
  
  # "C(8) N(1) H(16)"
  tmts <- c(
    `126` = 126.127726, `127N` = 127.124761, `127C` = 127.131080,
    `128N` = 128.128115, `128C` = 128.134435, `129N` = 129.131470,
    `129C` = 129.137790, `130N` = 130.134825, `130C` = 130.141145,
    `131N` = 131.138180, `131C` = 131.144499, `132N` = 132.141535,
    `132C` = 132.147855, `133N` = 133.14489, `133C` = 133.15121,
    `134N` = 134.148245, `134C` = 134.155114, `135N` = 135.152149)
  
  theos <- switch(quant,
                  tmt6  = tmts[names(tmts) %in% nms_tmt6],
                  tmt10 = tmts[names(tmts) %in% nms_tmt10],
                  tmt11 = tmts[names(tmts) %in% nms_tmt11],
                  tmt16 = tmts[names(tmts) %in% nms_tmt16],
                  tmt18 = tmts[names(tmts) %in% nms_tmt18],
                  stop("Unknown TMT type."))
  
  ul <- switch(quant,
               tmt6 = c(126.1, 131.2),
               tmt10 = c(126.1, 131.2),
               tmt11 = c(126.1, 131.2),
               tmt16 = c(126.1, 134.2),
               tmt18 = c(126.1, 135.2),
               stop("Unknown TMT type."))
  
  # stopifnot(all(c("rptr_moverzs", "rptr_ints") %in% names(data)))

  out <- mapply(find_reporter_ints, data[["rptr_moverzs"]], data[["rptr_ints"]], 
                MoreArgs = list(
                  theos = theos,
                  ul = ul,
                  ppm_reporters = ppm_reporters,
                  len = length(theos),
                  channels = names(theos)
                ), USE.NAMES = FALSE, SIMPLIFY = FALSE)
  
  out <- dplyr::bind_rows(out)
  
  if (!nrow(out)) {
    out <- data.frame(matrix(ncol = length(theos), nrow = 0L))
    colnames(out) <- theos
    
    for (i in seq_along(out)) 
      out[[i]] <- as.numeric(out[[i]])
  }
  
  data[["rptr_moverzs"]] <- data[["rptr_ints"]] <- NULL
  
  out <- dplyr::bind_cols(data, out)
  
  cols <- grep("^([0-9]{3}[NC]{0,1})", names(out))
  names(out)[cols] <- find_int_cols(length(theos))
  
  invisible(out)
}


#' Adds back reporter-ion intensities
#'
#' @param df Results from \link{calc_protfdr}.
#' @inheritParams matchMS
add_rptrs <- function (df = NULL, quant = "none", out_path = NULL) 
{
  if (!grepl("^tmt[0-9]+$", quant))
    return(df)
  
  pattern <- "^reporters_\\d+\\.rds$"
  files <- list.files(path = file.path(out_path, "temp"), pattern = pattern)
  idxes <- order(as.integer(gsub("^reporters_([0-9]+)\\.rds$", "\\1", files)))
  files <- files[idxes]
  
  reporters <- lapply(files, function (x) qs::qread(file.path(out_path, "temp", x)))
  reporters <- dplyr::bind_rows(reporters)
  
  df |>
    tidyr::unite(uniq_id, raw_file, pep_mod_group, pep_scan_num, sep = ".", 
                 remove = FALSE) |>
    dplyr::left_join(reporters, by = "uniq_id") |>
    dplyr::select(-uniq_id)
}


#' Finds the columns of reporter-ion intensity.
#' 
#' Also in proteoQ.
#' 
#' @param TMT_plex Numeric; the multiplexity of TMT, i.e., 10, 11 etc.
find_int_cols <- function (TMT_plex) 
{
  col_int <- if (TMT_plex == 18L) 
    c("I126", "I127N", "I127C", "I128N", "I128C", "I129N", "I129C",
      "I130N", "I130C", "I131N", "I131C",
      "I132N", "I132C", "I133N", "I133C", "I134N", "I134C", "I135N") 
  else if (TMT_plex == 16L) 
    c("I126", "I127N", "I127C", "I128N", "I128C", "I129N", "I129C",
      "I130N", "I130C", "I131N", "I131C",
      "I132N", "I132C", "I133N", "I133C", "I134N")
  else if (TMT_plex == 11L) 
    c("I126", "I127N", "I127C", "I128N", "I128C", "I129N", "I129C",
      "I130N", "I130C", "I131N", "I131C")
  else if (TMT_plex == 10L) 
    c("I126", "I127N", "I127C", "I128N", "I128C", "I129N", "I129C",
      "I130N", "I130C", "I131")
  else if(TMT_plex == 6L) 
    c("I126", "I127", "I128", "I129", "I130", "I131")
  else 
    NULL
}


#' Finds the intensities of reporter-ions.
#'
#' @param ms2_moverzs Numeric vector; a series of experimental MS2 m-over-z's
#'   (in the region of reporter ions).
#' @param ms2_ints Numeric vector; a series of experimental MS2 intensities (in
#'   the region of reporter ions).
#' @param theos The theoretical m-over-z of reporter ions.
#' @param ul The upper and lower bound for reporter-ion m-over-z's.
#' @param len The length of reporter-ion plexes.
#' @param channels The names of reporter-ion channels.
#' @inheritParams matchMS
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' ms2_moverzs <- c(112.0873, 126.1280, 127.1251, 127.1313, 128.1250,
#'                  128.1284, 128.1347, 129.1317, 129.1380, 130.0654,
#'                  130.1351, 130.1413, 131.1384)
#'
#' ms2_ints <- c(5113.79, 135569.00, 120048.00, 122599.00, 3397.98,
#'               140551.00, 144712.00, 103166.00, 145452.00, 3851.82,
#'               148218.00, 135393.00, 131215.00)
#'
#' theos <- c(126.1277, 127.1248, 127.1311, 128.1281, 128.1344,
#'            129.1315, 129.1378, 130.1348, 130.1411, 131.1382)
#' names(theos) <- c("126", "127N", "127C", "128N", "128C",
#'                   "129N", "129C", "130N", "130C", "131N")
#'
#' ppm_reporters <- 10
#' ul <- c(126.1, 131.2)
#' len <- 10
#' channels <- names(theos)
#'
#' x <- mzion:::find_reporter_ints(ms2_moverzs, ms2_ints, theos, ul, ppm_reporters = 10,
#'                         len , channels)
#'
#' x <- mzion:::find_reporter_ints(ms2_moverzs, ms2_ints, theos, ul, ppm_reporters = 25,
#'                         len , channels)
#'
#' # Two `129C`, no `127N` etc.
#' ms2_moverzs <- c(105.1503, 107.0428, 111.7716, 120.0811, 126.1281, 127.1312,
#'                  128.1282, 128.1349, 129.1317, 129.1365, 129.1382, 230.1694,
#'                  233.4857, 233.4964, 337.3533, 352.1844, 376.2764, 463.3083,
#'                  525.2150, 562.3732, 569.3899, 591.2545, 596.0308, 632.3300,
#'                  636.3959, 703.3637, 789.0423, 816.4487, 817.4516, 839.9531,
#'                  864.3056, 914.7645, 921.5302, 1479.9816)
#'
#' ms2_ints <- c(1201.79, 1319.32, 1603.45, 1595.34, 2148.66, 1785.74, 1254.24,
#'               1986.43, 10127.40, 1522.60, 1562.71, 2926.01, 1590.48, 1692.17,
#'               1347.88, 1412.64, 3050.10, 3231.10, 1355.21, 2424.18, 1783.26,
#'               1365.32, 1727.12, 2661.72, 1660.05, 5525.95, 1399.96, 4654.03,
#'               1990.57, 1758.72, 1655.09, 1460.68, 1641.39, 1721.33)
#'
#' x <- mzion:::find_reporter_ints(ms2_moverzs, ms2_ints, theos, ul, ppm_reporters = 25,
#'                         len , channels)
#' }
find_reporter_ints <- function (ms2_moverzs, ms2_ints, theos, ul,
                                ppm_reporters = 10L, len, channels) 
{
  range <- findInterval(ul, ms2_moverzs)
  rg <- range[1]:range[2]
  ms <- ms2_moverzs[rg]
  vs <- ms2_ints[rg]
  idxes <- find_reporters_ppm(theos, ms, ppm_reporters, len)
  
  if (!length(idxes)) {
    es <- rep_len(NA_real_, len)
    names(es) <- channels
    return(es)
  }

  if (anyDuplicated(chs <- names(idxes))) {
    idxes <- split(idxes, chs)
    
    idxes <- mapply(function (x, y) {
      if (length(x) > 1L)
        x <- x[which.min(abs(ms[x] - theos[y]))]
      else 
        x
    }, idxes, names(idxes), USE.NAMES = FALSE, SIMPLIFY = TRUE)
    
    # complete and correct order of channels
    idxes <- idxes[channels]
  }
  
  # missing channels:
  # 126 <NA> 127C 128N 128C 129N 129C <NA> <NA> <NA>
  #  2   NA    3    4    5    6    8   NA   NA   NA
  
  if (anyNA(names(idxes))) 
    names(idxes) <- channels
  
  rptr_ints <- vs[idxes]
  names(rptr_ints) <- names(idxes)

  if (length(rptr_ints) < len) {
    es <- rep_len(NA_real_, len)
    names(es) <- channels
    es[names(rptr_ints)] <- rptr_ints
  } 
  else {
    es <- rptr_ints
  }
  
  es
}


#' Finds the indexes of reporter ions.
#'
#' @param expts Numeric vector; a series of experimental MS2s (in the region of
#'   reporter ions).
#' @inheritParams find_reporter_ints
#' @return A vector of indexes
find_reporters_ppm <- function (theos, expts, ppm_reporters = 10L, len) 
{
  d <- outer(theos, expts, "find_ppm_error")
  row_cols <- which(abs(d) <= ppm_reporters, arr.ind = TRUE)
  row_cols[, 2]
}


#' Helper of \link{sub_protpep}
#'
#' Subsets the protein-peptide lookup (prps) against the uniq_peps list from
#' search results.
#'
#' @param prps A protein-peptide lookup.
#' @param uniq_peps A non-redundant list of peptides from search results.
msub_protpep <- function (prps, uniq_peps)
{
  mts <- lapply(prps, fastmatch::fmatch, uniq_peps)
  
  ans <- mapply(sub_protpep, prps, mts, names(mts),
                SIMPLIFY = FALSE, USE.NAMES = FALSE)

  dplyr::bind_rows(ans)
}


#' Subsets the protein-peptide lookups.
#' 
#' Duplicated peptide sequences with a protein also removed.
#'
#' @param prp A vector of peptides under a protein.
#' @param mt A vector of matches. The values are NA if no matches. The matched
#'   integers are the indexes in the list of uniq_peps for protein annotations.
#' @param nm The names of \code{prp}.
sub_protpep <- function (prp, mt, nm)
{
  nas <- is.na(mt)
  
  if (all(nas))
    return(NULL)
  
  oks <- !nas
  ps  <- which(oks)
  
  len <- length(prp)
  vc <- vn <- vector("logical", len)

  if (length(ps)) {
    pnt <- ps[ps %fin% attr(prp, "pnt_idxes", exact = TRUE)]
    pct <- ps[ps %fin% attr(prp, "pct_idxes", exact = TRUE)]
  }
  else {
    pct <- pnt <- numeric()
  }
  
  vn[pnt] <- TRUE
  vc[pct] <- TRUE

  u <- !duplicated.default(mt[ps])
  # pep_id = mt[ps][u]
  
  list(prot_acc = rep(nm, sum(u)), 
       pep_seq = prp[ps][u], 
       is_pnt = vn[ps][u], 
       is_pct = vc[ps][u])
}


#' Adds prot_acc to a peptide table
#'
#' Cached results are under sub dirs.
#' 
#' @param out_path An output path.
#' @param df The results after scoring.
#' @inheritParams matchMS
add_protacc2 <- function (df = NULL, out_path = NULL, .path_cache = NULL, 
                          .path_fasta = NULL) 
{
  message("Adding protein accessions (no enzyme specificity).")
  
  if (is.null(df)) {
    file <- file.path(out_path, "temp", "peploc.rds")
    
    if (file.exists(file))
      df <- qs::qread(file)
    else
      stop("File not found: ", file)
    
    rm(list = c("file"))
  }
  
  sub_dirs <- dir(out_path, pattern = "^sub[0-9]+_[0-9]+_[0-9]+$", 
                  full.names = TRUE)
  len_dirs <- length(sub_dirs)
  
  if (!len_dirs) {
    warning("Cached results not found for protein annotation.")
    return (df)
  }
  
  prps <- vector("list", len_dirs)
  
  for (i in seq_along(sub_dirs)) {
    cache_file <- file.path(sub_dirs[[i]], "Calls/.cache_info.rds")
    
    if (!file.exists(cache_file))
      stop("Cached file not found: ", cache_file)
    
    cache_info <- load_cache_info(cache_file)
    .time_stamp <- cache_info[[".time_stamp"]]
    .path_ms1masses <- cache_info[[".path_ms1masses"]]
    
    file <- file.path(.path_ms1masses, .time_stamp, "simple_prot_pep.rds")
    prps[[i]] <- if (file.exists(file)) qs::qread(file) else NULL
  }
  
  upeps <- unique(df$pep_seq)
  prps <- lapply(prps, msub_protpep, upeps)
  prps <- dplyr::bind_rows(prps)
  
  df <- hannot_decoys(df, prps)
}


#' Adds prot_acc to a peptide table.
#'
#' Decoys being kept.
#'
#' @param out_path An output path.
#' @param df The results after scoring.
#' @inheritParams matchMS
#' @importFrom fastmatch fmatch %fin% 
add_protacc <- function (df = NULL, out_path = NULL, .path_cache = NULL, 
                         .path_fasta = NULL) 
{
  message("Adding protein accessions.")
  
  if (is.null(df)) {
    file <- file.path(out_path, "temp", "peploc.rds")
    
    if (file.exists(file))
      df <- qs::qread(file)
    else
      stop("File not found: ", file)
    
    rm(list = c("file"))
  }
  
  # need to inverse the sequence at NA pep_ivmod: 
  # decoy MS2 are appended to targets and share the same pep_seq name as targets 
  #   where the pep_ivmod values are NA with the decoys
  
  .path_ms1masses <- create_dir(file.path(.path_fasta, "ms1masses"))
  .time_stamp <- find_ms1_times(out_path)
  
  if (length(.time_stamp) > 1L)
    stop("Multiple matches in time stamps in annotating protein acccessions.")
  
  prps <- qs::qread(file.path(.path_ms1masses, .time_stamp, "simple_prot_pep.rds"))
  prps <- msub_protpep(prps, unique(df[["pep_seq"]]))
  
  df <- hannot_decoys(df, prps)
}


#' Helper of annotating decoy peptides.
#' 
#' @param df A data frame.
#' @param prps The look-ups of protein and peptides.
hannot_decoys <- function (df, prps)
{
  # keep prot_acc be the first column
  # !!! reverse decoy pep_seq after adding prot_acc
  df <- dplyr::right_join(prps, df, by = "pep_seq")
  rows <- is.na(df[["pep_ivmod"]])
  tars <- df[!rows, ]
  
  decs <- df[rows, ]
  decs[["pep_seq"]] <- reverse_seqs(decs[["pep_seq"]])
  oks <- fastmatch::fmatch(decs[["pep_seq"]], tars[["pep_seq"]])
  decs <- decs[is.na(oks), ]
  decs[["prot_acc"]] <- paste0("-", decs[["prot_acc"]])
  df <- dplyr::bind_rows(tars, decs)
  
  # Adds prot_n_psm, prot_n_pep for protein FDR estimates
  x <- df[df[["pep_issig"]], ]
  
  prot_n_psm <- x |>
    dplyr::select(prot_acc) |>
    dplyr::group_by(prot_acc) |>
    dplyr::summarise(prot_n_psm = n())
  
  prot_n_pep <- x |>
    dplyr::select(pep_seq, prot_acc) |> 
    tidyr::unite(pep_prot, c("pep_seq", "prot_acc"), sep = ".", remove = FALSE) |> 
    dplyr::filter(!duplicated(pep_prot)) |>
    dplyr::group_by(prot_acc) |>
    dplyr::summarise(prot_n_pep = n())
  
  # inconsistent Protein[NC]-term
  pnt_nots <- grepl("Protein N-term", df[["pep_vmod"]], fixed = TRUE) & !df[["is_pnt"]]
  pct_nots <- grepl("Protein C-term", df[["pep_vmod"]], fixed = TRUE) & !df[["is_pct"]]
  df <- df[(!pnt_nots) & (!pct_nots), ]
  
  # peptide `is_pnt` and `is_pct` are not EXACT facts
  # but preference of terminal over interior matches
  # so remove them to avoid misleading uses or interpretations
  df[["is_pnt"]] <- NULL
  df[["is_pct"]] <- NULL
  
  list(df, prot_n_psm, prot_n_pep) |>
    purrr::reduce(dplyr::left_join, by = "prot_acc") |>
    dplyr::arrange(-prot_n_pep, -prot_n_psm)
}


#' Groups proteins by shared peptides.
#'
#' Adds columns \code{prot_hit_num} and \code{prot_family_member} etc. to
#' \code{psmQ.txt}.
#'
#' In general, non-significant and decoy peptides should have been removed from
#' the input \code{df}, as well as decoy proteins.
#'
#' In addition, there is no duplicated entries.
#'
#' @param df A two-column data frame contains \code{prot_acc} and
#'   \code{pep_seq}.
#' @param out_path The output path.
#' @param out_name The output filename.
#' @param fct A factor for data splitting into chunks.
#' 
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' df <- data.frame(prot_acc = character(2000), pep_seq = character(2000))
#' set.seed(100)
#' df$prot_acc <- sample(LETTERS[1:20], 2000, replace = TRUE)
#' df$pep_seq <- sample(letters[1:26], 20, replace = TRUE)
#' df <- df[!duplicated(df), ]
#'
#' out <- mzion:::groupProts(df, "~")
#'
#' # One peptide, multiple proteins
#' df <- data.frame(prot_acc = LETTERS[1:3], pep_seq = rep("X", 3))
#' out <- mzion:::groupProts(df, "~")
#' stopifnot(nrow(out) == 3L)
#'
#' # One peptide, one proteins
#' df <- data.frame(prot_acc = "A", pep_seq = "X")
#' out <- mzion:::groupProts(df, "~")
#' stopifnot(nrow(out) == 1L)
#'
#' # One proteins
#' df <- data.frame(prot_acc = rep("A", 3), pep_seq = LETTERS[24:26])
#' out <- mzion:::groupProts(df, "~")
#' stopifnot(nrow(out) == 3L)
#' }
groupProts <- function (df, out_path = NULL, fct = 4L, 
                        out_name = "prot_pep_setcover.rds") 
{
  # `pep_seq` in `df` are all from target and significant;
  # yet target `pep_seq` can be assigned to both target and decoy proteins
  #
  #    prot_acc     pep_seq
  #  1 -GOG8C_HUMAN EEQERLR
  #  2 -GOG8D_HUMAN EEQERLR
  # 11 MNT_HUMAN    EEQERLR
  
  if (!identical(names(df), c("prot_acc", "pep_seq")))
    stop("The two columns of `df` need to be in the order of ", "
         \"prot_acc\" and \"pep_seq\".")
  
  if (!nrow(df))
    stop("Zero row of data for protein groupings.")
  
  dir.create(file.path(out_path), recursive = TRUE, showWarnings = FALSE)
  
  df <- df[with(df, order(pep_seq)), ]
  
  if (nrow(df) <= 1L)
    return(dplyr::mutate(df, 
                         prot_isess = TRUE,
                         prot_hit_num = 1L,
                         prot_family_member = 1L, 
                         pep_literal_unique = TRUE, 
                         pep_razor_unique = TRUE))

  ## (1) builds protein ~ peptide map
  Mats <- map_pepprot(df, out_path = out_path, fct = fct)
  message("Completed protein-peptide maps.")
  
  Mat_upr_left <- Mats$upr_left
  Mat_lwr_left <- Mats$lwr_left
  Mat_lwr_right <- Mats$lwr_right
  
  peps_shared <- rownames(Mat_upr_left)
  prots_upr_right <- colnames(Mat_lwr_right)
  # peps_unique <- rownames(Mat_lwr_left)
  
  if (is.null(Mat_lwr_right))
    Mat_upr_right <- NULL
  else {
    # works for zero-column matrix
    Mat_upr_right <- Matrix::sparseMatrix(
      dims = c(nrow(Mat_upr_left), ncol(Mat_lwr_right)), 
      i={}, j={}
    )
    colnames(Mat_upr_right) <- prots_upr_right
    rownames(Mat_upr_right) <- peps_shared
  }
  
  # Empty `Mat_upr_left` is a zero-row data.frame, not NULL

  rm(list = c("Mats"))
  gc()
  
  # Mat_left (`Mat_upr_left` + `Mat_lwr_left`)
  # - `Mat_upr_left`
  #   * column names: proteins with shared peptides
  #   * row names: shared peptides 
  # - `Mat_lwr_left`
  #   * column names: the same as `Mat_upr_left`
  #   * row names: unique peptides
  # 
  # `Mat_right` (`Mat_upr_right` + `Mat_lwr_right`)
  # - `Mat_upr_right`
  #   * column names: protein with only unique peptides
  #   * row names: shared peptides (as in `Mat_upr_left`)
  #   * (the values are all zeros)
  # - `Mat_lwr_right`
  #   * column names: the same as `Mat_upr_right`
  #   * row names: unique peptides (as in `Mat_lwr_left`)

  ## (2) establishes protein groups
  # each row in cbind(Mat_lwr_left, Mat_lwr_right) has only one "1"
  #   -> Mat_lwr_left does not affect logical distance of 0/1
  
  if (nrow(Mat_upr_left)) {
    prot_grps <- local({
      grps_1 <- cut_proteinGroups(Mat_upr_left, out_path)
      gc()
      
      max <- max(grps_1$prot_hit_num, na.rm = TRUE)
      idxes <- seq_along(prots_upr_right) + max
      
      if (is.null(prots_upr_right) || !length(prots_upr_right))
        grps_2 <- NULL
      else 
        grps_2 <- data.frame(prot_acc = prots_upr_right, 
                             prot_hit_num = idxes, 
                             prot_family_member = 1L)

      rbind2(grps_1, grps_2)
    })
  }
  else {
    # no shared peptides
    prot_grps <- data.frame(prot_acc = prots_upr_right, 
                            prot_hit_num = seq_along(prots_upr_right), 
                            prot_family_member = 1L)
  }
  message("Completed protein grouping.")

  ## (3) finds essential protein entries
  ess_prots <- local({
    if (is.null(Mat_lwr_left))
      df_shared <- greedysetcover3(Mat_upr_left)
    else {
      # unique peptides of proteins with shared peptides
      rows_lwr_left_is_one <- Matrix::rowSums(Mat_lwr_left) > 0
      Mat_lwr_left_is_one <- Mat_lwr_left[rows_lwr_left_is_one, , drop = FALSE]
      
      # set covers of shared + unique peptides under shared proteins
      df_shared <- greedysetcover3(rbind2(Mat_upr_left, Mat_lwr_left_is_one))
      gc()
    }

    # proteins with exclusive unique peptides
    df_uniq <- df[, c("prot_acc", "pep_seq")]
    df_uniq <- df_uniq[df_uniq$prot_acc %in% prots_upr_right, , drop = FALSE]
    df_uniq <- df_uniq[!duplicated.data.frame(df_uniq), , drop = FALSE]
    df_uniq <- df_uniq[with(df_uniq, order(prot_acc, pep_seq)), , drop = FALSE]
    
    sets <- rbind2(df_shared, df_uniq)
    
    if (!is.null(out_path)) {
      qs::qsave(sets, file.path(out_path, out_name), preset = "fast")
    }

    unique(sets$prot_acc)
  })
  message("Established essential proteins.")

  ## Parses literal or razor uniqueness of peptides
  # sets aside df0
  df <- dplyr::mutate(df, prot_isess = prot_acc %in% ess_prots)
  df0 <- dplyr::filter(df, !prot_isess)
  df <- dplyr::filter(df, prot_isess)
  gc()
  
  # combines four quadrants
  M4 <- rbind2(
    cbind2(Mat_upr_left, Mat_upr_right), 
    cbind2(Mat_lwr_left, Mat_lwr_right)
  )
  
  rm(list = c("Mat_upr_left", "Mat_upr_right", 
              "Mat_lwr_left", "Mat_lwr_right"))
  gc()
  
  M4_ess <- if (nrow(M4) == 1L) 
    M4
  else 
    M4[, colnames(M4) %in% ess_prots, drop = FALSE]
  
  # literal: unique in M4
  # razor: unique in M4_ess
  peps_uniq <- local({
    rsums <- Matrix::rowSums(M4)
    rsums2 <- Matrix::rowSums(M4_ess)
    
    peps <- data.frame(pep_seq = rownames(M4)) |>
      dplyr::mutate(pep_literal_unique = (rsums == 1L)) |>
      dplyr::mutate(pep_razor_unique = (rsums2 == 1L))
  })
  
  rm(list = c("M4", "M4_ess"))
  gc()
  message("Parsed unique versus shared peptides.")
  
  df0 <- df0 |>
    dplyr::mutate(prot_hit_num = NA, prot_family_member = NA)
  
  df <- df |>
    dplyr::left_join(prot_grps, by = "prot_acc") |>
    dplyr::bind_rows(df0) |>
    dplyr::left_join(peps_uniq, by = "pep_seq")

  invisible(df)
}


#' Helper of \link{groupProts}.
#'
#' Builds the logical map between peptide (in rows) and proteins (in columns).
#'
#' The \code{lwr_left} and \code{lwr_right} can be NULL with early exit or
#' "empty" sparse matrix with end return. Maybe uniform later to "empty" matrix.
#'
#' @param df The data frame from upstream steps. It must contains the two
#'   columns of \code{prot_acc} and \code{pep_seq}. It should be TRUE that
#'   \code{df} is identical to \code{unique(df)}.
#' @param out_path An output path.
#' @param fct A factor for data splitting into chunks.
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' df <- data.frame(prot_acc = character(2000), pep_seq = character(2000))
#' set.seed(100)
#' df$prot_acc <- sample(LETTERS[1:20], 2000, replace = TRUE)
#' df$pep_seq <- sample(letters[1:26], 20, replace = TRUE)
#' df <- df[!duplicated(df), ]
#'
#' out <- mzion:::map_pepprot(df)
#'
#' # One peptide, multiple proteins
#' df <- data.frame(prot_acc = LETTERS[1:3], pep_seq = rep("X", 3))
#' out <- mzion:::map_pepprot(df)
#' stopifnot(rownames(out[[1]]) == "X", colnames(out[[1]]) == LETTERS[1:3])
#'
#' # One peptide, one proteins
#' df <- data.frame(prot_acc = "A", pep_seq = "X")
#' out <- mzion:::map_pepprot(df)
#' stopifnot(rownames(out[[1]]) == "X", colnames(out[[1]]) == "A")
#'
#' # One proteins
#' df <- data.frame(prot_acc = rep("A", 3), pep_seq = LETTERS[24:26])
#' out <- mzion:::map_pepprot(df)
#' stopifnot(rownames(out[[1]]) == LETTERS[24:26], colnames(out[[1]]) == "A")
#' }
map_pepprot <- function (df, out_path = NULL, fct = 4L) 
{
  # collapse rows of the same pep_seq
  #
  #      pep_seq prot_acc
  # 1       A        X
  # 2       A        Y
  # 3       B        X
  # 4       C        Y
  #
  #   X Y
  # 1 1 0
  # 2 0 1
  # 3 1 0
  # 4 0 1
  #
  # pep_seq   X     Y
  # 1 A       TRUE  TRUE
  # 2 B       TRUE  FALSE
  # 3 C       FALSE TRUE
  
  if (!identical(names(df), c("prot_acc", "pep_seq")))
    stop("The two columns of `df` need to be in the order of ", "
         \"prot_acc\" and \"pep_seq\".")
  
  # FIRST ordered by `pep_seq`, SECOND by `prot_acc` 
  # (for continuity of the same `pep_seq`)
  
  # df <- df[!duplicated.data.frame(df), ] # should not contain duplicated entries
  df <- df[with(df, order(pep_seq, prot_acc)), ]

  peps <- df$pep_seq

  # (one peptide, ONE protein)
  if (length(peps) == 1L) {
    out <- matrix(1)
    colnames(out) <- df$prot_acc
    rownames(out) <- peps
    Mat <- Matrix::Matrix(out, sparse = TRUE)
    
    return(list(upr_left = Mat, lwr_left = NULL, lwr_right = NULL))
  }

  ## Separates into Mat0 and Mat1
  uniq_prots <- unique(df$prot_acc)
  
  # (One protein, multiple peptides)
  if (length(uniq_prots) == 1L) {
    Mat <- Matrix::Matrix(matrix(rep(1L, length(peps))), sparse = TRUE)
    colnames(Mat) <- uniq_prots
    rownames(Mat) <- peps
    
    return(list(upr_left = Mat, lwr_left = NULL, lwr_right = NULL))
  }
  
  Mat <- Matrix::sparse.model.matrix(~ -1 + prot_acc, df)
  prots <- stringi::stri_replace_first_fixed(colnames(Mat), "prot_acc", "")
  colnames(Mat) <- prots
  
  Mat <- Mat == 1L
  rownames(Mat) <- peps
  gc()
  
  dpeps <- peps[duplicated.default(peps)]
  drows <- peps %in% dpeps
  Mat0  <- Mat[!drows, , drop = FALSE]
  Mat1  <- Mat[drows, , drop = FALSE]

  rm(list = c("dpeps", "drows", "Mat", "peps"))
  gc()
  
  ## Mat1: (a) pre sparse-matrix vector
  ncol  <- as.numeric(ncol(Mat1))
  peps1 <- rownames(Mat1)
  vec   <- pcollapse_sortpeps(Mat = Mat1, ncol = ncol, peps = peps1, fct = fct)
  
  rm(list = c("Mat1"))
  gc()

  ## Mat1: (b) vector -> sparse matrix
  # (not to use function to avoid copying large vector)
  upeps <- unique(peps1)
  n_upeps <- as.numeric(length(upeps))
  llen <- n_upeps * ncol
  
  if (object.size(vec)/1024^3 > 5) {
    rows_per_chunk <- 10000
    size_chunk <- ncol*rows_per_chunk
    n_chunks <- ceiling(n_upeps/rows_per_chunk)

    out <- NULL
    
    for (i in 1:n_chunks) {
      start <- size_chunk*(i-1)+1
      end <- min(llen, size_chunk*i)
      
      vsub <- vec[start:end]
      msub <- Matrix::Matrix(vsub, ncol = ncol, byrow = TRUE, sparse = TRUE)
      out <- rbind2(out, msub)
      
      rm(list = c("vsub", "msub", "start", "end"))
      gc()
    }
    
    rm(list = c("rows_per_chunk", "size_chunk", "n_chunks"))
  } 
  else {
    out <- Matrix::Matrix(vec, ncol = ncol, byrow = TRUE, sparse = TRUE)
  }
  
  rm(list = c("vec"))
  gc()

  colnames(out) <- prots
  rownames(out) <- upeps
  gc()

  ## To logical sparse matrix
  out <- out == 1L
  gc()

  ## Cleans up
  cols_1 <- Matrix::colSums(out) > 0
  upr_left <- out[, cols_1, drop = FALSE]
  lwr_left <- Mat0[, cols_1, drop = FALSE]
  lwr_right <- Mat0[, !cols_1, drop = FALSE]

  invisible(list(upr_left = upr_left, 
                 lwr_left = lwr_left, 
                 lwr_right = lwr_right))
}


#' Helper of \link{map_pepprot}.
#'
#' Collapses the counts the number of peptide sequences under proteins.
#'
#' The row names in the input matrix need to be \emph{sorted}. The output is a
#' vector and will be later wrapped into a sparse matrix.
#'
#' @param mat A dgCMatrix object. Column names are SORTED protein accessions.
#'   Rownames are SORTED peptide sequences.
#' @param ncol The number of columns in \code{mat}.
#' @param peps Peptide sequences as the row names of \code{mat}.
collapse_sortpeps <- function (mat, ncol = NULL, peps = NULL) 
{
  if (is.null(peps)) 
    peps <- rownames(mat)
  
  if (is.null(ncol))
    ncol <- as.numeric(ncol(mat))

  # !!! `peps` must be SORTED !!!

  cts <- cumsum(table(peps))
  llen <- as.numeric(length(cts)) * ncol
  
  rm(list = c("peps"))
  gc()

  out <- rep.int(0L, llen)
  
  start <- 1
  end <- ncol
  
  r1 <- 1
  r2 <- 0
  
  for (i in seq_along(cts)) {
    r1 <- r2 + 1
    r2 <- cts[i]
    
    out[start:end] <- Matrix::colSums(mat[r1:r2, ])
    
    start <- start + ncol
    end <- end + ncol
    
    if (i %% 100 == 0) gc()
  }
  
  rm(list = c("mat"))
  gc()

  invisible(out)
}


#' Helper of \link{map_pepprot}.
#' 
#' Parallel version of \link{collapse_sortpeps}.
#' 
#' @param fct A factor for data splitting into chunks.
#' @param Mat A sparse matrix.
#' @inheritParams collapse_sortpeps
pcollapse_sortpeps <- function (Mat, ncol = NULL, peps = NULL, fct = 4L) 
{
  if (is.null(peps)) 
    peps <- rownames(Mat)
  
  if (is.null(ncol))
    ncol <- as.numeric(ncol(Mat))
  
  size <- local({
    dim <- dim(Mat)
    as.numeric(dim[1]) * as.numeric(dim[2])
  })
  
  n_cores <- detect_cores(16L)
  n_cores <- min(n_cores, floor(n_cores * 7E9 /size))

  # !!! `peps` must be SORTED !!!

  if (size <= 1E8 || n_cores <= 1L) {
    vec <- collapse_sortpeps(Mat, ncol, peps)
  }
  else {
    if (is.null(peps)) 
      peps <- rownames(Mat)
    
    Mats <- 
      lapply(find_group_breaks(peps, n_cores * fct), function (x) Mat[x, ])

    rm(list = c("Mat", "peps"))
    gc()
    
    cl <- parallel::makeCluster(getOption("cl.cores", n_cores))
    # don't delete, otherwise return 0L
    parallel::clusterEvalQ(cl, library(Matrix))
    vecs <- parallel::clusterApplyLB(cl, Mats, collapse_sortpeps)
    parallel::stopCluster(cl)
    rm(list = "Mats")
    gc()
    
    vec <- integer(sum(lengths(vecs)))
    len <- length(vecs)
    sta <- 0L
    
    while(len) {
      vec_1 <- vecs[[1]]
      len_1 <- length(vec_1)
      end <- sta + len_1
      
      if (is.na(end)) {
        message("Handling integer overflow.")
        
        len_1 <- as.numeric(len_1)
        vec[(sta + 1):(sta + len_1)] <- vec_1
        sta <- sta + len_1
      }
      else {
        vec[(sta + 1L):end] <- vec_1
        ok_sta <- sta + len_1
        sta <- if (is.na(sta)) sta + as.numeric(len_1) else ok_sta
      }

      vecs[1] <- NULL
      len <- len - 1L
      rm(list = c("vec_1", "len_1"))
      gc()
    }
  }
  
  message("\tCompleted matrix-to-vector conversion.")
  
  invisible(vec)
}


#' Chunksplits by groups.
#'
#' @param vec A sorted vector.
#' @param fold The number of folds.
#' @param by_rngs Logical; if TRUE return ranges of indexes or else return the
#'   indexes of breaks.
#' @examples
#' \donttest{
#' library(mzion)
#'
#' vec <- sort(rep(LETTERS[1:5], 1:5))
#' mzion:::find_group_breaks(vec, 3)
#' }
#' @return Ranges or indexes of breaks
find_group_breaks <- function (vec, fold = 5L, by_rngs = TRUE) 
{
  # !!! vec must be sorted !!!
  # or the same values form a continuum
  
  len <- length(vec)
  
  if (fold <= 1L)
    return (if (by_rngs) 1:len else len)
  
  uv <- unique(vec)
  
  ### A faster bypass; still works without bypassing
  if (FALSE) {
    nu <- length(uv)
    
    if (nu == fold) {
      if (by_rngs)
        return(lapply(uv, function (x) .Internal(which(vec == x))))
      else {
        ans <- integer(nu)
        
        for (i in 1:nu) {
          oks <- .Internal(which(vec == uv[[i]]))
          ans[[i]] <- oks[length(oks)]
        }
        
        return(ans)
      }
    }
  }
  ###
  
  tv <- lapply(uv, function (x) sum(vec == x))
  tv <- .Internal(unlist(tv, recursive = FALSE, use.names = FALSE))
  n  <- length(tv)
  cs <- cumsum(tv)
  
  if (fold >= n)
    return(if (by_rngs) mapply(`:`, c(1L, cs[1:(n-1L)] + 1L), cs) else cs)
  
  r <- ceiling(len/fold)
  dif <- r * fold -len
  
  if (dif > 0) {
    mod <- len %/% r
    fold <- if (dif %% r == 0L) mod else mod + 1L
  }
  
  rs <- 1:fold * r
  rs <- rs[rs < len] # not `<=`
  
  inds <- lapply(rs, function (x) max(which(cs <= x)))
  inds <- .Internal(unlist(inds, recursive = FALSE, use.names = FALSE))
  brs <- cs[inds]
  
  if (by_rngs) {
    ends <- c(brs, len)
    stas <- c(1L, brs + 1L)
    mapply(`:`, stas, ends, SIMPLIFY = FALSE, USE.NAMES = FALSE)
  }
  else {
    c(brs, len)
  }
}


#' Cuts proteins into groups.
#'
#' By the number of shared peptides.
#'
#' @param M A logical matrix; peptides in rows and proteins in columns.
#' @param out_path A file path to outputs.
cut_proteinGroups <- function (M = NULL, out_path = NULL) 
{
  prots <- colnames(M)
  n_prots <- length(prots)
  
  if (ncol(M) == 1L) {
    D <- matrix(1.0)
    colnames(D) <- prots
    rownames(D) <- prots
  } 
  else {
    D <- proxyC::simil(M, margin = 2) # dsTMatrix
  }
  
  rm(list = c("M"))
  gc()
  
  # n_prots > 10000L
  if (FALSE) {
    dm <- matrix(nrow = n_prots, ncol = n_prots)
    colnames(dm) <- prots
    rownames(dm) <- prots
    gc()
    
    # max_chunksize <- find_free_mem() * 3600000 / 1024
    max_chunksize <- 2500 * 40000
    nrows_per_chunk <- ceiling(max_chunksize/n_prots)
    n_chunks <- ceiling(n_prots/nrows_per_chunk)
    
    cols <- 1:n_prots
    
    for (i in 1:n_chunks) {
      start <- (i-1) * nrows_per_chunk + 1
      end <- min(i * nrows_per_chunk, n_prots)
      rows <- start:end
      
      X <- D[rows, cols] # dsTMatrix
      gc()
      X <- (X == 0) # lsyMatrix
      gc()
      
      x <- as.matrix(X)
      dm[rows, cols] <- x
      rm(list = c("X", "x"))
      gc()
    }
    
    rm(list = c("D", "start", "end", "rows", "max_chunksize", 
                "nrows_per_chunk", "n_chunks", "cols"))
    gc()
  } 
  else {
    D <- (D == 0) # lsyMatrix
    gc()
    
    dm <- as.matrix(D)
    rm(list = c("D"))
    gc()
  }
  
  # Diagonal values are `FALSE`
  # TRUE - orthogonal (without shared peptides)
  # FALSE - with shared peptides
  # 
  #             KKA1_ECOLX NP_000005 NP_000007
  # KKA1_ECOLX      FALSE      TRUE      TRUE
  # NP_000005        TRUE     FALSE      TRUE
  # NP_000007        TRUE      TRUE     FALSE
  
  # --- finds protein groups
  d <- as.dist(dm)
  rm(list = "dm")
  gc()
  
  if (length(d)) {
    hc <- hclust(d, method = "single")
    gc()
    grps <- data.frame(prot_hit_num = cutree(hc, h = .9))
  } 
  else {
    hc <- NULL
    grps <- data.frame(prot_hit_num = 1L)
    rownames(grps) <- prots
  }
  
  grps <- grps |> 
    tibble::rownames_to_column("prot_acc") |>
    dplyr::group_by(prot_hit_num) |>
    dplyr::mutate(prot_family_member = dplyr::row_number()) |>
    dplyr::ungroup()

  if (!is.null(out_path)) {
    qs::qsave(grps, file.path(out_path, "prot_grps.rds"), preset = "fast")
  }

  # stopifnot(identical(grps$prot_acc, prots))
  
  invisible(grps)
}


#' Builds manually distance sparse matrix.
#'
#' Not yet used.
#' 
#' @param M_ul The upper-left matrix.
#' @param ncols_ur The number of columns for the matrix block on the upper
#'   right.
#' @examples 
#' \donttest{
#' library(mzion)
#' # m <- mzion:::sparseD_fourquad(ul, 6)
#' }
sparseD_fourquad <- function (M_ul, ncols_ur = 0L) 
{
  nrows_ul <- ncols_ul <- ncol(M_ul)
  nrows_l <- ncols_ur
  ncols <- ncols_ul + ncols_ur
  
  M_ur <- Matrix::sparseMatrix(dims = c(nrows_ul, ncols_ur), i={}, j={})
  m_lwr <- Matrix::sparseMatrix(i = 1:nrows_l, j = (ncols_ul+1):ncols, x = 1)
  
  list(upr = cbind2(M_ul, M_ur), lwr = m_lwr)
}


#' Simplified \link[stats]{as.dist} for memory efficiency.
#' 
#' Not yet used; assumed the input is already a symmetric matrix.
#' 
#' @inheritParams stats::as.dist
as_dist <- function (m, diag = FALSE, upper = FALSE) 
{
  p <- nrow(m)
  
  ans <- m[row(m) > col(m)]
  gc()
  attributes(ans) <- NULL
  
  if (!is.null(rownames(m))) 
    attr(ans, "Labels") <- rownames(m)
  else if (!is.null(colnames(m))) 
    attr(ans, "Labels") <- colnames(m)
  
  attr(ans, "Size") <- p
  attr(ans, "call") <- match.call()
  class(ans) <- "dist"
  
  if (is.null(attr(ans, "Diag")) || !missing(diag)) 
    attr(ans, "Diag") <- diag
    
  if (is.null(attr(ans, "Upper")) || !missing(upper)) 
    attr(ans, "Upper") <- upper

  ans
}


#' Greedy set cover.
#' 
#' A bool matrix input. Output both essential sets and elements.
#' 
#' @param mat A bool matrix of protein (cols)-peptide (rows) map. 
#' 
#' @return A two-column data frame of prot_acc and pep_seq. 
greedysetcover3 <- function (mat) 
{
  # dense matrix to sparse matrix
  if (is.matrix(mat)) {
    mat <- Matrix::Matrix(mat, sparse = TRUE)
    gc()
  }
  
  if (nrow(mat) == 1L || ncol(mat) == 1L) 
    return(data.frame(prot_acc = colnames(mat), pep_seq = rownames(mat)))

  prot_acc <- NULL
  pep_seq <- NULL
  
  while(nrow(mat)) {
    max <- which.max(Matrix::colSums(mat, na.rm = TRUE))
    
    if (max == 0L) 
      break
    
    prot <- names(max)
    rows <- which(mat[, max])
    # peps <- names(rows) # name dropped if only one row
    peps <- rownames(mat)[rows]
    
    prot_acc <- c(prot_acc, rep(prot, length(peps)))
    pep_seq <- c(pep_seq, peps)
    
    mat <- mat[-rows, -max, drop = FALSE]
  }
  
  rm(list = c("mat"))
  gc()
  
  dplyr::bind_cols(prot_acc = prot_acc, pep_seq = pep_seq)
}


## matchMS
#   calc_pepmasses2 (ms1_precursors.R)
#   bin_ms1masses (bin_masses.R)
#   load_mgfs (mgf.R)
#   ms2match (msmsmatches2.R)
#   calc_pepscores (scores.R)
#   calc_pepfdr
#   post_pepfdr
#   calc_peploc (scores)
#   add_protacc (quant2.R)
#   calc_protfdr (scores.R)
#   add_rptrs (quant2.R)
#   try_psmC2Q
#     psmC2Q
#       grp_prots (quant2.R)
# 
# ======================================
# bin_masses.R
#   - bin_ms1masses
#     - (i) binTheoSeqs (small dataset)
#       - bin_theoseqs (-> export)
#         - find_ms1_cutpoints (-> export)
#     - (ii) binTheoSeqs_i (larger dataset; -> export)
#       - binTheoSeqs2 (-> export)
#         - bin_theoseqs (-> export)
#           - find_ms1_cutpoints (-> export)
# 
# mgf.R
#   - readMGF
#    - read_mgf_chunks
#     // START parallel
#     - proc_mgf_chunks_i
#      - proc_mgf_chunks
#       - proc_mgfs
#         - which_topx2
#         - index_mz
#         - sub_mgftopn
#         - integerize_ms2ints
#     // END parallel
# 
# calc_tmtint (quant2.R)
#   find_reporter_ints
#     find_reporters_ppm
#   find_int_cols
# 
# vmod_ms1_labels.R
#   - make_ms1vmod_i
#     - make_ms1_vmodsets
#       - bacth_vmods_combi
#         - make_unique_sets
#           - find_unique_sets
#     - find_intercombi2
#       - expand_grid_rows (utils_engine.R)
# 
# vmod_ms2_labels.R
#     - combi_namesiteU
#       - find_vmodposU
#         - vec_to_list
#         - sim_combn
#     - combi_namesiteM
#       - find_vmodposM
#         - vec_to_list
#         - sim_combn
#       - match_aas_indexes


# ms1_precursors.R: 
#   - calc_pepmasses2
#    - find_aa_masses
#       - calc_aamasses
#         - add_fix_masses
#         - add_var_masses
#         - parse_aamasses
#     - split_fastaseqs
#       - load_fasta2 (fastas.R)
#       - chunksplit (msmsmatches.R)
#         - make_fastapeps0 (-> export)
#           - keep_n_misses (-> export; ms1_precursors.R)
#     - distri_fpeps (fixedmods)
#     - ms1masses_bare
#       - ms1masses_noterm
#         - calcms1mass_noterm (-> export)
#           - calcms1mass_noterm_byprot (-> export)
#             - calcms1mass_noterm_bypep (-> export)
#       - roll_sum (-> export; ms1_precursors.R)
#     - find_motif_pat
#     - distri_peps (varmods)
#       - subpeps_by_vmods (dispatch.R)
#         - find_nmodtree
#           ...
#         - find_cmodtree
#           ...
#       - rm_char_in_nfirst (ms1_precursors.R)
#       - rm_char_in_nlast (ms1_precursors.R)
#     - simple_prots_peps
#     - flat_pepseqs
#     - add_term_mass
#     - helpers below
# 
# helpers at sets of realized modifications: 
#   (5, 6) "amods- tmod+ vnl- fnl+", "amods- tmod- vnl- fnl+"
#     - hms1_a0_vnl0_fnl1
#       - ms1_a0_vnl0_fnl1
#         - expand_grid_rows
#         - delta_ms1_a0_fnl1 (-> export)
#   
#  (7-8) "amods+ tmod- vnl- fnl-", "amods+ tmod+ vnl- fnl-"
#    (9-10) "amods+ tmod- vnl+ fnl-", "amods+ tmod+ vnl+ fnl-"
#    (11-12) "amods+ tmod- vnl- fnl+", "amods+ tmod+ vnl- fnl+"
#    (13-14) "amods+ tmod- vnl+ fnl+", "amods+ tmod+ vnl+ fnl+"
#         [by nested combinatorial conditions; no explicit functions]
#         - hms1_a1_vnl0_fnl0
#           - ms1_a1_vnl0_fnl0
#             - match_mvmods (vmods_ms1_labels.R)
#             - expand_grid_rows (utils_engine.R)
#             - delta_ms1_a0_fnl1 (ms1_precursors.R)

## ms2match (msmsmatches2.R)
# 
# ms2base.R: (1, 2) "amods- tmod+ vnl- fnl-", "amods- tmod- vnl- fnl-"
#   ms2match_base 
#     purge_search_space (utils_engine.R)
#       subset_theoframes (msmsmatches.R)
#     
#       frames_adv (frame-advancing)
#         gen_ms2ions_base (for specific pep_seq)
#           ms2ions_by_type (ion_ladder.R)
#             byions, czions, axions (ion_ladder.R)
#           calc_rev_ms2 (utils_engine.R)
#         search_mgf
#           find_ms2_bypep2
#             fuzzy_match_one
#             fuzzy_match_one2
#       post_frame_adv (utils_engine.R)
# 
# ms2_a0_vnl0_fnl1.R: (5, 6) "amods- tmod+ vnl- fnl+", "amods- tmod- vnl- fnl+"
#   ms2match_a0_vnl0_fnl1 
#     purge_search_space (utils_engine.R)
#     
#       frames_adv (ms2_base.R)
#         gen_ms2ions_a0_vnl0_fnl1
#           // early return
#           gen_ms2ions_base (ms2base.R)
#             calc_rev_ms2 (utils_engine.R)
#             ms2ions_by_type (ion_ladder.R)
#               byions, czions, axions (ion_ladder.R)
#             calc_rev_ms2 (utils_engine.R)
#           // regular return
#           ms2ions_by_type (ion_ladder.R)
#             byions, czions, axions (ion_ladder.R)
#         search_mgf (ms2base.R)
#           find_ms2_bypep2 (ms2base.R)
#             fuzzy_match_one (ms2base.R)
#             fuzzy_match_one2 (ms2base.R)
#       post_frame_adv (utils_engine.R)
# 
# ms2_a1_vnl0_fnl0.R: (7, 8) "amods+ tmod+ vnl- fnl-", "amods+ tmod- vnl- fnl-"
#   "ms2match_a1_vnl0_fnl0"
#     "purge_search_space" (utils_engine.R)
#     // START parallel
#     
#       "frames_adv" (ms2_base.R)
#         "gen_ms2ions_a1_vnl0_fnl0" (ms2_a1_vnl0_fnl0.R)
#           "match_mvmods" (vmods_ms1_labels.R)
#             "expand_grid_rows" (utils_engine.R)
#             "combi_namesiteU" (vmods_ms2_labels.R)
#               "find_vmodposU" (vmods_ms2_labels.R)
#                 "vec_to_list" (utils_engine.R)
#                 "sim_combn" (vmod_ms2_labels.R)
#             "combi_namesiteM" (vmods_ms2_labels.R)
#               "find_vmodposM" (vmods_ms2_labels.R)
#                 "vec_to_list" (vmods_ms2_labels.R)
#                 "sim_combn" (vmod_ms2_labels.R)
#               "match_aas_indexes" (vmods_ms2_labels.R)
#           "check_ms1_mass_vmods2" (ms2_a1_vnl0_fnl0.R)
#           "calc_rev_ms2" (utils_engine.R)
#           "calc_ms2ions_a1_vnl0_fnl0" (ms2_a1_vnl0_fnl0.R)
#             "ms2ions_by_type" (ion_ladder.R)
#               "byions", "czions", "axions"
#                 "bions_base", "yions_base",
#                 "cions_base", "zions_base", 
#                 "aions_base", "xions_base", 
#           "add_hexcodes" (ms2_a1_vnl0_fnl0.R)
#         "search_mgf" (ms2base.R)
#           "find_ms2_bypep2" (ms2base.R)
#             "fuzzy_match_one" (ms2base.R)
#             "fuzzy_match_one2" (ms2base.R)
#       "post_frame_adv" (utils_engine.R)
#     // END parallel
#       (saveRDS ion_matches_[i].rds)
# 
# ms2_a1_vnl1_fnl0.R: (9, 10) "amods+ tmod+ vnl+ fnl-", "amods+ tmod- vnl+ fnl-"
#   "ms2match_a1_vnl1_fnl0" 
#     "purge_search_space" (utils_engine.R)
#     // START parallel
#     
#       "frames_adv" (ms2_base.R)
#         "gen_ms2ions_a1_vnl1_fnl0"
#           "match_mvmods" (vmods_ms1_labels.R)
#             "expand_grid_rows" (utils_engine.R)
#             "combi_namesiteU" (vmods_ms2_labels.R)
#               "find_vmodposU" (vmods_ms2_labels.R)
#                 "vec_to_list" (utils_engine.R)
#                 "sim_combn" (vmod_ms2_labels.R)
#             "combi_namesiteM" (vmods_ms2_labels.R)
#               "find_vmodposM" (vmods_ms2_labels.R)
#                 "vec_to_list" (utils_engine.R)
#                 "sim_combn" (vmod_ms2_labels.R)
#               "match_aas_indexes" (vmods_ms2_labels.R)
#           "check_ms1_mass_vmods2" (ms2_a1_vnl0_fnl0.R)
#           "expand_grid_rows" (utils_engine.R)
#           "calc_rev_ms2" (utils_engine.R)
#           "calc_ms2ions_a1_vnl1_fnl0"
#             "ms2ions_by_type" (ion_ladder.R)
#               "byions", "czions", "axions"
#                 "bions_base", "yions_base",
#                 "cions_base", "zions_base", 
#                 "aions_base", "xions_base", 
#           "add_hexcodes_vnl2"
#         "search_mgf" (ms2base.R)
#           "find_ms2_bypep2" (ms2base.R)
#             "fuzzy_match_one" (ms2base.R)
#             "fuzzy_match_one2" (ms2base.R)
#       "post_frame_adv" (utils_engine.R)
#     // END parallel
# 
# ms2_a1_vnl0_fnl1.R: (11, 12) "amods+ tmod+ vnl- fnl+", "amods+ tmod- vnl- fnl+"
#   ms2match_a1_vnl0_fnl1 
#     purge_search_space (utils_engine.R)
#     
#       frames_adv (ms2_base.R)
#         gen_ms2ions_a1_vnl0_fnl1
#           - match_mvmods (vmods_ms1_labels.R)
##             - combi_namesiteU
#               - find_vmodposU
#                 - "sim_combn" (vmod_ms2_labels.R)
#             - combi_namesiteM
#               - find_vmodposM
#                 - "sim_combn" (vmod_ms2_labels.R)
#               - match_aas_indexes
#           check_ms1_mass_vmods2 (ms2_a1_vnl0_fnl0.R)
#           calc_rev_ms2 (utils_engine.R)
#           calc_ms2ions_a1_vnl0_fnl1
#             ms2ions_by_type (ion_ladder.R)
#               byions, czions, axions
#           add_hexcodes_fnl2
#         search_mgf (ms2base.R)
#           find_ms2_bypep2 (ms2base.R)
#             fuzzy_match_one (ms2base.R)
#             fuzzy_match_one2 (ms2base.R)
#       post_frame_adv (utils_engine.R)
# 

## calc_pepscores (scores.R)
#   calcpepsc
#   calc_pepfdr
#     calc_pepprobs_i
#       scalc_pepprobs
#         calc_probi
#           calc_probi_bypep
#             calc_probi_byvmods
#               add_seions
#               find_ppm_outer_bycombi
#               match_ex2th2
#       add_primatches

## calc_protfdr (scores.R)
#   calc_protfdr_i
#   fit_protfdr

## calc_peploc (scores.R)
#   which_topx3
#   findLocFracsDF
#   concatFracs

## (quant2.R)
#   groupProts
#     map_pepprot
#       pcollapse_sortpeps
#         collapse_sortpeps
#         find_group_breaks
#     cut_proteinGroups
#       as_lgldist
#         proteoCpp::to_lgldistC
#     greedysetcover3
#     

#################################
# mapMS2ions.R
#################################
# mapMS2ions
# match_mgf_path
# match_raw_id
# add_raw_ids
# find_secion_types
# find_psm_rows
# find_psm_rows1
# find_psm_rows2
# find_theoexpt_pair
# find_mgf_query
# combine_prisec_matches
# check_existed_psms
# get_mzion_coltypes

# batch_ms2ions
#   hbatch_ms2ions
#     mgen_ms2ions
#     make_ms2frames
#       make_ms2frames_bypars
#         create_dir
#         find_ms1_cutpoints
#         hash_frame_nums



#################################
# utils_engine.R
#################################
# which_topx
# which_topx2
# get_topn_vals
# insVal
# topx
# find_ppm_error
# find_mass_error_range
# `%+%`
# post_frame_adv
# purge_search_space
# subset_theoframes
# subset_neuloss_peps
# find_nterm_mass
# find_cterm_mass
# quick_rightjoin
# quick_leftjoin
# detect_cores
# find_free_mem
# find_mod_indexes
# is_equal_sets
# purge_decoys
# expand_grid_rows
# count_elements
# vec_to_list
# split_vec
# accumulate_char
# combi_mat

#################################
# utils_os.R
#################################
# `names_pos<-`
# find_int_cols
# ins_cols_after
# add_cols_at
# replace_cols_at
# reloc_col_after
# reloc_col_after_last
# reloc_col_after_first
# reloc_col_before
# reloc_col_before_last
# reloc_col_before_first
# find_preceding_colnm
# recur_flatten
# chunksplit
# chunksplitLB
# find_dir
# create_dir
# save_call2
# find_callarg_vals
# match_calltime
# delete_files
# is_nulllist
# add_nulllist
#################################

#################################
# utils_ui.R (user interfaces)
#################################
# calc_monopeptide
# calc_monopep
# check_aaseq
# calc_ms2ionseries
# calc_ms2ions
# unique_mvmods
# vmods_elements
# find_intercombi
#################################



#################################
# fastas.R
#################################
# read_fasta
# write_fasta
# load_fasta
# load_fasta2
# find_acc_type
#################################



#################################
# unimods.R
#################################
# parse_unimod
# find_unimod
# table_unimods
#################################



#################################
# dispatch.R
#################################
# find_pos_site
# find_protntsite
# find_anyntsite
# ...
# subpeps_by_vmods
# find_nmodtree
# find_cmodtree
# subset_by_prps
#################################



#######################################################################
## MS2 permutations
#
# aas - "H" "Q" "G" "V" "M" "N" "V" "G" "M" "G" "Q" "K" "M" "N" "S"
# 
# Ma - Carbamidomethyl (M)
# Mb - Carbamyl (M)
# N - Deamidated (N)
# 
# Level 1 - sets of MS1 labels (lists of 6)
# 
# Level 2 - permutation of Level-1 with  the positions of residues in aas
#    (lists of 6, the number of total permutations in `n2_perm`; 
# 
#       Carbamidomethyl (M) Carbamyl (M) Deamidated (N) n1_perm n2_perm
# L1.1                   1            1              1      6      36
# L1.2                   2            1              1     12      24
# L1.3                   1            2              1     12      24
# L1.4                   1            1              2     12      36
# L1.5                   2            1              2     30      30
# L1.6                   1            2              2     30      30
#######################################################################



## (Tentative) same-site rules: no additive varmods
# 
# No additive terminal mods (fixed/fixed; var/var; fixed/var)!!!
# 
# (1) No more than one fixedmod on the same residue or N/C terminal.
#   [N] fixed "Oxidation (M)" + fixed "Carbamidomethyl (M)"
#   [N] fixed "TMT6plex (N-term)" + fixed "Acetyl (Protein N-term)"
# 
#   # otherwise additive
#   [Y] fixed "Oxidation (M)" + fixed "TMT6plex (N-term)" with M on the N-term
# (2) OK different variable mods to the same residue at different sites
#   [Y] variable "Oxidation (M) @3" + variable "Carbamidomethyl (M) @4"
#   [Y] variable "Oxidation (M)" + variable "TMT6plex (N-term)" with M on the N-term
# (3) no conflict between fixedmods and variable mods (additive)
#   [Y] fixed "Oxidation (M)" + variable "TMT6plex (N-term)" with M on the N-term
#   [N] fixed "Oxidation (M) @3" + variable "Carbamidomethyl (M) @3"
#   [N] fixed "TMT6plex (N-term)" + variable "Acetyl (Protein N-term)"



#' Adds secondary ions of b0, y0 etc.
#' 
#' @param ms2s A vector of theoretical MS2 m-over-z values.
#' @inheritParams matchMS
add_seions <- function (ms2s, type_ms2ions = "by") 
{
  # proton <- 1.00727647
  # h2o <- 18.010565
  # nh3 <- 17.026549
  
  len <- length(ms2s)
  
  if (type_ms2ions == "by") {
    bs <- ms2s[1:(len/2)]
    ys <- ms2s[(len/2+1):len]
    
    b2s <- (bs + 1.00727647)/2
    bstars <- bs - 17.026549
    bstar2s <- (bstars + 1.00727647)/2
    b0s <- bs - 18.010565
    b02s <- (b0s + 1.00727647)/2
    
    y2s <- (ys + 1.00727647)/2
    ystars <- ys - 17.026549
    ystar2s <- (ystars + 1.00727647)/2
    y0s <- ys - 18.010565
    y02s <- (y0s + 1.00727647)/2
    
    c(b2s, bstars, bstar2s, b0s, b02s, y2s, ystars, ystar2s, y0s, y02s)
    # c(bstars, b0s, ystars, y0s, b2s, bstar2s, b02s, y2s, ystar2s, y02s)
  } 
  else if (type_ms2ions == "ax") {
    as <- ms2s[1:(len/2)]
    xs <- ms2s[(len/2+1):len]
    
    a2s <- (as + 1.00727647)/2
    astars <- as - 17.026549
    astar2s <- (astars + 1.00727647)/2
    a0s <- as - 18.010565
    a02s <- (a0s + 1.00727647)/2
    
    x2s <- (xs + 1.00727647)/2
    
    c(a2s, astars, astar2s, a0s, a02s, x2s)
    # c(astars, a0s, a2s, astar2s, a02s, x2s)
  } 
  else if (type_ms2ions == "cz") {
    cs <- ms2s[1:(len/2)]
    zs <- ms2s[(len/2+1):len]
    
    c2s <- (cs + 1.00727647)/2
    z2s <- (zs + 1.00727647)/2
    
    c(c2s, z2s)
  }
}


#' Matches two lists without making a data frame
#' 
#' Not currently used. 
#' 
#' @param a The left vector.
#' @param b The right vector.
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' a <- c(3, 4, 1, 2, 5)
#' b <- 2
#' 
#' mzion:::list_leftmatch(a, b)
#' }
list_leftmatch <- function (a, b) 
{
  ord <- order(a, decreasing = TRUE)
  a <- a[ord]
  
  oks <- a %in% b
  
  b2 <- rep(NA_real_, length(a))
  b2[oks] <- b
  
  b2
}


#' Helper for score calculations
#'
#' By the positions of variable modifications.
#' 
#' @section Model: 
#' N - the total number of features (white and black balls) \cr
#' k - the number of sampled features \cr
#' m - the numbers of theoretical features (white balls) \cr
#' n - the number of noise (black balls) \cr
#' 
#' * Subtracts \code{m} and the counts of secondary b0, y0 matches etc. from noise
#' ((N < m) -> (n < 0L); OK if n < 0L) \cr
#' * \code{ith} and \code{ith2} in ascending order, \code{iex} and \code{iex2} in adaptive order \cr
#' * One-to-one correspondence: \code{ith} <-> \code{iex}; \code{ith2} <-> \code{iex2} \cr
#' 
#' @section Check matches:
#' \code{abs(df2$theo[df2$ith] - expt_moverzs[df2$iex]) <= ppm_ms2} \cr
#' \code{identical(df2$int[df2$ith], expt_ints[df2$iex])}
#' 
#' @section y:
#' y$expt - experimental m/z's \cr
#' y$int  - experimental intensities (primary) \cr
#' y$int2 - experimental intensiteis (secondary) \cr
#' y$theo - matched theoretical m/z's \cr
#' y$idx  - values: the indexes in theoretical sequence (df$ith)
#'          positions: the position in expt_moverzs
#' 
#' @param df Two lists of \code{theo} and matched \code{expt} m-over-z.
#' @param nms The names (character strings indicating the names and position of
#'   variable modifications).
#' @param burn_ins The range of burn-ins where inputs will be excluded from
#'   probablity assessments.
#' @inheritParams calc_probi
#' @import dplyr
#' @importFrom purrr map
#' @importFrom tibble tibble
#' @importFrom fastmatch fmatch %fin%
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' ##
#' pep <- "YGPQYGHPPPPPPPPDYGPHADSPVLMVYGLDQSK"
#' nms <- unlist(stringr::str_split(pep, ""))
#' 
#' theos <- c(393.2335,450.2550,547.3078,675.3663,838.4297,
#'            895.4511,1032.5100,1129.5628,1226.6156,1323.6683,
#'            1420.7211,1517.7739,1614.8266,1711.8794,1808.9322,
#'            1923.9591,2087.0224,2144.0439,2241.0967,2378.1556,
#'            2449.1927,2564.2196,2651.2517,2748.3044,2847.3728,
#'            2960.4569,3091.4974,3190.5658,3353.6291,3410.6506,
#'            3523.7347,3638.7616,3766.8202,3853.8522,4211.1101,
#'            376.2757,463.3078,591.3663,706.3933,819.4773,
#'            876.4988,1039.5621,1138.6306,1269.6710,1382.7551,
#'            1481.8235,1578.8763,1665.9083,1780.9353,1851.9724,
#'            1989.0313,2086.0840,2143.1055,2306.1688,2421.1958,
#'            2518.2485,2615.3013,2712.3541,2809.4068,2906.4596,
#'            3003.5124,3100.5651,3197.6179,3334.6768,3391.6983,
#'            3554.7616,3682.8202,3779.8729,3836.8944,3999.9577)
#' 
#' expts <- c(NA,NA,NA,675.36646,838.42981,895.45056,1032.51025,
#'            NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,
#'            NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,376.27603,463.30823,
#'            591.36676,706.39380,819.47552,876.50018,1039.56287,
#'            NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,
#'            NA,NA,NA,NA,NA,NA,NA,NA,NA,NA,NA)
#' 
#' names(expts) <- names(theos) <- c(nms, rev(nms))
#' 
#' ith <- c(4,5,6,7,36,37,38,39,40,41,42)
#' iex <- c(42,57,72,93,20,26,36,44,56,65,96)
#' ith <- as.integer(ith)
#' iex <- as.integer(iex)
#' m <- length(ith)
#' 
#' df <- list(theo = theos, expt = expts, ith = ith, iex = iex, m = m)
#' 
#' expt_moverzs <- c(126.05530,126.12798,127.12505,127.13139,128.12843,
#'                   128.13475,129.13177,129.13806,130.13516,130.14140,
#'                   131.13841,136.07588,143.11812,195.11308,221.09239,
#'                   230.17036,235.14416,244.09303,271.12891,376.27603,
#'                   377.28003,384.21320,400.54648,441.89435,442.22861,
#'                   463.30823,464.31158,502.76166,503.26221,516.75928,
#'                   517.26062,531.28296,565.28522,565.78705,574.33997,
#'                   591.36676,592.36957,613.81238,614.31451,648.34070,
#'                   669.80933,675.36646,696.86902,706.39380,707.39600,
#'                   713.32672,713.82715,714.33093,761.85156,762.33771,
#'                   762.85907,810.37610,810.88019,811.38434,811.88660,
#'                   819.47552,838.42981,846.49664,846.99695,855.74426,
#'                   859.91162,867.92706,868.43024,868.93225,876.50018,
#'                   877.50354,878.75262,884.42273,884.75665,885.09052,
#'                   885.42700,895.45056,896.45435,908.43860,908.94092,
#'                   909.44440,916.95612,949.79688,950.13049,950.46545,
#'                   950.79791,962.48212,964.98084,965.48273,987.49255,
#'                   987.82599,988.16028,988.50989,1004.51562,1005.52985,
#'                   1013.56659,1031.50378,1032.51025,1033.51355,1034.51636,
#'                   1039.56287,1040.56641,1062.48096,1063.48511,1161.55078)
#' 
#' expt_ints <- c(16921,29468,36904,28121,37829,23537,39307,36194,25192,33532,
#'                26551,91477,15182,24720,17471,50430,14282,14084,39681,99581,
#'                13900,52774,16289,17160,14127,115919,22728,29658,16358,77851,
#'                28386,18132,49422,32030,39155,78946,18520,25765,13728,19688,
#'                13347,12440,14183,95484,26643,20027,14759,13589,14318,18829,
#'                12227,19829,16826,31208,22442,18285,14859,31434,13299,16824,
#'                12843,21389,21024,12491,69633,25811,14946,28967,55172,29773,
#'                17955,40642,19888,35676,35222,14974,12466,46216,86923,48637,
#'                30824,12961,26805,31218,36352,49433,40495,31233,40643,18265,
#'                12316,25125,202241,90877,20903,40353,15008,31908,22554,13634)
#' 
#' mzion:::calc_probi_byvmods(df, nms = "0000000", expt_moverzs, expt_ints, N = 404)
#' 
#' ## 
#' pep <- "LFEEDEREK"
#' nms <- unlist(stringr::str_split(pep, ""))
#' 
#' theos <- c(343.2543,490.3227,619.3653,748.4079,863.4348,992.4774,
#'            1148.5785,1277.6211,1634.8790,376.2757,505.3183,661.4194,
#'            790.4620,905.4890,1034.5316,1163.5742,1310.6426,1423.7266)
#' 
#' expts <- c(343.25455,490.32318,619.36487,NA,863.43542,NA,NA,
#'            NA,NA,376.27606,505.31924,NA,NA,NA,NA,NA,NA,NA)
#' 
#' names(expts) <- names(theos) <- c(nms, rev(nms))
#' 
#' ith <- c(1,2,3,5,10,11)
#' iex <- c(39,57,73,92,41,59)
#' ith <- as.integer(ith)
#' iex <- as.integer(iex)
#' m <- length(ith)
#' 
#' df <- list(theo = theos, expt = expts, ith = ith, iex = iex, m = m)
#' 
#' expt_moverzs <- c(115.08694,120.08116,126.12807,127.12512,127.13135,
#'                   128.12845,128.13469,129.13177,129.13800,130.13510,
#'                   130.14134,131.13840,132.14159,136.07581,158.09254,
#'                   173.15001,175.11917,175.15672,176.15985,186.15297,
#'                   188.15988,229.16661,230.17041,231.17406,248.18094,
#'                   249.18439,251.11345,269.12421,273.21259,287.19257,
#'                   291.17169,301.20755,301.24423,305.16913,315.25937,
#'                   322.70038,331.21384,331.71515,343.25455,361.71152,
#'                   376.27606,377.24023,377.27985,386.72955,387.22852,
#'                   395.23312,395.73502,396.23633,406.26596,407.27014,
#'                   433.20410,453.24899,470.30963,470.81094,472.27225,
#'                   487.30685,490.32318,499.81451,505.31924,517.77081,
#'                   519.27625,519.77734,551.32843,551.63458,551.82617,
#'                   551.86658,551.96796,552.32220,552.36621,591.37250,
#'                   592.34991,609.33093,619.36487,633.33594,634.33850,
#'                   635.34485,636.34497,644.39349,648.31799,655.82574,
#'                   706.39349,740.87518,741.37933,747.88177,748.39014,
#'                   748.88788,749.38904,749.89026,750.39099,791.45404,
#'                   819.47766,863.43542,864.43774,943.52075,944.51770,
#'                   945.51129,946.51874,947.52203,948.52100,1342.65393)
#' 
#' expt_ints <- c(8508,28501,194673,190890,160012,223742,147623,260388,198943,164580,
#'                149024,165036,7306,21035,8098,11560,35686,8953,15544,10771,
#'                17617,7660,227328,16612,88320,10075,8968,9123,20253,7351,
#'                49432,11202,8013,65251,21790,11174,48669,10941,40270,24887,
#'                81536,9488,9709,28670,8442,7151,185877,54537,9754,7176,
#'                10297,12091,42045,9021,14507,11520,27411,7991,45770,7927,
#'                18996,9520,111456,46109,49064,59457,41824,36185,9619,9065,
#'                8708,21105,26995,13041,8674,11169,14089,7697,9047,10710,
#'                12763,7125,7321,7483,31612,18050,26134,31474,11331,8789,
#'                8672,65913,25918,17819,34367,15767,15221,14225,7419,7284)
#' 
#' mzion:::calc_probi_byvmods(df, nms = "0000000", expt_moverzs, expt_ints, N = 434)
#' }
calc_probi_byvmods <- function (df, nms, expt_moverzs, expt_ints, # expt_charges, 
                                max_len = 40L, N = 20000L, type_ms2ions = "by", 
                                topn_ms2ions = 150L, ppm_ms2 = 20L, 
                                soft_secions = FALSE, burn_ins = 1:2, 
                                min_ms2mass = 115L, d2 = 1E-5, 
                                tally_ms2ints = TRUE, digits = 4L) 
{
  df_theo <- df[["theo"]]
  m <- length(df_theo)

  ## df2
  tt2  <- add_seions(df_theo, type_ms2ions = type_ms2ions)
  
  if (FALSE) {
    m2 <- m/2L
    
    if (type_ms2ions == "by") {
      # idxes_mul <- c(1, 3, 5, 6, 8, 10)
      # idxes_one <- c(2, 4, 7, 9)
      rng_mul <- c(1:m2, (2 * m2 + 1):(3 * m2), 
                   (4 * m2 + 1):(5 * m2), (5 * m2 + 1):(6 * m2), 
                   (7 * m2 + 1):(8 * m2), (9 * m2 + 1):(10 * m2))
      rng_one <- c((m2 + 1):(2 * m2), (3 * m2 + 1):(4 * m2), 
                   (6 * m2 + 1):(7 * m2), (8 * m2 + 1):(9 * m2))
    } else if (type_ms2ions == "ax") {
      # idxes_mul <- c(1, 3, 5, 6)
      # idxes_one <- c(2, 4)
      rng_mul <- c(1:m2, (2 * m2 + 1):(3 * m2), 
                   (4 * m2 + 1):(5 * m2), (5 * m2 + 1):(6 * m2))
      rng_one <- c((m2 + 1):(2 * m2), (3 * m2 + 1):(4 * m2))
    } else if (type_ms2ions == "cz") {
      # idxes_one <- NULL
      # idxes_mul <- c(1, 2)
      rng_mul <- seq_len(m)
      rng_one <- NULL
    }
    
    tt2_one <- tt2[rng_one]
    tt2_mul <- tt2[rng_mul]
    expt_mul <- expt_one <- expt_moverzs
    
    # FALSE & NA -> FALSE; TRUE & NA -> NA
    nna <- !is.na(expt_charges)
    expt_one[nna & (expt_charges > 1L)] <- NA_integer_
    expt_mul[nna & (expt_charges == 1L)] <- NA_integer_
    df2_one <- match_ex2th2(expt_one, tt2_one, min_ms2mass, d2)
    df2_mul <- match_ex2th2(expt_mul, tt2_mul, min_ms2mass, d2)
  }

  df2  <- match_ex2th2(expt_moverzs, tt2, min_ms2mass, d2)
  ith2 <- df2[["ith"]]
  iex2 <- df2[["iex"]]

  ## 1. int2 (secondary intensities)
  len <- length(df2[["expt"]])
  df2[["int"]] <- rep_len(NA_real_, len)
  df2[["int"]][ith2] <- expt_ints[iex2] # works if iex2 contains NA
  
  facs <- rep(seq_len(len/m), each = m)
  int2 <- .Internal(split(df2[["int"]], as.factor(facs)))
  int2 <- Reduce(`%+%`, int2)
  
  # df2[["int"]]
  # NA     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
  # NA     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
  # NA     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA  48669 185877  12091   7927     NA  10710     NA
  # NA     NA   7697     NA     NA     NA     NA     NA     NA     NA     NA  11174   8442     NA     NA     NA     NA     NA
  # NA  11520     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA  28670     NA     NA     NA     NA     NA
  # 
  # int2
  #  0  11520   7697      0      0      0      0      0      0      0      0  59843 222989  12091   7927      0  10710      0

  ## 2. y 
  ith <- df[["ith"]]
  iex <- df[["iex"]]
  df[["int"]] <- rep_len(NA_integer_, m)
  df[["int"]][ith] <- expt_ints[iex]

  nudbl <- rep_len(NA_real_, topn_ms2ions)
  nuint <- rep_len(NA_integer_, topn_ms2ions)
  y <- list(expt = expt_moverzs, int = expt_ints, theo = nudbl, idx = nuint, int2 = nuint)
  y[["theo"]][iex] <- df_theo[ith]
  y[["idx"]][iex] <- ith
  
  # if (tally_ms2ints) {
  ## 3. join `int2` to `y`
  y_idx  <- y[["idx"]]
  ok_iex <- .Internal(which(!is.na(y_idx)))
  y_ith  <- y_idx[ok_iex]
  y[["int2"]][ok_iex] <- int2[y_ith]
  
  ## 4. collapses `int2` to `int`
  y[["int"]] <- y[["int"]] %+% y[["int2"]]
  y[["idx"]] <- y[["int2"]] <- NULL
  # }

  if (soft_secions) {
    ok_int2 <- .Internal(which(int2 > 0L & is.na(df[["int"]])))
    
    if (length(ok_int2)) {
      ok_iex2 <- iex2[match(ok_int2, ith2 %% m)]
      ok_iex2 <- ifelse(is.na(ok_iex2), m, ok_iex2)
      y[["int"]][ok_iex2] <- int2[ok_int2]
      # need to adjust the theoreticals, e.g., (df_theo[ok_int2] + 1.0078)/2; 
      # for simplicity use expt_moverzs, as long as they are not NA
      y[["theo"]][ok_iex2] <- expt_moverzs[ok_iex2]
    }
  }

  ## 5. arrange by "-int"
  # removes chimeric interference
  chim <- df$chim
  
  if (!is.null(chim)) {
    # chim <- chim[!chim %in% iex2]
    # currently use the longest sequences of iex in find_iexunv 
    #   -> some iex may be in chim
    chim <- chim[!chim %in% c(iex, iex2)]
    y[["int"]][chim] <- .1
  }
  
  ord_int <- order(y[["int"]], decreasing = TRUE, method = "radix", na.last = TRUE)
  y_theo  <- y[["theo"]][ord_int]
  maxi    <- .Internal(which(!is.na(y_theo)))
  maxi    <- maxi[length(maxi)]
  y_theo  <- y_theo[1:maxi]

  ## 6. mutate(k = row_number(), x = k - cumsum(is.na(theo)))
  k <- 1:maxi
  x <- k - cumsum(is.na(y_theo))
  
  ## 7. filter(!is.na(theo))
  # note: x <= k <= x + n
  ok_y <- !is.na(y_theo)
  k    <- k[ok_y]
  x    <- x[ok_y]

  ## 8. Probability
  # excludes unstable burn-in scores
  # burn_ins is different to min_n_ms2
  #   min_n_ms2 - guard against low-quality specta with low number of matches
  #   burn_ins  - guard against unstable scores
  x_ <- x[-burn_ins]
  k_ <- k[-burn_ins]
  
  if (length(x_)) {
    N_ <- floor(N*m/max_len/2L + topn_ms2ions)
    prs <- stats::dhyper(x = x_, m = m, n = N_, k = k_)
    pr  <- min(prs, na.rm = TRUE)
  }
  else
    pr <- .5

  ## outputs
  list(pep_ivmod = nms, 
       pep_prob  = pr, 
       pri_matches = list(df), 
       sec_matches = list(df2))
}


#' Helper for score calculations
#'
#' By peptides.
#' 
#' @param nms The names (of peptides).
#' @inheritParams calc_probi
#' @import dplyr
#' @importFrom purrr map2
#' @importFrom tibble tibble
calc_probi_bypep <- function (mts, nms, expt_moverzs, expt_ints, # expt_charges, 
                              max_len = 40L, N = 20000L, 
                              type_ms2ions = "by", topn_ms2ions = 150L, 
                              ppm_ms2 = 20L, soft_secions = FALSE, 
                              min_ms2mass = 115L, d2 = 1E-5, 
                              tally_ms2ints = TRUE, 
                              digits = 4L) 
{
  ## for different positions: $TNLAMMR$`0000500`, $TNLAMMR$`0000050`
  #    the same `pep_seq`, `pep_calc_mr` for different mod positions
  #    different `pep_ivmod`, `pep_prob`, `pri_matches`, `sec_matches`
  
  # NAMES are hexcodes: 0000000
  res <- mapply(calc_probi_byvmods, 
                mts, names(mts), # names: vmods
                MoreArgs = list(
                  expt_moverzs = expt_moverzs, 
                  expt_ints = expt_ints, 
                  # expt_charges = expt_charges, 
                  max_len = max_len, 
                  N = N, 
                  type_ms2ions = type_ms2ions, 
                  topn_ms2ions = topn_ms2ions, 
                  ppm_ms2 = ppm_ms2, 
                  soft_secions = soft_secions, 
                  burn_ins = c(1:2),
                  min_ms2mass = min_ms2mass, 
                  d2 = d2, 
                  tally_ms2ints = tally_ms2ints, 
                  digits = digits
                ), 
                SIMPLIFY = FALSE,
                USE.NAMES = TRUE)
  
  len <- length(res)
  out <- vector("list", len)
  
  for (i in 1:len) {
    res_i <- res[[i]]
    
    out[[i]] <- list(
      pep_seq = nms,
      theo_ms1 = attr(mts, "theo_ms1", exact = TRUE), 
      pep_ivmod = res_i$pep_ivmod, 
      pep_mod_group = attr(mts, "pep_mod_group", exact = TRUE), 
      pep_prob = res_i$pep_prob, 
      pri_matches = res_i["pri_matches"], 
      sec_matches = res_i["sec_matches"]
    )
  }
  
  out
}


#' Helper for score calculations
#'
#' @param mts Nested data frame of \code{theo} and matched \code{expt} m-over-z.
#' @param expt_moverzs Nested list of match and unmatched experimental m-over-z.
#' @param expt_ints Nested list of match and unmatched experimental intensity.
#' @param N Numeric; the number of MS2 features in an MGF query.
#' @param d2 Bin width in ppm divided by 1E6.
#' @inheritParams matchMS
#' @inheritParams calc_pepscores
#' @import dplyr
#' @importFrom purrr map
calc_probi <- function (mts, expt_moverzs, expt_ints, # expt_charges, 
                        max_len = 40L, 
                        N = 20000L, type_ms2ions = "by", topn_ms2ions = 150L, 
                        ppm_ms2 = 20L, soft_secions = FALSE, 
                        min_ms2mass = 115L, d2 = 1E-5, 
                        tally_ms2ints = TRUE, digits = 4L) 
{
  out <- mapply(
    calc_probi_bypep, 
    mts, names(mts), # names: pep_seqs
    MoreArgs = list(
      expt_moverzs = expt_moverzs, 
      expt_ints = expt_ints, 
      # expt_charges = expt_charges, 
      max_len = max_len, 
      N = N, 
      type_ms2ions = type_ms2ions, 
      topn_ms2ions = topn_ms2ions, 
      soft_secions = soft_secions, 
      ppm_ms2 = ppm_ms2, 
      min_ms2mass = min_ms2mass, 
      d2 = d2, 
      tally_ms2ints = tally_ms2ints, 
      digits = digits
    ), 
    SIMPLIFY = FALSE,
    USE.NAMES = FALSE)
  
  out <- .Internal(unlist(out, recursive = FALSE, use.names = FALSE))
}


#' Calculates peptide scores by single MGF entries (scan numbers).
#' 
#' Each entry corresponds to a row in \code{ion_matches.rds}.
#' 
#' @param entry A row of data.
#' @param d2 Bin width in ppm divided by 1E6.
#' @inheritParams matchMS
#' @inheritParams calc_pepscores
#' @import purrr
scalc_pepprobs <- function (entry, topn_ms2ions = 150L, type_ms2ions = "by", 
                            ppm_ms2 = 20L, soft_secions = FALSE, 
                            max_len = 40L, n_ms2_bg = 20000L, min_ms2mass = 115L, 
                            d2 = 1E-5, tally_ms2ints = TRUE, digits = 4L) 
{
  # only one experimental set of values and thus `[[1]]`
  expt_moverzs <- entry[["pep_ms2_moverzs"]][[1]]
  expt_ints <- entry[["pep_ms2_ints"]][[1]]
  # expt_charges <- entry[["ms2_charges"]][[1]]

  ## matches between theoreticals and experimentals
  
  # [[1]] --- `entry$matches` (always at level-one and can be unlisted)
  # [[1]]$AMMASIGR --- `entry$matches[[1]]` (1:i peptides)
  # [[1]]$AMMASIGR$`00500000` --- `entry$matches[[1]][[1]]` (1:j positions)
  # A tibble: 18 x 2
  # theo  expt
  # <dbl> <dbl>
  #   1  175.   175.
  #   2  230.   230.
  #   3  301.   301.
  # 
  # [[1]]$TNLAMMR
  # [[1]]$TNLAMMR$`0000500`
  # A tibble: 16 x 2
  # theo  expt
  # <dbl> <dbl>
  #   1  175.   175.
  #   2  230.   230.
  #   3  331.   331.
  # 
  # [[1]]$TNLAMMR$`0000050`
  # A tibble: 16 x 2
  # theo  expt
  # <dbl> <dbl>
  #   1  175.   175.
  #   2  230.   230.
  #   3  331.   331.
  
  # (flattens by one level as is a list-column)
  mts <- entry[["matches"]][[1]]
  topn_ms2ions <- min(topn_ms2ions, entry$pep_n_ms2[[1]])

  out <- calc_probi(mts = mts, 
                    expt_moverzs = expt_moverzs, 
                    expt_ints = expt_ints, 
                    # expt_charges = expt_charges, 
                    max_len = max_len, 
                    N = n_ms2_bg, 
                    type_ms2ions = type_ms2ions, 
                    topn_ms2ions = topn_ms2ions, 
                    ppm_ms2 = ppm_ms2, 
                    soft_secions = soft_secions, 
                    min_ms2mass = min_ms2mass, 
                    d2 = d2, 
                    tally_ms2ints = tally_ms2ints, 
                    digits = digits)

  uniq_id <- .Internal(unlist(entry$uniq_id, recursive = FALSE, use.names = FALSE))
  
  out <- lapply(out, function (x) {
    x[["uniq_id"]] <- uniq_id
    x
  })

  invisible(out)
}


#' Calculates the scores of peptides at an \code{aa_masses}.
#' 
#' @param df Resulted data from ion matches.
#' @param d2 Bin width in ppm divided by 1E6.
#' @inheritParams matchMS
#' @inheritParams calc_pepscores
calc_pepprobs_i <- function (df, topn_ms2ions = 150L, type_ms2ions = "by", 
                             ppm_ms2 = 20L, soft_secions = FALSE, 
                             max_len = 40L, n_ms2_bg = 20000L, 
                             out_path = "~/mzion/outs", min_ms2mass = 115L, 
                             tally_ms2ints = TRUE, 
                             d2 = 1E-5, digits = 4L) 
{
  if (is.data.frame(df)) {
    n_rows <- nrow(df)
    
    if (!n_rows) {
      null_out <- data.frame(
        pep_seq = as.character(), 
        theo_ms1 = as.numeric(),
        pep_ivmod = as.character(), 
        pep_mod_group = as.integer(),
        pep_prob = as.numeric(), 
        pri_matches = list(), 
        sec_matches = list() , 
        uniq_id = as.character()# , 
        # pep_scan_num = as.integer()
      )
      
      return(null_out)
    }
    
    df <- split.data.frame(df, seq_len(n_rows))
  }

  df <- lapply(df, scalc_pepprobs, 
               topn_ms2ions = topn_ms2ions, 
               type_ms2ions = type_ms2ions, 
               ppm_ms2 = ppm_ms2, 
               soft_secions = soft_secions, 
               max_len = max_len, 
               n_ms2_bg = n_ms2_bg, 
               min_ms2mass = min_ms2mass, 
               d2 = d2, 
               tally_ms2ints = tally_ms2ints, 
               digits = digits)
  
  ## do not reverse decoy "pep_seq"s until after adding protein accessions
  # if (sum(nas <- is.na(df[["pep_ivmod"]])))
  #   df[nas, "pep_seq"] <- reverse_seqs(df[nas, ][["pep_seq"]])
  df <- .Internal(unlist(df, recursive = FALSE, use.names = FALSE))
  df <- dplyr::bind_rows(df)
}


#' Calculates the scores of peptides.
#'
#' @param tally_ms2ints Logical; tally MS2 intensities or not.
#' @param n_ms2_bg The count of MS2 background noises.
#' @inheritParams matchMS
#' @import parallel
calc_pepscores <- function (topn_ms2ions = 150L, type_ms2ions = "by", 
                            target_fdr = 0.01, 
                            min_len = 7L, max_len = 40L, ppm_ms2 = 20L, 
                            maxn_mdda_precurs = 1L, n_ms2_bg = 20000L, 
                            tally_ms2ints = TRUE, soft_secions = FALSE, 
                            out_path = NULL, mgf_path = NULL, min_ms2mass = 115L, 
                            maxn_vmods_per_pep = 5L, maxn_sites_per_vmod = 3L,
                            maxn_vmods_sitescombi_per_pep = 64L, minn_ms2 = 6L, 
                            ppm_ms1 = 20L, quant = "none", ppm_reporters = 10, 
                            fasta = NULL, acc_type = NULL, acc_pattern = NULL, 
                            fixedmods = NULL, varmods = NULL, 
                            enzyme = "trypsin_p", maxn_fasta_seqs = 200000L, 
                            maxn_vmods_setscombi = 64L, 
                            add_ms2theos = FALSE, add_ms2theos2 = FALSE, 
                            add_ms2moverzs = FALSE, add_ms2ints = FALSE, 
                            digits = 4L) 
{
  on.exit(
    if (exists(".savecall", envir = fun_env)) {
      if (.savecall) {
        save_call2(path = file.path(out_path, "Calls"), fun = fun)
      }
    }, add = TRUE)

  if (file.exists(file_aa <- file.path(out_path, "aa_masses_all.rds")))
    aa_masses_all <- qs::qread(file_aa)
  else if (file.exists(file_aa <- file.path(.path_bin, "aa_masses_all.rds")))
    aa_masses_all <- qs::qread(file_aa)
  else
    stop("Amino-acid look-ups not found: ", file_aa)

  sc_path <- file.path(out_path, "temp")
  tempdir <- create_dir(file.path(out_path, "sc_temp"))
  
  ## Check cached current
  fun <- as.character(match.call()[[1]])
  fun_env <- environment()
  fml_nms <- names(formals(fun))
  fs_im  <- find_targets(out_path, pattern = "^ion_matches_")$files
  n_im <- length(fs_im)

  if (!n_im) 
    stop("Results of ion matches not found with pattern.")
  
  if (n_im != length(aa_masses_all)) {
    stop("Unequal number of modules between ion matches and amino-acid lookups.", 
         "\nDelete `ion_meatches_` under `temp` and restart.")
  }

  args_except <- c("fdr_type", "maxn_mdda_precurs", "n_ms2_bg")

  fml_incl <- if (length(args_except))
    fml_nms[!fml_nms %in% args_except]
  else
    fml_nms

  message("[x] For reprocessing (with new score function) ", 
          "delete cached 'pepscores_[...]' and 'calc_pepscores.rda'.\n")
  
  cache_pars <- find_callarg_vals(time = NULL, 
                                  path = file.path(out_path, "Calls"), 
                                  fun = paste0(fun, ".rda"), 
                                  args = fml_incl) 
  cache_pars <- cache_pars[sort(names(cache_pars))]
  call_pars  <- mget(fml_incl, envir = fun_env, inherits = FALSE) 
  call_pars  <- call_pars[sort(names(call_pars))]

  if (identical(cache_pars, call_pars)) {
    fs_sc <- list.files(sc_path, pattern = "^prescores_")
    n_sc  <- length(fs_sc)
    fi_sp <- file.path(sc_path, "total_splits.rds")
    n_sp  <- if (file.exists(fi_sp)) qs::qread(fi_sp) else -1L
    
    if (n_sc == n_sp) {
      if (grepl("^tmt", quant)) {
        fs_tmt <- list.files(sc_path, pattern = "^reporters_\\d+_\\d+")
        
        if (length(fs_tmt) == n_sc) {
          message("Found cached 'prescores_[...]' and 'reporters_[...]'.")
          .savecall <- FALSE
          return(NULL)
        }
        else {
          message("Recalculating peptide scores (not all 'reporters_' found).")
        }

        rm(list = "fs_tmt")
      }
      else {
        message("Found cached 'prescores_[...]'.")
        .savecall <- FALSE
        return(NULL)
      }
    } 
    else {
      message("Recalculating peptide scores (not all 'pepscores_' found).")
    }

    rm(list = c("fs_sc", "n_sc", "fi_sp", "n_sp"))
  }
  else {
    message("Calculating peptide scores.")
    dir.create(sc_path, recursive = TRUE, showWarnings = FALSE)
    rm(list = c("cache_pars", "call_pars"))
  }

  pep_fmod_all  <- unlist(lapply(aa_masses_all, attr, "fmods", exact = TRUE))
  pep_vmod_all  <- unlist(lapply(aa_masses_all, attr, "vmods", exact = TRUE))
  rm(list = c("file_aa", "aa_masses_all"))
  
  d2 <- calc_threeframe_ppm(ppm_ms2) * 1E-6
  
  split_im(files = fs_im, sc_path = sc_path, tempdir = tempdir, 
           maxn_mdda_precurs = maxn_mdda_precurs)
  im_path <- tempdir
  fs_im <- list.files(im_path, pattern = "^ion_matches_")
  
  n_cores <- detect_cores(48L) - 1L
  cl <- parallel::makeCluster(getOption("cl.cores", n_cores), 
                              outfile = file.path(sc_path, "log.txt"))

  parallel::clusterExport(cl, list("calcpepsc", 
                                   "calc_pepprobs_i", "scalc_pepprobs", 
                                   "calc_probi", "calc_probi_bypep", 
                                   "calc_probi_byvmods", "add_seions", 
                                   "find_ppm_outer_bycombi", "match_ex2th2", 
                                   "hcalc_tmtint", "calc_tmtint", 
                                   "find_reporter_ints", 
                                   "add_primatches"), 
                          envir = environment(mzion::matchMS))

  parallel::clusterApplyLB(
    cl, fs_im, calcpepsc, 
    im_path = im_path, 
    pep_fmod_all = pep_fmod_all, 
    pep_vmod_all = pep_vmod_all, 
    maxn_mdda_precurs = maxn_mdda_precurs, 
    topn_ms2ions = topn_ms2ions, 
    type_ms2ions = type_ms2ions, 
    ppm_ms2 = ppm_ms2, 
    max_len = max_len, 
    n_ms2_bg = max(topn_ms2ions * 5L, n_ms2_bg), 
    soft_secions = soft_secions, 
    out_path = out_path, 
    min_ms2mass = min_ms2mass, 
    d2 = d2, 
    tally_ms2ints = tally_ms2ints, 
    add_ms2theos = add_ms2theos, 
    add_ms2theos2 = add_ms2theos2, 
    add_ms2moverzs = add_ms2moverzs, 
    add_ms2ints = add_ms2ints,
    quant = quant, 
    ppm_reporters = ppm_reporters, 
    digits = digits)

  parallel::stopCluster(cl)
  
  move_scfiles(type = "list_table", tempdir, sc_path)
  move_scfiles(type = "prescores",  tempdir, sc_path)
  move_scfiles(type = "reporters",  tempdir, sc_path)

  qs::qsave(length(list.files(sc_path, pattern = "^prescores")), 
            file.path(sc_path, "total_splits.rds"))
  
  message("Completed peptide scores at: ", Sys.time())
  unlink(tempdir, recursive = TRUE)
  .savecall <- TRUE

  invisible(NULL)
}


#' Split \code{ion_matches_.rds}
#'
#' For RAM efficiency
#'
#' @param files File names such as \code{ion_matches_1.rds, ion_matches_2.rds}
#' @param sc_path A file path to \code{ion_matches_1.rds}
#' @param tempdir A temporary directory
#' @param col_key The column key for continuous chunk splitting. The same value
#'   under the col_key will remain in the same chunk.
#' @param max_size The maximum file size
#' @inheritParams matchMS
split_im <- function (files, sc_path, tempdir, maxn_mdda_precurs = 1L, 
                      col_key = "orig_scan", max_size = 10000000) 
{
  for (file in files) {
    fi   <- file.path(sc_path, file)
    size <- file.size(fi)
    
    if (size > max_size) {
      n_chunks <- size %/% max_size + 1L
      df <- qs::qread(fi)
      
      if (maxn_mdda_precurs > 1L && col_key %in% names(df)) {
        df  <- df[order(df[[col_key]]), ]
        dfs <- split(df, find_chunkbreaks(df[[col_key]], n_chunks))
      }
      else {
        dfs <- chunksplit(df, n_chunks, "row")
      }

      nms <- paste0(gsub("(.*)\\.rds$", "\\1", file), "_", 1:n_chunks, ".rds")
      mapply(qs::qsave, dfs, file.path(tempdir, nms), MoreArgs = list(preset = "fast"))
    }
    else {
      nm <- paste0(gsub("(.*)\\.rds$", "\\1", file), "_1", ".rds")
      file.copy(fi, file.path(tempdir, nm), overwrite = TRUE)
    }
  }
}


#' Order fractions
#' 
#' @param type The type of files.
#' @param tempdir A temporary directory containing the files.
order_fracs <- function (type = "list_table", tempdir)
{
  files <- list.files(tempdir, pattern = paste0("^", type, "_\\d+_\\d+.*"))
  idxes <- as.integer(gsub(paste0("^", type, "_(\\d+).*"), "\\1", files))
  fracs <- as.integer(gsub(paste0("^", type, "_\\d+_(\\d+).*"), "\\1", files))
  fracs <- split(fracs, idxes)
  files <- split(files, idxes)
  idxes <- split(idxes, idxes)
  
  ords  <- lapply(fracs, order)
  idxes <- names(files)
  mapply(function (x, y) x[y], files, ords, SIMPLIFY = FALSE)
}


#' Order fractions
#' 
#' Three layers: module_notch_frac
#' 
#' @param type The type of files.
#' @param tempdir A temporary directory containing the files.
order_fracs3 <- function (type = "list_table", tempdir)
{
  files <- list.files(tempdir, pattern = paste0("^", type, "_\\d+_\\d+_\\d+.*"))
  l1 <- as.integer(gsub(paste0("^", type, "_(\\d+).*"), "\\1", files))
  l2 <- as.integer(gsub(paste0("^", type, "_\\d+_(\\d+).*"), "\\1", files))
  l3 <- as.integer(gsub(paste0("^", type, "_\\d+_\\d+_(\\d+).*"), "\\1", files))
  
  df <- data.frame(l1 = l1, l2 = l2, l3 = l3)
  df <- dplyr::arrange(df, l1, l2, l3)
  df$fs <- with(df, paste(l1, l2, l3, sep = "_"))
  df$fs <- paste0(type, "_", df$fs, ".rds")
  
  split(df$fs, df$l1)
}


#' Combines results from fractions
#' 
#' @param files A list of file names.
#' @param tempdir A temporary directory containing the files.
#' @param is_notched Logical; is a search with MS1 notches or not.
#' @param sc_path An output path
combine_fracs <- function (files, tempdir, sc_path, is_notched = FALSE)
{
  out_nm <- gsub("_\\d+\\.rds$", ".rds", files[[1]])
  df <- lapply(file.path(tempdir, files), qs::qread)
  df <- dplyr::bind_rows(df)
  
  # uniq_id does not contain information of pep_ms1_offset
  if (is_notched)
    df <- df[!duplicated.default(df[["uniq_id"]]), ]

  qs::qsave(df, file.path(sc_path, out_nm))
}


#' Moves score-related files from \code{tempdir} to \code{sc_path}
#' 
#' @param type The type of files
#' @param tempdir A temporary directory containing the files
#' @param sc_path A target directory
move_scfiles <- function (type = "list_table", tempdir, sc_path)
{
  files <- list.files(tempdir, pattern = paste0("^", type, "_\\d+_\\d+.*"))
  file.rename(file.path(tempdir, files), file.path(sc_path, files))
}


#' Find the index or name of decoy results.
#' 
#' @param pattern The pattern of files.
#' @inheritParams matchMS
find_decoy <- function (out_path, pattern = "^ion_matches_") 
{
  pat <- paste0(pattern, "rev_[0-9]+\\.rds$")
  list_d <- list.files(path = file.path(out_path, "temp"), pattern = pat)

  if (length(list_d) > 1L) {
    warning("More than one decoy results found; ", 
            "'", list_d[1], "' will be used.", call. = FALSE)
    list_d <- list_d[1]
  }
  
  nms_d <- gsub(paste0(pattern, "(rev_[0-9]+)\\.rds$"), "\\1", list_d)
  
  list(idxes = nms_d, files = list_d)
}


#' Find the index or name of target results.
#' 
#' @param out_path An output path.
#' @param pattern The pattern of files.
find_targets <- function (out_path, pattern = "^ion_matches_") 
{
  list_t <- list.files(path = file.path(out_path, "temp"), 
                       pattern = paste0(pattern, "[0-9]+\\.rds$"))
  nms_t  <- gsub(paste0(pattern, "(\\d+)\\.rds$"), "\\1", list_t)
  ord    <- order(as.integer(nms_t))
  nms_t  <- nms_t[ord]
  list_t <- list_t[ord]
  
  list(idxes = nms_t, files = list_t)
}


#' Helper of \link{calc_pepscores}.
#'
#' @param file A file name of \code{ion_matches_}
#' @param im_path A temporary file path to \code{ion_matches_}
#' @param pep_fmod_all Attributes of \code{pep_fmod} from \code{aa_masses_all}
#' @param pep_vmod_all Attributes of \code{pep_vmod} from \code{aa_masses_all}
#' @param d2 Bin width in ppm divided by 1E6
#' @inheritParams matchMS
#' @inheritParams calc_pepscores
calcpepsc <- function (file, im_path, pep_fmod_all, pep_vmod_all, 
                       maxn_mdda_precurs = 1L, max_len = 40L, n_ms2_bg = 20000L, 
                       topn_ms2ions = 150L, type_ms2ions = "by", 
                       ppm_ms2 = 20L, soft_secions = FALSE, 
                       out_path = NULL, min_ms2mass = 115L, d2 = 1E-5, 
                       tally_ms2ints = TRUE, add_ms2theos = FALSE, 
                       add_ms2theos2 = FALSE, add_ms2moverzs = FALSE, 
                       add_ms2ints = FALSE, quant = "none", ppm_reporters = 10, 
                       digits = 4L) 
{
  msg <- paste0("\tModule: ", file)
  write(msg, stdout())

  cols_a  <- c("pep_scan_num", "raw_file")
  cols_b  <- c("pep_ms2_moverzs", "pep_ms2_ints", # "ms2_charges", 
               "pri_matches", "sec_matches")
  cols_lt <- c(cols_a, cols_b)
  
  cols_sc <- c("pep_seq", "pep_n_ms2", "pep_scan_title", "pep_exp_mz", 
               "pep_exp_mr", "pep_tot_int", "pep_exp_z", "pep_ret_range", 
               "pep_scan_num", "raw_file", "pep_mod_group", "pep_ms1_offset", 
               "pep_fmod", "pep_vmod", "pep_isdecoy", "pep_calc_mr", 
               "pep_ivmod", "pep_prob", "pep_len", 
               "pep_ms2_moverzs", "pep_ms2_ints", 
               "pep_ms2_theos", "pep_ms2_theos2", 
               "pep_ms2_exptints", "pep_ms2_exptints2", 
               "pep_n_matches", "pep_n_matches2", 
               "pep_ms2_deltas", "pep_ms2_ideltas", "pep_ms2_iexs", 
               "pep_ms2_deltas2", "pep_ms2_ideltas2", "pep_ms2_iexs2", 
               "pep_ms2_deltas_mean", "pep_ms2_deltas_sd", "pep_ms2_ideltas.")

  df <- qs::qread(file.path(im_path, file))
  n_rows <- nrow(df)
  idx <- gsub("^ion_matches_(.*)\\.rds$", "\\1", file)
  
  if (!n_rows) {
    idx <- gsub("_\\d+", "", idx) # idx = "1_1"
    
    dfa <- data.frame(matrix(ncol = length(cols_lt), nrow = 0L))
    colnames(dfa) <- cols_lt
    qs::qsave(dfa, 
              file.path(out_path, "temp", paste0("list_table_", idx, ".rds")), 
              preset = "fast")
    
    dfb <- data.frame(matrix(ncol = length(cols_sc), nrow = 0L))
    colnames(dfb) <- cols_sc
    qs::qsave(dfb, 
              file.path(out_path, "temp", paste0("pepscores_",  idx, ".rds")), 
              preset = "fast")
    
    return (dfb)
  }

  df[["uniq_id"]] <- paste(df[["pep_scan_num"]], df[["raw_file"]], 
                           df[["pep_ms1_offset"]], sep = "@")
  esscols <- c("pep_ms2_moverzs", "pep_ms2_ints", # "ms2_charges", 
               "matches", "pep_n_ms2", "uniq_id")

  ## chimeric intensity value masking
  if (maxn_mdda_precurs > 1L) {
    df$gid <- paste(df[["orig_scan"]], df[["raw_file"]], df[["pep_ms1_offset"]], 
                    sep = "@")
    dfs <- split(df, df$gid)
    rows <- lapply(dfs, function (x) nrow(x) == 1L)
    rows <- unlist(rows, recursive = FALSE, use.names = FALSE)
    df <- dplyr::bind_rows(dfs[rows])
    df$gid <- NULL
    dfm <- dfs[!rows]
    rm(list = c("dfs", "rows"))
    
    if (lenm <- length(dfm)) {
      dfm <- lapply(dfm, addChim)
      prs <- lapply(dfm, calc_pepprobs_i, 
                    topn_ms2ions = topn_ms2ions, 
                    type_ms2ions = type_ms2ions, 
                    ppm_ms2 = ppm_ms2,
                    soft_secions = soft_secions, 
                    max_len = max_len, 
                    n_ms2_bg = n_ms2_bg, 
                    out_path = out_path, 
                    min_ms2mass = min_ms2mass, 
                    d2 = d2, 
                    tally_ms2ints = tally_ms2ints, 
                    digits = digits)
      prs <- dplyr::bind_rows(prs)
      dfm <- dplyr::bind_rows(dfm)

      if ("matches" %in% names(dfm)) 
        dfm <- dfm[, -which(names(dfm) == "matches"), drop = FALSE]
      
      if ("pep_mod_group" %in% names(dfm) && "pep_mod_group" %in% names(prs))
        prs[["pep_mod_group"]] <- NULL
      
      dfm <- quick_rightjoin(dfm, prs, "uniq_id")
      rm(list = c("prs"))
    }
  }
  else {
    lenm <- 0L
  }

  path_df2 <- file.path(im_path, paste0("df2_", idx, ".rds"))
  df2 <- df[, -which(names(df) %in% esscols), drop = FALSE]
  qs::qsave(df2, path_df2, preset = "fast")
  df <- df[, esscols, drop = FALSE]
  rm(list = "df2")

  probs <- calc_pepprobs_i(
    df,
    topn_ms2ions = topn_ms2ions, 
    type_ms2ions = type_ms2ions, 
    ppm_ms2 = ppm_ms2,
    soft_secions = soft_secions, 
    max_len = max_len, 
    n_ms2_bg = n_ms2_bg, 
    out_path = out_path, 
    min_ms2mass = min_ms2mass, 
    d2 = d2, 
    tally_ms2ints = tally_ms2ints, 
    digits = digits)
  
  ## Reassemble `df`
  if ("matches" %in% names(df)) 
    df <- df[, -which(names(df) == "matches"), drop = FALSE]
  
  df2 <- qs::qread(path_df2)
  df  <- dplyr::bind_cols(df, df2)
  rm(list = c("df2", "path_df2"))

  if ("pep_mod_group" %in% names(df) && "pep_mod_group" %in% names(probs))
    probs[["pep_mod_group"]] <- NULL
  
  df <- quick_rightjoin(df, probs, "uniq_id")
  rm(list = c("probs"))

  if (lenm)
    df <- dplyr::bind_rows(df, dfm[, names(df)])

  df <- df[, -which(names(df) == "uniq_id"), drop = FALSE]
  rm(list = "dfm")

  df <- post_pepscores(df)
  
  hcalc_tmtint(df = df[, c("raw_file", "pep_mod_group", "pep_scan_num", 
                           "rptr_moverzs", "rptr_ints")], 
               quant = quant, 
               ppm_reporters = ppm_reporters, 
               idx = idx, 
               out_path = im_path)

  qs::qsave(df[, cols_lt, drop = FALSE], 
            file.path(im_path, paste0("list_table_", idx, ".rds")), 
            preset = "fast")
  
  qs::qsave(df, 
            file.path(im_path, paste0("prescores_",  idx, ".rds")), 
            preset = "fast")

  invisible(NULL)
}


#' Finds the indexes of experimental matches.
#' 
#' For a single row.
#' 
#' @param mi An i-th match.
find_iexunv <- function (mi)
{
  ## may contain decoy entries: "00000700 (2)" NA
  # NA
  # X   NA
  # X
  # NA  NA

  nms <- lapply(mi, names)
  mi <- mapply(function (x, y) x[!is.na(y)], mi, nms, 
               USE.NAMES = FALSE,SIMPLIFY = FALSE)
  mi <- mi[lengths(mi) > 0L]
  len <- length(mi)
  
  if (!len)
    return(NULL)
  
  iexs <- vector("list", len)
  
  # go through all peptides under a match
  for (i in 1:len) {
    ps <- mi[[i]]

    if (length(ps) == 1L) {
      iexs[[i]] <- ps[[1]]$iex
    }
    else {
      # to be more accurate, should use union
      iexs[[i]] <- ps[[which.max(lapply(ps, `[[`, "m"))]]$iex
    }
  }

  unique(.Internal(unlist(iexs, recursive = FALSE, use.names = FALSE)))
}


#' Preparation for scoring of chimeric spectra.
#' 
#' @param df A data frame for scoring.
addChim <- function (df)
{
  # i - matches
  #   j - peptides
  #     k - vmods
  #     (targets, decoys)
  
  df$gid <- NULL
  mts <- df$matches

  iexs <- lapply(mts, find_iexunv)
  unv <- unique(.Internal(unlist(iexs, recursive = FALSE, use.names = FALSE)))
  
  # for-loop to keep attributes
  for (i in seq_along(mts)) {
    mi <- mts[[i]]
    iex <- iexs[[i]]
    yi <- unv[!unv %in% iex]
    
    if (!length(yi))
      next

    # by peptides
    for (j in seq_along(mi)) {
      p <- mi[[j]]
      nms <- names(p)

      # by multiple vmods
      for (k in seq_along(p)) {
        # decoy
        if (is.na(nms[[k]]))
          next

        p[[k]]$chim <- yi
      }

      mi[[j]] <- p
    }
    
    mts[[i]] <- mi
  }
  
  df$matches <- mts

  df
}


#' Helper of \link{add_primatches}
#' 
#' @param is_notched Logical; is a search with MS1 notches or not.
#' @inheritParams matchMS
#' @inheritParams calc_pepscores
hadd_primatches <- function (out_path = NULL, is_notched = FALSE, 
                             add_ms2theos = FALSE, add_ms2theos2 = FALSE, 
                             add_ms2moverzs = FALSE, add_ms2ints = FALSE) 
{
  # the same as those in calcpepsc
  cols_sc <- c("pep_seq", "pep_n_ms2", "pep_scan_title", "pep_exp_mz", "pep_exp_mr", 
               "pep_tot_int", "pep_exp_z", "pep_ret_range", "pep_scan_num", "raw_file", 
               "pep_mod_group", "pep_ms1_offset", 
               "pep_fmod", "pep_vmod", "pep_isdecoy", 
               "pep_calc_mr", "pep_ivmod", "pep_prob", "pep_len", 
               "pep_ms2_moverzs", "pep_ms2_ints", 
               "pep_ms2_theos", "pep_ms2_theos2", 
               "pep_ms2_exptints", "pep_ms2_exptints2", 
               "pep_n_matches", "pep_n_matches2", 
               "pep_ms2_deltas", "pep_ms2_ideltas", "pep_ms2_iexs", 
               "pep_ms2_deltas2", "pep_ms2_ideltas2", "pep_ms2_iexs2", 
               "pep_ms2_deltas_mean", "pep_ms2_deltas_sd", 
               
               # for localization scores
               "pep_ms2_ideltas.")
  
  message("Adding theoretical MS2 m/z and intensity values: ", Sys.time())
  
  tempdir <- file.path(out_path, "temp")
  files <- list.files(path = tempdir, pattern = "^prescores_\\d+.*\\.rds$")
  n_cores <- min(detect_cores(48L) - 1L, len <- length(files))
  
  if (n_cores <= 1L) {
    for (i in 1:len) {
      add_primatches(files[[i]], tempdir = tempdir, 
                     add_ms2theos = add_ms2theos, 
                     add_ms2theos2 = add_ms2theos2, 
                     add_ms2moverzs = add_ms2moverzs, 
                     add_ms2ints = add_ms2ints)
    }
  }
  else {
    cl <- parallel::makeCluster(getOption("cl.cores", n_cores))
    parallel::clusterExport(cl, list("add_primatches"), 
                            envir = environment(mzion::matchMS))
    parallel::clusterApplyLB(cl, files, 
                             add_primatches, 
                             tempdir = tempdir, 
                             add_ms2theos = add_ms2theos, 
                             add_ms2theos2 = add_ms2theos2, 
                             add_ms2moverzs = add_ms2moverzs, 
                             add_ms2ints = add_ms2ints)
    parallel::stopCluster(cl)
  }

  ms_files <- order_fracs(type = "ms2info", tempdir)
  
  mapply(function (fis, idx) {
    df <- lapply(fis, function (x) qs::qread(file.path(tempdir, x)))
    df <- dplyr::bind_rows(df)
    df[["pep_isdecoy"]] <- ifelse(is.na(df[["pep_ivmod"]]), TRUE, FALSE)
    df <- dplyr::rename(df, pep_calc_mr = theo_ms1)
    
    if (!all(cols_sc %in% names(df)))
      stop("Developer needs to update the columns of peptide scores.")
    
    df <- df[, cols_sc, drop = FALSE]
    
    qs::qsave(df, file.path(out_path, "temp", paste0("pepscores_", idx, ".rds")), 
              preset = "fast")
  }, ms_files, names(ms_files))
  
  lapply(order_fracs("reporters", tempdir), 
         combine_fracs, tempdir, tempdir, is_notched)
  
  message("Completed theoretical MS2 m/z and intensity values: ", Sys.time())

  invisible(NULL)
}


#' Adds sequences of primary and secondary matches.
#'
#' Applied to both targets and decoys as feature "pep_ms2_deltas_mean" may be
#' used in SVM-Percolator.
#'
#' @param file The file name of a temporary score file.
#' @param tempdir The temporary directory for score results.
#' @inheritParams matchMS
add_primatches <- function (file = NULL, tempdir = NULL, add_ms2theos = FALSE, 
                            add_ms2theos2 = FALSE, add_ms2moverzs = FALSE, 
                            add_ms2ints = FALSE) 
{
  df <- qs::qread(file.path(tempdir, file))
  
  if (!add_ms2moverzs) df[["pep_ms2_moverzs"]] <- NA_character_
  if (!add_ms2ints)    df[["pep_ms2_ints"]] <- NA_character_
  
  df <- dplyr::mutate(df, 
                      pep_ms2_theos = NA_character_, 
                      pep_ms2_theos2 = NA_character_, 
                      
                      pep_ms2_exptints = NA_character_, 
                      pep_ms2_exptints2 = NA_character_, 
                      
                      pep_n_matches = NA_integer_, 
                      pep_n_matches2 = NA_integer_, 
                      
                      pep_ms2_deltas = NA_character_, 
                      pep_ms2_ideltas = NA_character_,
                      pep_ms2_iexs = NA_character_,
                      pep_ms2_deltas2 = NA_character_, 
                      pep_ms2_ideltas2 = NA_character_, 
                      pep_ms2_iexs2 = NA_character_,
                      
                      pep_ms2_deltas_mean = NA_real_, 
                      pep_ms2_deltas_sd = NA_real_, 
                      
                      pep_ms2_ideltas. = NA_integer_)

  # unlist from list table
  pris <- lapply(df$pri_matches, `[[`, 1)
  secs <- lapply(df$sec_matches, `[[`, 1)
  len <- length(pris)
  
  m2s <- m1s <- iys2 <- iys1 <- sd1s <- me1s <- vector("list", len)

  th1s <- lapply(pris, `[[`, "theo")
  ex1s <- lapply(pris, `[[`, "expt") # contains NA
  iy1s <- lapply(pris, `[[`, "int") # contains NA
  ps1s. <- ps1s <- lapply(pris, `[[`, "ith")
  es1s <- lapply(pris, `[[`, "iex")
  th2s <- lapply(secs, `[[`, "theo")
  ex2s <- lapply(secs, `[[`, "expt") # contains NA
  iy2s <- lapply(secs, `[[`, "int") # contains NA
  ps2s <- lapply(secs, `[[`, "ith") # can be integer(0)
  es2s <- lapply(secs, `[[`, "iex") # can be integer(0)
  
  ds1s <- mapply(function (x, y, p) round((x[p] - y[p]) * 1E3, digits = 2L), 
                 ex1s, th1s, ps1s, USE.NAMES = FALSE)
  ds2s <- mapply(function (x, y, p) round((x[p] - y[p]) * 1E3, digits = 2L), 
                 ex2s, th2s, ps2s, USE.NAMES = FALSE)
  me1s <- lapply(ds1s, function (x) round(mean(x), digits = 2L))
  sd1s <- lapply(ds1s, function (x) round(stats::sd(x), digits = 2L))
  
  iy1s <- mapply(function (x, y) stringi::stri_join(x[y], collapse = ";"), 
                 iy1s, ps1s, USE.NAMES = FALSE)
  ds1s <- stringi::stri_join_list(ds1s, sep = ';')
  es1s <- stringi::stri_join_list(es1s, sep = ';')
  # does the collapsion at the least
  ps1s <- stringi::stri_join_list(ps1s, sep = ';')
  
  rows <- lengths(ds2s) > 0L
  ds2s[rows] <- stringi::stri_join_list(ds2s, sep = ';')
  
  rows <- lengths(es2s) > 0L
  es2s[rows] <- stringi::stri_join_list(es2s[rows], sep = ';')
  # es2s <- unname(es2s)
  
  iy2s <- mapply(function (x, y) stringi::stri_join(x[y], collapse = ";"), 
                 iy2s, ps2s, USE.NAMES = FALSE)
  # does the collapsion at the least
  rows <- lengths(ps2s) > 0L
  ps2s[rows] <- stringi::stri_join_list(ps2s[rows], sep = ';')
  # ps2s <- unname(ps2s)
  
  m1s <- lapply(pris, `[[`, "m")
  m2s <- lapply(secs, `[[`, "m")
  
  df[["pep_ms2_deltas"]] <- ds1s
  df[["pep_ms2_deltas2"]] <- ds2s
  df[["pep_ms2_deltas_mean"]] <- me1s
  df[["pep_ms2_deltas_sd"]] <- sd1s
  
  df[["pep_ms2_ideltas"]] <- ps1s
  df[["pep_ms2_ideltas2"]] <- ps2s
  df[["pep_ms2_iexs"]] <- es1s
  df[["pep_ms2_iexs2"]] <- es2s
  df[["pep_n_matches"]] <- m1s
  df[["pep_n_matches2"]] <- m2s
  df[["pep_ms2_exptints"]] <- iys1
  df[["pep_ms2_exptints2"]] <- iys2
  
  # for localization
  df[["pep_ms2_ideltas."]] <- ps1s.

  if (add_ms2theos) df$pep_ms2_theos <- collapse_vecs(lapply(pris, `[[`, "theo"))
  if (add_ms2theos2) df$pep_ms2_theos2 <- collapse_vecs(lapply(secs, `[[`, "theo"))
  if (add_ms2moverzs) df$pep_ms2_moverzs <- collapse_vecs(df$pep_ms2_moverzs)
  if (add_ms2ints) df$pep_ms2_ints <- collapse_vecs(df$pep_ms2_ints)
  
  qs::qsave(df, file.path(tempdir, gsub("^prescores", "ms2info", file)), 
            preset = "fast")

  invisible(NULL)
}


#' Pastes vectors to character strings.
#'
#' @param vecs A list of vectors.
#' @param nm The name of sub list in \code{vecs}.
#' @param sep A separator.
#' @param digits A non-negative integer; the number of decimal places to be
#'   used. The default is 4.
collapse_vecs <- function (vecs, nm = "theo", sep = ";", digits = 4L) 
{
  vecs <- lapply(vecs, round, digits = digits)
  
  ans <- lapply(vecs, function (v) 
    .Internal(paste0(list(v), collapse = sep, recycle0 = FALSE)))

  do.call(rbind, ans)
}


#' Cleanups post \link{calc_pepscores}.
#' 
#' @param df A results after pep_scores.
post_pepscores <- function (df) 
{
  df[["pep_scan_num"]] <- as.character(df[["pep_scan_num"]])
  df[["pep_len"]] <- stringr::str_length(df[["pep_seq"]])
  df[["pep_scan_title"]] <- as.character(df[["pep_scan_title"]])
  df[["pep_exp_mz"]] <- as.numeric(df[["pep_exp_mz"]])
  df[["pep_exp_mz"]] <- as.numeric(df[["pep_exp_mz"]])
  df[["pep_tot_int"]] <- as.numeric(df[["pep_tot_int"]])
  df[["pep_exp_z"]] <- as.character(df[["pep_exp_z"]])
  df[["pep_ret_range"]] <- as.integer(df[["pep_ret_range"]])
  df[["pep_n_ms2"]] <- as.integer(df[["pep_n_ms2"]])
  df[["pep_fmod"]] <- as.character(df[["pep_fmod"]])
  df[["pep_vmod"]] <- as.character(df[["pep_vmod"]])
  
  invisible(df)
}


#' Finds the cut-off in peptide scores for a given \code{target_fdr}.
#' 
#' Assume normal distribution for log(decoy_score).
#' 
#' @param td A data frame of target-decoy results at a given peptide length.
#' @inheritParams matchMS
find_pepscore_co1 <- function (td, target_fdr = 0.01) 
{
  target <- dplyr::filter(td, !pep_isdecoy)
  decoy  <- dplyr::filter(td, pep_isdecoy)
  
  nt <- nrow(target)
  nd <- nrow(decoy)
  
  if (nd <= 5L) 
    return(NA_real_)
  
  n <- nt + nd
  lambt <- nt / n
  lambd <- 1 - lambt
  
  vecd <- log2(decoy$pep_score)
  sigmad <- sd(vecd, na.rm = TRUE)
  mud <- mean(vecd, na.rm = TRUE)
  
  if (is.na(sigmad)) 
    return(NA_real_)
  
  xs <- seq(mud + sigmad, mud + 3*sigmad, 0.014355293)
  
  for (i in seq_along(xs)) {
    y <- (1 - pnorm(xs[i], mud, sigmad)) * nd / n
    
    if (y <= target_fdr) 
      break
  }
  
  2^(xs[i])
}


#' Finds the cut-off in peptide scores for a given \code{target_fdr}.
#' 
#' Assume log-normal for decoy scores.
#' 
#' @param td A data frame of target-decoy results at a given peptide length.
#' @inheritParams matchMS
find_pepscore_co2 <- function (td, target_fdr = 0.01) 
{
  target <- dplyr::filter(td, !pep_isdecoy)
  decoy  <- dplyr::filter(td, pep_isdecoy)
  
  nt <- nrow(target)
  nd <- nrow(decoy)
  
  if (nd <= 5L) 
    return(NA_real_)
  
  n <- nt + nd
  lambt <- nt / n
  lambd <- 1 - lambt
  
  vecd <- decoy$pep_score
  sigmad <- sd(vecd, na.rm = TRUE)
  mud <- mean(vecd, na.rm = TRUE)
  
  if (is.na(sigmad)) 
    return(NA_real_)
  
  xs <- seq( mud + 4*sigmad, mud + sigmad, -.1)
  
  for (i in seq_along(xs)) {
    y <- (1 - plnorm(xs[i], mud, sigmad, lower.tail = FALSE)) * nd / n
    
    if (y >= target_fdr) 
      break
  }
  
  xs[i]
}


#' Helper of \link{calc_pepfdr}.
#'
#' Calculates the probability cut-off for target-decoy pairs at a given peptide
#' length.
#' 
#' @param td A target-decoy pair.
#' @param len Numeric; the length of peptides.
#' @param fct_score A factor to convert p-values to scores.
#' @inheritParams matchMS
probco_bypeplen <- function (len, td, fdr_type = "protein", target_fdr = 0.01, 
                             min_pepscores_co = 0, fct_score = 5, out_path) 
{
  td <- dplyr::filter(td, pep_len == len)
  td <- sub_td_byfdrtype(td = td, fdr_type = fdr_type, fct_score = fct_score)
  count <- nrow(td)
  
  if (count < (1 / target_fdr)) {
    if (count <= 10L)
      return(NA_real_)
    
    best_co <- tryCatch(
      (find_pepscore_co1(td, target_fdr) + find_pepscore_co2(td, target_fdr))/2,
      error = function(e) NA
    )
    
    prob_co <- 10^(-best_co/fct_score)
    names(prob_co) <- count
    
    return(prob_co)
  }

  # ---
  rows <- which(td$fdr <= target_fdr)
  
  if (length(rows)) {
    max_pr <- max(td[["fdr"]], na.rm = TRUE)
    # the last row since pep_score in a descending order
    row <- max(rows, na.rm = TRUE)
    # row <- rows[length(rows)]
    score_co <- td[["pep_score"]][row]

    ### guard against very low score_co
    if (FALSE) {
      lwr <- if (len <= 10L) {
        31 - len * target_fdr * 200
      }
      else if (len <= 15L) {
        29 - 11:15 * target_fdr * 160
      }
      else {
        2
      }

      lwr <- ifelse(lwr <= 5, 5, lwr)
      # if (len <= 15L) score_co <- max(score_co, lwr)
    }
    ####
    
    # fittings (the data range may affect the fitting)
    df <- data.frame(x = td[["pep_score"]], y = td[["fdr"]])
    
    if (max_pr <= target_fdr) {
      fit <- suppressWarnings(
        tryCatch(
          stats::nls(y ~ SSasymp(x, Asym, R0, lrc), data = df, 
              control = list(tol = 1e-03, warnOnly = TRUE), 
              algorithm = "port"), 
          error = function (e) NA, 
          warning = function (w) NA))

      if (all(is.na(fit))) {
        fit <- suppressWarnings(
          tryCatch(
            stats::nls(y ~ SSlogis(x, Asym, xmid, scal), data = df, 
                control = list(tol = 1e-03, warnOnly = TRUE), 
                algorithm = "port"), 
            error = function (e) NA, 
            warning = function (w) NA))
      }
    }
    else {
      fit <- suppressWarnings(
        tryCatch(
          stats::nls(y ~ SSlogis(x, Asym, xmid, scal), data = df, 
              control = list(tol = 1e-03, warnOnly = TRUE), 
              algorithm = "port"), 
          error = function (e) NA, 
          warning = function (w) NA))

      if (all(is.na(fit))) {
        fit <- suppressWarnings(
          tryCatch(
            stats::nls(y ~ SSasymp(x, Asym, R0, lrc), data = df, 
                control = list(tol = 1e-03, warnOnly = TRUE), 
                algorithm = "port"), 
            error = function (e) NA, 
            warning = function (w) NA))
      }
    }

    if (!all(is.na(fit))) {
      min_x <- min(target_fdr, min(df$x, na.rm = TRUE))
      max_x <- max(target_fdr, max(df$x, na.rm = TRUE))
      del_x <- max_x - min_x
      
      step <- if (del_x > 10) 
        .25
      else if (del_x > 1)
        .02
      else
        .01

      newx <- seq(min_x, max_x, by = step)
      newy <- predict(fit, data.frame(x = newx)) |> `names<-`(newx)
      
      # NA if not existed
      score_co2 <- as.numeric(names(which(newy <= target_fdr)[1]))
      score_co2 <- max(score_co2, min_pepscores_co)

      ### guard against vert low score_co2
      # if (len <= 15L) score_co2 <- max(score_co2, lwr)
      ###
      
      best_co <- min(score_co, score_co2, na.rm = TRUE)

      if (FALSE) {
        try(
          local({
            pdf(file.path(out_path, "temp", paste0("probco_peplen@", len, ".pdf"))) 
            plot(y ~ x, df, xlab = "pep_score", col = "blue", ylab = "FDR", pch = 19)
            title(main = paste0("Peptide length ", len))
            lines(newx, newy, col = "red", type = "b")
            abline(h = target_fdr, col = "green", lwd = 3, lty = 2)
            legend("topright", legend = c("Raw", "Smoothed"), 
                   col = c("blue", "red"), pch = 19, bty = "n")
            legend("center", pch = 19, 
                   legend = c(paste0("Best: ", round(best_co, 2L)), 
                              paste0("Smoothed: ", round(score_co2, 2L))))
            dev.off()
          })
        )
      }

      rm(list = c("newx", "newy", "score_co", "score_co2"))
    } 
    else {
      best_co <- score_co
    }
    
    rm(list = c("df", "fit"))
    
    prob_co <- 10^(-best_co/fct_score)
  }
  else {
    best_co <- tryCatch(
      (find_pepscore_co1(td, target_fdr) + find_pepscore_co2(td, target_fdr))/2,
      error = function(e) NA)
    
    if (is.na(best_co)) {
      best_co <- Inf
    }

    prob_co <- 10^(-best_co/fct_score)
  }
  
  names(prob_co) <- count

  invisible(prob_co)
}


#' Subsets targets and decoys by fdr_type.
#' 
#' @param td A data frame of targets and decoys.
#' @param fct_score A factor to convert p-values to scores.
#' @inheritParams matchMS
sub_td_byfdrtype <- function (td, fdr_type = "protein", fct_score = 5)
{
  if (fdr_type %in% c("peptide", "protein")) {
    if (fdr_type == "protein") {
      td <- dplyr::arrange(td, pep_seq, pep_prob)
      td <- dplyr::group_by(td, pep_seq)
      td <- dplyr::filter(td, row_number() == 1L)
      td <- dplyr::ungroup(td)
    }
    else {
      # td[["pep_ivmod2"]] <- gsub(" [\\(\\[]\\d+[\\)\\[]$", "", td[["pep_ivmod"]])
      td[["pep_ivmod2"]] <- gsub(" .*", "", td[["pep_ivmod"]])
      td[["pep_seq_mod"]] <- ifelse(is.na(td[["pep_ivmod2"]]), td[["pep_seq"]], 
                                    paste0(td[["pep_seq"]], ".", td[["pep_ivmod2"]]))
      td <- dplyr::arrange(td, pep_seq_mod, pep_prob)
      td <- dplyr::group_by(td, pep_seq_mod)
      td <- dplyr::filter(td, row_number() == 1L)
      td <- dplyr::ungroup(td)
      td[["pep_ivmod2"]] <- NULL
      td[["pep_seq_mod"]] <- NULL
    }
  }
  
  td <- dplyr::select(td, pep_prob, pep_isdecoy)
  td  <- split(td, td[["pep_isdecoy"]])
  td0 <- td[["FALSE"]]
  td1 <- td[["TRUE"]]

  # guard against very low number of decoys
  # (already order by pep_prob?)
  # td1 <- td1[order(td1[["pep_prob"]]), ]
  nr1 <- nrow(td1)
  if (is.null(nr1)) nr1 <- 0L
  
  if (nr1) {
    td1 <- if (nr1 > 200)
      td1[-c(1:5), ]
    else if (nr1 > 100L)
      td1[-c(1:5), ]
    else if (nr1 > 50L)
      td1[-c(1:5), ]
    else if (nr1 > 10L)
      td1[-c(1:5), ]
    else if (nr1 > 1L)
      td1[-seq_len(max(as.integer(nr1 * .5) + 1L, 1L)), ]
    else
      td1
  }

  td  <- dplyr::bind_rows(td0, td1)
  td <- td[order(td[["pep_prob"]]), ]
  td <- dplyr::mutate(td, total = row_number())
  td <- dplyr::mutate(td, decoy = cumsum(pep_isdecoy))
  td <- dplyr::mutate(td, fdr = decoy/total)
  td <- dplyr::mutate(td, pep_score = -log10(pep_prob) * fct_score)
}


#' Find the suitable pep_len values for the fitting of probability cut-offs.
#'
#' Recursively decrease the value of \code{min_count} by half until some indexes
#' are found.
#'
#' @param all_lens A vector of all possible pep_len values found from data.
#' @param counts A vector of the counts of sequences at given pep_len values.
#' @param min_count The minimum counts for consideration in fitting.
find_optlens <- function (all_lens, counts, min_count = 128L) 
{
  idxes <- which(counts >= min_count)
  
  if (length(idxes)) 
    return(all_lens[idxes])
  else 
    find_optlens(all_lens, counts, min_count/2L)
}


#' Find the pep_len that yields the lowest probability.
#' 
#' Closest to 13L; favors smaller "left" if with a "right" tie.
#' 
#' @param prob_cos A vector of probability cut-offs.
#' @param guess An integer of guessed valley.
find_probco_valley <- function (prob_cos, guess = 12L) 
{
  len <- length(prob_cos)
  
  if (len == 1L) return(as.integer(names(prob_cos)[1]))

  min_len <- as.integer(names(prob_cos)[1])
  if (min_len > guess) return(min_len)
  
  deltas <- prob_cos[2:len] - prob_cos[1:(len-1)]
  idxes <- which(deltas > 0) 
  ups <- as.numeric(names(idxes))
  
  ups_left <- ups[ups <= guess & ups - guess >= -3L]
  lens_left <- length(ups_left)
  if (lens_left) return(ups_left[lens_left])
  
  ups_right <- ups[ups > guess & ups - guess <= 3L]
  lens_right <- length(ups_right)
  if (lens_right) return(ups_right[1])

  invisible(guess)
}


#' Prepares target-decoy data.
#'
#' @param td A data frame of targets and decoys (for Percolator).
#' @param is_notched Logical; is a search with MS1 notches or not.
#' @param only_notch_zero Logical; if TRUE, use only data at the zero notch.
#' @inheritParams matchMS
prep_pepfdr_td <- function (td = NULL, out_path, enzyme = "trypsin_p", 
                            nes_fdr_group = "base", fdr_group = "base", 
                            is_notched = FALSE, only_notch_zero = TRUE)
{
  files <- list.files(path = file.path(out_path, "temp"), 
                      pattern = "^pepscores_", full.names = TRUE)
  
  if (!length(files)) 
    stop("Score results not found.")
  
  if (is.null(td)) {
    td <- lapply(files, qs::qread)
    td <- td[lapply(td, nrow) > 0L] # otherwise, error with bind_rows
    td <- dplyr::bind_rows(td)
  }
  
  if (is_notched && only_notch_zero)
    td <- td[with(td, pep_ms1_offset == 0), ]

  cts   <- dplyr::count(dplyr::group_by(td, "pep_mod_group"), pep_mod_group)
  max_i <- cts$pep_mod_group[which.max(cts$n)[[1]]]
  top3s <- cts$pep_mod_group[which_topx2(cts$n, 3)[1:3]]
  top3s <- top3s[!is.na(top3s)]

  if (is.null(enzyme))
    is_nes <- FALSE
  else {
    enzyme <- tolower(enzyme)
    is_nes <- isTRUE(enzyme == "noenzyme") || isTRUE(grepl("^semi", enzyme))
  }
  
  if (!is_nes)
    if (!nes_fdr_group %in% c("all", "base")) 
      nes_fdr_group <- fdr_group
  
  if (is_nes) {
    td  <- if (nes_fdr_group == "all")
      td
    else if (nes_fdr_group == "all_cterm_tryptic")
      td[grepl("[KR]$", td[["pep_seq"]]), ]
    else if (nes_fdr_group == "all_cterm_nontryptic")
      td[!grepl("[KR]$", td[["pep_seq"]]), ]
    else if (nes_fdr_group == "base")
      td[td[["pep_mod_group"]] == max_i, ]
    else if (nes_fdr_group == "base_cterm_tryptic")
      td[td[["pep_mod_group"]] == max_i & grepl("[KR]$", td[["pep_seq"]]), ]
    else if (nes_fdr_group == "base_cterm_nontryptic")
      td[td[["pep_mod_group"]] == max_i & !grepl("[KR]$", td[["pep_seq"]]), ]
    else if (nes_fdr_group == "top3")
      td[td[["pep_mod_group"]] %in% top3s, ]
    else if (nes_fdr_group == "top3_cterm_tryptic")
      td[td[["pep_mod_group"]] %in% top3s & grepl("[KR]$", td[["pep_seq"]]), ]
    else if (nes_fdr_group == "top3_cterm_nontryptic")
      td[td[["pep_mod_group"]] %in% top3s & !grepl("[KR]$", td[["pep_seq"]]), ]
    else
      stop("Invalid argument for \"nes_fdr_group\".")
  }
  else {
    td <- if (fdr_group == "all")
      td
    else if (fdr_group == "base")
      td[td[["pep_mod_group"]] == max_i, ]
    else if (fdr_group == "top3")
      td[td[["pep_mod_group"]] %in% top3s, ]
    else 
      stop("Invalid argument for \"fdr_group\".")
  }
  
  if (!nrow(td))
    stop("No entries at fdr_group = ", fdr_group, ".", 
         "May consider a different `fdr_group`.")

  td
}


#' Keeps the best entries of targets and decoys.
#' 
#' @param td A data frame of targets and decoys.
#' @param cols Columns for grouping.
keep_pepfdr_best <- function (td, cols = c("pep_scan_num", "raw_file"))
{
  # keeps separated best hits for targets and decoys
  # two lists of "TRUE" and "FALSE"
  td <- split(td, td[["pep_isdecoy"]])
  
  td <- lapply(td, function (x) {
    x <- dplyr::group_by_at(x, cols)
    x <- dplyr::arrange(x, pep_prob)
    x <- dplyr::filter(x, row_number() == 1L)
    x <- dplyr::ungroup(x)
  })
  
  # decoy sequences may be present in targets
  ok <- is.na(fastmatch::fmatch(reverse_seqs(td[["FALSE"]][["pep_seq"]]), 
                                td[["TRUE"]][["pep_seq"]]))
  td[["FALSE"]] <- td[["FALSE"]][ok, ]
  
  #  keeps the best hit for each `scan_num`
  td <- if (nrow(td[["FALSE"]]))
    dplyr::bind_rows(td[c("TRUE", "FALSE")])
  else
    td[["TRUE"]]
  
  td <- dplyr::group_by_at(td, cols)
  td <- dplyr::arrange(td, pep_prob)
  td <- dplyr::filter(td, row_number() == 1L)
  td <- dplyr::ungroup(td)
}


#' Calculates the cut-off score at a peptide FDR.
#'
#' Needs \code{min_len} and \code{max_len} since the target-decoy pair may not
#' cover all \code{pep_len} values.
#' 
#' @param target_fdr Numeric; the levels of false-discovery rate (FDR).
#' @param fdr_type Character string; the type of FDR for controlling.
#' @param fct_score A trivial factor converting p-values to scores.
#' @param is_notched Logical; is a search with MS1 notches or not.
#' @inheritParams matchMS
#' @examples 
#' \donttest{
#' library(mzion)
#' 
#' if (FALSE) {
#'   prob_cos <- calc_pepfdr(target_fdr = .01, 
#'                           fdr_type = "protein", 
#'                           min_len = 7L, 
#'                           max_len = 50L, 
#'                           out_path = "~/mzion/bi_1")
#' }
#' }
calc_pepfdr <- function (target_fdr = .01, fdr_type = "protein", 
                         min_len = 7L, max_len = 40L, is_notched = FALSE, 
                         max_pepscores_co = 70, min_pepscores_co = 0, 
                         enzyme = "trypsin_p", fdr_group = "base", 
                         nes_fdr_group = "base", fct_score = 5, out_path)
{
  message("Calculating peptide FDR.")
  
  td <- prep_pepfdr_td(out_path = out_path, 
                       enzyme = enzyme, 
                       nes_fdr_group = nes_fdr_group, 
                       fdr_group = fdr_group, 
                       is_notched = is_notched, 
                       only_notch_zero = TRUE)
  
  # back-compatibility to new column keys (e.g. scan_num -> pep_scan_num)
  if (!"pep_scan_num" %in% names(td)) 
    stop("Seems like reprocessing of results from an earlier version.\n", 
         "  Please delete old \"temp\\pep_score[...].rds\".")
  
  if (!sum(td[["pep_isdecoy"]])) {
    warning("No decoys found.")
    seqs <- min_len:max(td[["pep_len"]], na.rm = TRUE)
    prob_cos <- rep(.5, length(seqs))
    return(data.frame(pep_len = seqs, pep_prob_co = prob_cos))
  }
  
  # dependent variables: higher pep_exp_z tends to have greater pep_len
  # td <- dplyr::filter(td, pep_exp_z == 2L, )
  
  # not cols <- c("pep_scan_num", "raw_file", "pep_ms1_offset")
  #  as only use td at pep_ms1_offset == 0
  td <- keep_pepfdr_best(td, cols = c("pep_scan_num", "raw_file"))
  qs::qsave(td, file.path(out_path, "temp", "td_pepfdr.rds"), preset = "fast")
  
  # --- 
  all_lens <- sort(unique(td$pep_len))
  prob_cos <- lapply(all_lens, probco_bypeplen, 
                     td = td, 
                     fdr_type = fdr_type, 
                     target_fdr = target_fdr, 
                     min_pepscores_co = min_pepscores_co, 
                     fct_score = fct_score, 
                     out_path = out_path)
  prob_cos <- unlist(prob_cos)
  
  if (length(prob_cos) == 1L && !is.na(prob_cos))
    return(data.frame(pep_len = all_lens, pep_prob_co = prob_cos))
  else if (length(prob_cos) == 1L && is.na(prob_cos))
    return(data.frame(pep_len = all_lens, pep_prob_co = target_fdr))
  else if (all(is.na(prob_cos))) {
    seqs <- min_len:max(td$pep_len, na.rm = TRUE)
    prob_cos <- rep(target_fdr, length(seqs))
    return(data.frame(pep_len = seqs, pep_prob_co = prob_cos))
  }
  
  counts <- as.integer(names(prob_cos))
  names(counts) <- all_lens
  names(prob_cos) <- all_lens
  prob_nas <- prob_cos[is.na(prob_cos)]
  prob_cos <- prob_cos[!is.na(prob_cos)]

  if (length(prob_cos) == 1L) {
    seqs <- min_len:max_len
    prob_cos <- rep(prob_cos, length(seqs))
    return(data.frame(pep_len = seqs, pep_prob_co = prob_cos))
  }
  
  #########################################
  # (At least two non-trivial prob_cos)
  #########################################
  
  lens  <- find_optlens(all_lens, counts, 50L)

  # no fittings
  if (length(lens) <= 3L) {
    prob_cos <- prob_cos[!is.na(names(prob_cos))]
    prob_no_uses <- NULL
    
    return(fill_probco_nas(prob_nas = prob_nas, prob_no_uses = prob_no_uses, 
                           prob_cos = prob_cos, target_fdr = target_fdr))
  }
  
  # quality ones for fittings
  ok_lens <- names(prob_cos) %in% lens
  prob_no_uses <- prob_cos[!ok_lens]
  count_no_uses <- counts[!ok_lens]
  prob_cos <- prob_cos[ok_lens]
  counts <- counts[ok_lens]
  
  ## fittings
  df <- data.frame(x = as.numeric(names(prob_cos)), 
                   y = -fct_score * log10(prob_cos))
  df7 <- df[df$x <= 7L, ]
  df  <- df[df$x >  7L, ]
  nr  <- nrow(df) # >= 3L
  
  # may consider an empirical slope of -.3 at pep_len >= 19
  if (nr <= 4L) {
    fit <- stats::lm(y ~ x, df)
  }
  else {
    fits <- lapply(pmin(nr - 2L, 4), find_fdr_fits, df) # 4:5
    res <- lapply(fits, attr, "res", exact = TRUE)
    oks <- unlist(lapply(res, is.finite), recursive = FALSE, use.names = FALSE)
    fits <- fits[oks]
    res <- res[oks]
    
    if (!length(fits))
      stop("Contact the developer.")
    
    fit <- fits[[which.min(res)]]
  }
  
  newx <- min(df$x, na.rm = TRUE):max(df$x, na.rm = TRUE)
  newy <- predict(fit, data.frame(x = newx))

  if (nrow(df7)) {
    newx <- c(df7$x, newx)
    newy <- c(df7$y, newy)
  }
  
  names(newy) <- newx

  max_pepscores_co <- if (length(idx <- which(names(prob_cos) == 8L)))
    max(-fct_score*log10(prob_cos[[idx]]), max_pepscores_co)
  else if (length(idx <- which(names(prob_cos) == 9L)))
    max(-fct_score*log10(prob_cos[[idx]]), max_pepscores_co)
  else if (length(idx <- which(names(prob_cos) == 7L)))
    max(-fct_score*log10(prob_cos[[idx]])/2, max_pepscores_co)
  else
    max_pepscores_co

  newy[newy < min_pepscores_co] <- min_pepscores_co
  newy[newy > max_pepscores_co] <- max_pepscores_co
  
  local({
    df <- rbind2(df7, df)
    n1 <- nrow(df)
    dfp <- rbind2(
      cbind(df, type = rep("Original", n1)), 
      data.frame(x = newx, y = newy, type = "Fitted"))
    n2 <- nrow(dfp) - n1
    
    try(
      local({
        pdf(file.path(out_path, "temp", "pepscore_len.pdf")) 
        plot(y ~ x, dfp, col = c(rep("blue", n1), rep("red", n2)), 
             xlab = "pep_len", ylab = "score_co", pch = 19)
        legend("topright", legend = c("Raw", "Smoothed"), 
               col = c("blue", "red"), pch = 19, bty = "n")
        dev.off()
      })
    )
  })
  
  ## Outputs
  prob_cos <- local({
    nms <- names(prob_cos)
    prob_cos <- 10^(-newy/fct_score)
    names(prob_cos) <- nms
    
    # with `find_optlens`, some length in newy may not be in prob_cos
    prob_cos[!is.na(names(prob_cos))]
  })
  
  prob_cos <- fill_probco_nas(prob_nas, prob_no_uses, prob_cos, target_fdr) %T>% 
    qs::qsave(file.path(out_path, "temp", "pep_probco.rds"), preset = "fast")
}


#' Fills NA in probability cutoffs
#' 
#' @param prob_nas Named vector; peptide length in names and NA in values.
#' @param prob_no_uses Named vector; peptide length in names and NA in values.
#' @param prob_cos Named vector; non-NA probability cutoffs.
#' @inheritParams calc_pepfdr
fill_probco_nas <- function (prob_nas = NULL, prob_no_uses = NULL, prob_cos, 
                             target_fdr = .01)
{
  prob_nas <- fill_probs(prob_nas, prob_cos, target_fdr)
  prob_no_uses <- fill_probs(prob_no_uses, prob_cos, target_fdr)
  prob_cos <- c(prob_cos, prob_nas, prob_no_uses)
  
  prob_cos <- data.frame(pep_len = as.numeric(names(prob_cos)), 
                         pep_prob_co = prob_cos)
  
  prob_cos <- dplyr::arrange(prob_cos, pep_len)
}


#' Helper to find the best regression.
#' 
#' @param knot The number of knots.
#' @param df A data frame.
find_fdr_fits <- function (knot, df)
{
  fit_ns <- tryCatch(stats::lm(y ~ splines::ns(x, knot), df), 
                     error = function(e) NA)
  fit_bs <- tryCatch(stats::lm(y ~ splines::bs(x, knot), df), 
                     error = function(e) NA)
  res_ns <- if (class(fit_ns) == "lm") sum(resid(fit_ns)^2) else Inf
  res_bs <- if (class(fit_bs) == "lm") sum(resid(fit_bs)^2) else Inf
  
  if (res_ns <= res_bs) {
    fit <- fit_ns
    res <- res_ns
  }
  else {
    fit <- fit_bs
    res <- res_bs
  }
  
  attr(fit, "res") <- res
  fit
}


#' Helper of \link{fill_probco_nas}
#'
#' @param nas A vector of NA or inferior probability cut-offs to be replaced.
#' @inheritParams fill_probco_nas
#' @return The replacements. Do not return the concatenated prob_cos and nas, to
#'   prevent the estimated values from affecting the consequent replacement of
#'   prob_no_uses.
fill_probs <- function (nas, prob_cos, target_fdr = .01) 
{
  len <- length(nas)
  
  if (!len)
    return(NULL)
  
  peplen_prs <- as.integer(names(prob_cos))
  peplen_nas <- as.integer(names(nas))
  nas <- nas[!peplen_nas %in% peplen_prs]
  peplen_nas <- as.integer(names(nas))

  co_nas <- if (all(peplen_nas > max(peplen_prs)))
    prob_cos[length(prob_cos)]
  else if (all(peplen_nas < min(peplen_prs)))
    prob_cos[1]
  else
    min(median(prob_cos), mean(prob_cos), target_fdr)
  
  val <- unname(co_nas)
  vals <-rep(val, len)
  names(vals) <- peplen_nas

  vals
}


#' Post processing after peptide FDR.
#' 
#' @param prob_cos Probability cut-offs (in data frame).
#' @param out_path An output path.
#' @param fct_score A factor to convert p-values to scores.
#' @inheritParams matchMS
post_pepfdr <- function (prob_cos = NULL, n_13c = 0L, out_path = NULL, 
                         fct_score = 5L) 
{
  if (is.null(prob_cos)) {
    file_prob <- file.path(out_path, "temp", "pep_probco.rds")
    
    if (file.exists(file_prob))
      prob_cos <- qs::qread(file_prob)
    else 
      stop("File not found: ", file_prob)
  }
  
  # changed from 10: with modified "N" from 500 to 20000 in dhyper 
  ok_targets <- find_targets(out_path, "^pepscores_")
  files <- ok_targets$files
  
  if (!length(files)) 
    stop("Results of peptide scores not found.")
  
  # td <- lapply(files, function (x) qs::qread(file.path(out_path, "temp", x)))
  td <- lapply(files, function (x) {
    # without column "matches" -> `df` may have duplicated rows; 
    # targets and decoys share the same pep_seq but is.na(decoys$pep_ivmod)
    df <- qs::qread(file.path(out_path, "temp", x))
    u  <- df[, c("raw_file", "pep_scan_num", "pep_seq", "pep_ivmod", 
                 "pep_ms1_offset")]
    df <- df[!duplicated.data.frame(u), ]
  })
  
  names(td) <- ok_targets$idxes

  if (!any(ok <- unlist(lapply(td, nrow) > 0L)))
    stop("No PSM matches for scoring. Consider different search parameters.")
  
  td <- td[ok]
  rm(list = c("ok_targets", "files", "ok"))

  td <- lapply(td, rm_dup13c, n_13c = n_13c)

  td <- lapply(td, function (df) {
    df <- df |> 
      dplyr::left_join(prob_cos, by = "pep_len") |>
      dplyr::mutate(pep_issig = ifelse(pep_prob <= pep_prob_co, TRUE, FALSE))
  })

  # may delay the combine...
  td <- dplyr::bind_rows(td)

  # Adjusted p-values (just to moderate pep_score)
  td <- td |> 
    dplyr::mutate(pep_adjp = p.adjust(pep_prob, "BH"))
  
  adjp_cos <- lapply(prob_cos$pep_prob_co, function (x) {
    row <- which.min(abs(log10(td$pep_prob/x)))
    td[row, ]$pep_adjp
  })
  adjp_cos <- unlist(adjp_cos, recursive = FALSE, use.names = FALSE)
  prob_cos <- dplyr::bind_cols(prob_cos, pep_adjp_co = adjp_cos)
  
  td <- td |> 
    dplyr::left_join(prob_cos[, c("pep_len", "pep_adjp_co")], by = "pep_len") |> 
    dplyr::mutate(pep_score = -log10(pep_adjp) * fct_score, 
                  # pep_score = ifelse(pep_score > 250, 250, pep_score), 
                  pep_score_co = -log10(pep_adjp_co) * fct_score) |> 
    dplyr::select(-c("pep_prob", "pep_adjp", "pep_prob_co", "pep_adjp_co"))
  
  qs::qsave(td, file.path(out_path, "temp", "pepfdr.rds"), preset = "fast")
  
  invisible(td)
}


#' Calculates the cut-offs of protein scores.
#'
#' @param df An output from upstream steps.
#' @param out_path An output path.
#' @inheritParams calc_pepfdr
#' @inheritParams matchMS
calc_protfdr <- function (df = NULL, target_fdr = .01, max_protscores_co = Inf, 
                          max_protnpep_co = 10L, method_prot_es_co = "median", 
                          out_path = NULL) 
{
  message("Calculating peptide-protein FDR.")
  
  # score cut-offs as a function of prot_n_pep
  max_n_pep  <- max(df$prot_n_pep, na.rm = TRUE)
  all_n_peps <- unique(df$prot_n_pep)
  
  # protein enrichment score cut-offs at each `prot_n_pep`
  td <- df[with(df, pep_issig), ]
  
  score_co <- split(td, td[["prot_n_pep"]])
  score_co <- lapply(score_co, calc_protfdr_i, 
                     target_fdr = target_fdr, 
                     max_protnpep_co = max_protnpep_co, 
                     method_prot_es_co = method_prot_es_co, 
                     out_path = out_path)
  score_co <- unlist(score_co, recursive = FALSE, use.names = TRUE)
  score_co[score_co > max_protscores_co] <- max_protscores_co
  
  # fitted score cut-offs
  score_co_bf <- data.frame(prot_n_pep = as.integer(names(score_co)), 
                            prot_score_co_bf = score_co)
  
  score_co <- score_co |> 
    fit_protfdr(max_n_pep, out_path) |> 
    dplyr::filter(prot_n_pep %in% all_n_peps) |> 
    dplyr::left_join(score_co_bf, by = "prot_n_pep") |> 
    dplyr::mutate(prot_es_co = ifelse(prot_score_co <= prot_score_co_bf, 
                                      prot_score_co, prot_score_co_bf)) |> 
    dplyr::select(-c("prot_score_co", "prot_score_co_bf"))
  
  # add protein enrichment score
  prot_es <- df |> 
    dplyr::group_by(prot_acc, pep_seq) |> 
    dplyr::arrange(-pep_score) |> 
    dplyr::filter(row_number() == 1L) |> 
    dplyr::ungroup() |> 
    dplyr::filter(pep_issig) |> 
    dplyr::mutate(pep_es = pep_score - pep_score_co) |> 
    dplyr::group_by(prot_acc) |> 
    dplyr::summarise(prot_es = max(pep_es, na.rm = TRUE))
  
  # puts together
  df <- df |> 
    dplyr::left_join(prot_es, by = "prot_acc")
  
  df <- df |> 
    dplyr::left_join(score_co, by = "prot_n_pep") |> 
    dplyr::mutate(prot_issig = ifelse(prot_es >= prot_es_co, TRUE, FALSE)) |> 
    dplyr::mutate(pep_score = round(pep_score, digits = 1L), 
                  pep_score_co = round(pep_score_co, digits = 1L), 
                  prot_es = round(prot_es, digits = 1L), 
                  prot_es_co = round(prot_es_co, digits = 1L))
}


#' Function factories for descriptive statistics.
#'
#' @param f One of \code{max, mean, median, min}. Data frame \code{df} is a PSM
#'   table.
aggr_prot_es <- function(f) 
  function (df, ...) dplyr::summarise(df, prot_es = f(prot_es, ...))


#' Helper of \link{calc_protfdr}.
#' 
#' For prot_n_pep at value i.
#' 
#' @param td A data frame with paired target-decoys at prot_n_pep = i.
#' @param n_burnin The minimum number of burn-ins in protein enrichment scores. 
#' @param out_path An output path.
#' @inheritParams calc_protfdr
#' @return A score cut-off at a given prot_n_pep.
calc_protfdr_i <- function (td, target_fdr = .01, max_protnpep_co = 10L, 
                            method_prot_es_co = "median", n_burnin = 3L, out_path) 
{
  options(digits = 9L)
  
  if (td[["prot_n_pep"]][[1]] > max_protnpep_co)
    return(0L)

  td <- td |> 
    dplyr::group_by(prot_acc, pep_seq) |> 
    dplyr::arrange(-pep_score) |> 
    dplyr::filter(row_number() == 1L) |> 
    dplyr::ungroup()

  ## no decoys
  if (sum(td$pep_isdecoy) == 0L) 
    return(0L)
  
  ## all decoys
  if (sum(!td$pep_isdecoy) == 0L) {
    if (nrow(td) <= 5L) return(0L) else return(20L)
  }

  ## both targets and decoys
  if (nrow(td) <= 20L) 
    return(1L)
  
  # (NOT to use `local` for hard `return (0L)`)
  prot_scores <- td |> 
    dplyr::mutate(prot_es = pep_score - pep_score_co) |> 
    dplyr::group_by(prot_acc) 
  
  prot_scores <- switch(method_prot_es_co, 
                        max = aggr_prot_es(max)(prot_scores, na.rm = TRUE), 
                        mean = aggr_prot_es(mean)(prot_scores, na.rm = TRUE), 
                        median = aggr_prot_es(median)(prot_scores, na.rm = TRUE),
                        min = aggr_prot_es(min)(prot_scores, na.rm = TRUE), 
                        aggr_prot_es(max)(prot_scores, na.rm = TRUE))

  # no decoys
  if (!any(grepl("^-", prot_scores$prot_acc))) 
    return (0L)
  
  # Multiple dipping of -NP_003310, -NP_597676 with the same set of 
  #  identifying pep_seqs and identical `prot_es`
  # 
  # prot_acc     prot_es
  # <chr>          <dbl>
  # 1 -NP_003310      43.1
  # 2 -NP_597676      43.1
  # 3 -NP_597681      43.1
  # 4 NP_001004067    96.3
  #
  # Not yet to parse out same-set, sub-set proteins. For simplicity and performance, 
  # keep one unique `prot_es` (by roughly assuming `prot_es` is an indicator for 
  # the redundancy). 

  prot_scores <- prot_scores |> 
    dplyr::mutate(prot_es = round(prot_es, digits = 5L)) |> 
    dplyr::filter(!duplicated(prot_es))
  
  # Removes the last three in case only one or two decoy spikes near the end 
  # the list 
  # 
  # prot_acc      prot_es
  # <chr>           <dbl>
  # NP_001028448     53.4
  # -NP_001157012    54.4
  # NP_077772        62.7

  prot_scores <- prot_scores |> 
    dplyr::arrange(prot_es) |> 
    dplyr::filter(row_number() > n_burnin)

  # no decoys
  if (!any(grepl("^-", prot_scores$prot_acc))) 
    return (0L)

  # both targets and decoys
  td <- td |> 
    dplyr::right_join(prot_scores, by = "prot_acc") |> 
    dplyr::arrange(-prot_es) |> 
    dplyr::mutate(total = row_number()) |> 
    dplyr::mutate(decoy = cumsum(pep_isdecoy)) |> 
    dplyr::mutate(fdr = decoy/total)
  
  rm(list = "prot_scores")
  
  rows <- which(td$fdr <= target_fdr)
  row <- if (length(rows)) max(rows, na.rm = TRUE) else -Inf

  if (row == -Inf) {
    score_co <- 0L
    score_co2 <- score_co
  } 
  else {
    score_co <- td$prot_es[row]

    score_co2 <- local({
      data <- data.frame(x = td[["prot_es"]], y = td[["fdr"]])
      
      fit <- suppressWarnings(
        tryCatch(
          stats::nls(y ~ SSlogis(x, Asym, xmid, scal), data = data, 
              control = list(tol = 1e-03, warnOnly = TRUE), 
              algorithm = "port"), 
          error = function (e) NA)
      )
      
      if (all(is.na(fit))) {
        score_co2 <- score_co
      } 
      else {
        min_score <- min(data$x, na.rm = TRUE)
        max_score <- max(data$x, na.rm = TRUE)
        newx <- min_score:max_score
        newy <- predict(fit, data.frame(x = newx)) |> `names<-`(newx)

        # NA if not existed
        score_co2 <- which(newy <= target_fdr)[1] |> 
          names() |> 
          as.numeric()
        
        local({
          title <- paste0("prot_n_pep@", td$prot_n_pep[1])
          
          if (FALSE) {
            try(
              local({
                pdf(file.path(out_path, "temp", paste0(title, ".pdf"))) 
                plot(y ~ x, data, xlab = "Enrichment score", col = "blue", 
                     ylab = "FDR", pch = 19)
                title(main = title)
                lines(newx, newy, col = "red", type = "b")
                abline(h = target_fdr, col = "green", lwd = 3, lty = 2)
                legend("topright", legend = c("Raw", "Smoothed"), 
                       col = c("blue", "red"), pch = 19, bty = "n")
                legend("center", pch = 19, 
                       legend = c(paste0("Raw: ", round(score_co, 2L)), 
                                  paste0("Smoothed: ", round(score_co2, 2L))))
                dev.off()
              })
            )
          }
        })
      }

      score_co2
    })
  }
  
  invisible(min(score_co, score_co2, na.rm = TRUE))
}


#' Fits the raw cut-offs of protein scores.
#'
#' Assumed a sigmoidal function.
#'
#' @param vec Named numeric vector. The values are the score cut-offs as a
#'   function of \code{prot_n_pep}. The names correspond to the number of
#'   peptides being identified.
#' @param max_n_pep Integer; the maximum value of \code{prot_n_pep} for
#'   prediction.
#' @param out_path An output path.
fit_protfdr <- function (vec, max_n_pep = 1000L, out_path) 
{
  if (length(vec) <= 10L) 
    return(data.frame(prot_n_pep = as.numeric(names(vec)), prot_score_co = vec))

  rv <- rev(vec)
  df <- data.frame(x = as.numeric(names(rv)), y = rv)
  elbow <- min(df[which(df$y == min(df$y, na.rm = TRUE)), "x"], na.rm = TRUE)
  amp <- max(df$y, na.rm = TRUE) * .8
  sca <- 0.5
  
  ## nls
  f <- function (x, m = 0, s = 1, a = 1) { a - a / (1 + exp(-(x-m)/s)) }
  
  fit <- suppressWarnings(
    tryCatch(
      stats::nls(y ~ f(x, m, s, a), data = df, 
          start = list(a = amp, m = elbow, s = sca), 
          control = list(tol = 1e-03, warnOnly = TRUE), 
          algorithm = "port"), 
      error = function (e) NA)
  )
  
  # should not occur
  if (all(is.na(fit))) {
    fits <- suppressWarnings(
      purrr::map(seq_len(elbow-1), ~ {
        tryCatch(
          stats::nls(y ~ f(x, m, s, a), data = df, 
              start = list(a = amp, m = .x, s = sca), 
              control = list(tol = 1e-03, warnOnly = TRUE), 
              algorithm = "port"), 
          error = function (e) NA)
      })
    )
    
    fit <- if (all(is.na(fits))) {
      NA
    } 
    else {
      # fits %>% .[!is.na(.)] %>% .[[length(.)]]
      fits <- fits[!is.na(fits)]
      fits <- fits[[length(fits)]]
    }
  }

  ## lm
  df_left <- df[df$x <= elbow, ]
  df_right <- df[df$x > elbow, ]
  
  fit_left <- tryCatch(
    lm(y ~ x, data = df_left), 
    error = function (e) NA)
  
  fit_right <- tryCatch(
    lm(y ~ x, data = df_right), 
    error = function (e) NA)
  
  res_left <- if (class(fit_left) == "lm") sum(resid(fit_left)^2) else Inf
  res_right <- if (class(fit_right) == "lm") sum(resid(fit_right)^2) else Inf
  res_lm <- sum(res_left + res_right)
  
  res_nls <- if (class(fit) == "nls") sum(resid(fit)^2) else Inf

  ## nls vs. lm
  if (res_nls <= res_lm) {
    newx <- 1:max_n_pep
    newy <- predict(fit, data.frame(x = newx))
    
    out <- data.frame(
      prot_n_pep = newx, 
      prot_score_co = newy) |> 
      dplyr::mutate(prot_score_co = ifelse(prot_n_pep >= elbow, 0, prot_score_co))
  } 
  else {
    newx_left <- 1:elbow
    newy_left <- predict(fit_left, data.frame(x = newx_left))
    newx_right <- (elbow + 1L):max_n_pep
    newy_right <- predict(fit_right, data.frame(x = newx_right))
    
    newx <- c(newx_left, newx_right)
    newy <- c(newy_left, newy_right)

    out <- data.frame(
      prot_n_pep = newx, 
      prot_score_co = newy) |> 
      dplyr::mutate(prot_score_co = ifelse(prot_n_pep >= elbow, 0, prot_score_co))
    
  }
  
  try(
    local({
      pdf(file.path(out_path, "temp", "protein_score_co.pdf")) 
      plot(y ~ x, df, xlab = "prot_n_pep", col = "blue", 
           ylab = "Protein score", pch = 19)
      title(main = "Protein score CO")
      # lines(newx, newy, col = "red", type = "b")
      # lines(newx, newy, col = "red")
      lines(out$prot_n_pep , out$prot_score_co, col = "red", type = "b")
      lines(out$prot_n_pep , out$prot_score_co, col = "red")
      legend("topright", legend = c("Raw", "Smoothed"), 
             col = c("blue", "red"), pch = 19, bty = "n")
      dev.off()
      
      qs::qsave(df, file.path(out_path, "temp", "protein_score_co.rds"))
    })
  )
  
  invisible(out)
}


#' Finds the the outer products for a vector of MS2 ions at a given ion series.
#'
#' \emph{Experiment} values go first and theoretical seconded.
#'
#' @param X Numeric vector; one series experimental MS2s.
#' @param Y Numeric vector; one series of theoretical MS2s.
#' @inheritParams matchMS
#' 
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' expts <- c(101.0714, 102.0554, 110.0717, 115.0505, 126.1279, 127.0504,
#'            127.1249, 127.1312, 128.1283, 128.1346, 129.0660, 129.1316,
#'            129.1379, 130.1350, 130.1412, 131.1383, 133.0431, 133.0609,
#'            134.0448, 136.0757, 145.0608, 158.0924, 173.1496, 175.1190,
#'            176.1594, 191.0663, 193.0971, 198.0873, 201.0869, 201.1233,
#'            202.0821, 230.1702, 248.0876, 248.1806, 257.1527, 298.6711,
#'            312.6687, 335.1190, 361.1768, 361.6685, 367.2292, 369.6903,
#'            370.1821, 370.6830, 376.2756, 377.2790, 384.6952, 412.7264,
#'            420.2143, 423.2597, 475.2341, 475.3442, 476.3469, 484.2382,
#'            484.7389, 487.7817, 488.2842, 496.2717, 523.3182, 537.3159,
#'            537.8178, 572.8343, 573.3373, 623.3586, 624.3298, 636.8528,
#'            637.3558, 637.8575, 638.4089, 645.3453, 645.8500, 646.3501,
#'            687.8795, 688.3799, 692.8696, 695.4283, 701.3759, 701.8768,
#'            702.3782, 702.8797, 737.3956, 737.8962, 738.3671, 739.3572,
#'            740.3575, 745.9085, 746.4121, 752.4502, 801.4272, 809.4722,
#'            810.4739, 852.4418, 967.4690, 968.4714, 969.5046, 1084.5293,
#'            1132.5676, 1133.5686, 1134.5735, 1135.5786)
#'
#' theos <- c(116.0342, 203.0662, 290.0983, 418.1569, 475.1783, 572.2311,
#'            732.2617, 861.3043, 958.3571, 1071.4412, 1168.4939, 1225.5154,
#'            1322.5681, 1435.6522, 1536.6999, 1664.7585, 1761.8112, 1917.9123,
#'            175.1190, 272.1717, 400.2303, 501.2780, 614.3620, 711.4148,
#'            768.4363, 865.4890, 978.5731, 1075.6259, 1204.6684, 1364.6991,
#'            1461.7519, 1518.7733, 1646.8319, 1733.8639, 1820.8960, 1935.9229)
#'
#' names(theos) <- c("D", "S", "S", "Q", "G", "P", "C", "E", "P",
#'                   "L", "P", "G", "P", "L", "T", "Q", "P", "R",
#'                   "R", "P", "Q", "T", "L", "P", "G", "P", "L",
#'                   "P", "E", "C", "P", "G", "Q", "S", "S", "D")
#'
#' mzion:::find_ppm_outer_bycombi(theos, expts, ppm_ms2 = 25L)
#' 
#' # No secondary matches
#' theos <- c(56.5233, 235.1522, 284.6864, 326.2050, 361.7235, 
#'            418.2656, 474.8076, 653.4366, 95.0128, 452.2707, 
#'            551.3391, 634.3762, 705.4133, 818.4974, 931.5815, 
#'            1288.8394, 48.0100, 226.6390, 276.1732, 317.6917, 
#'            353.2103, 409.7523, 466.2944, 644.9233, 94.0287, 
#'            451.2866, 550.3550, 633.3921, 704.4292, 817.5133, 
#'            930.5974, 1287.8553, 47.5180, 226.1470, 275.6812, 
#'            317.1997, 352.7183, 409.2603, 465.8024, 644.4313,
#'            188.6415, 245.1835, 301.7256, 337.2441, 378.7627, 
#'            428.2969, 606.9258, 670.9551, 359.2492, 472.3333, 
#'            585.4174, 656.4545, 739.4916, 838.5600, 1195.8179, 
#'            1323.8765, 180.1282, 236.6703, 293.2123, 328.7309, 
#'            370.2494, 419.7836, 598.4126, 662.4419, 358.2651, 
#'            471.3492, 584.4333, 655.4704, 738.5075, 837.5759, 
#'            1194.8338, 1322.8924, 179.6362, 236.1783, 292.7203, 
#'            328.2389, 369.7574, 419.2916, 597.9206, 661.9499)
#' 
#' a <- c("Q", "K", "V", "M", "A", "I", "I", "K")
#' b <- rev(a)
#' names(theos) <- c(rep(a, 5), rep(b, 5))
#' 
#' expts <- c(101.01134,110.07162,112.03947,116.01675,118.83968,
#'            120.08091,126.12779,127.12479,127.13109,128.12816,
#'            128.13440,129.13150,129.13777,130.13483,130.14053,
#'            131.13824,150.26431,155.08147,156.07658,159.07658,
#'            173.14934,175.05345,175.15630,176.13777,176.15942,
#'            176.72833,187.07147,188.15984,203.04829,203.35188,
#'            204.05164,219.14928,227.06596,229.16634,230.16991,
#'            231.17354,232.95274,248.17976,268.16522,315.25906,
#'            318.07504,319.07828,333.21524,361.11679,361.20996,
#'            372.28027,376.27521,377.27872,389.11212,390.11490,
#'            404.25201,432.24750,489.26880,489.35962,504.09521,
#'            510.33450,515.28448,527.35297,533.29462,542.31720,
#'            560.34607,577.31445,588.33716,594.34283,599.39276,
#'            602.44226,604.36749,614.35211,632.36328,659.46362,
#'            694.44006,694.93970,695.39063,707.20782,734.39813,
#'            752.41211,753.41321,756.51660,757.52002,830.91998,
#'            851.48267,852.48303,855.58301,899.52069,956.62952,
#'            1027.66833,1230.73962,1232.75513,1233.75024)
#' 
#' mzion:::find_ppm_outer_bycombi(theos, expts, ppm_ms2 = 25)
#' }
find_ppm_outer_bycombi <- function (X, Y, ppm_ms2 = 20L) 
{
  d <- outer(X, Y, "find_ppm_error")
  row_cols <- which(abs(d) <= ppm_ms2, arr.ind = TRUE)
  ix <- row_cols[, 1]
  iy <- row_cols[, 2]

  es <- rep(NA_real_, length(Y))
  names(es) <- names(Y)
  es[iy] <- X[ix]
  
  list(theo = Y, expt = es, ith = iy, iex = ix, m = length(ix))
}


#' Matches between secondary experimentals and theoreticals.
#' 
#' @param expt A vector of experimental m-over-z values.
#' @param theo A vector of theoretical m-over-z values.
#' @param d Bin size, e.g., \eqn{20 ppm / 2 * 1E-6}.
#' @inheritParams matchMS
match_ex2th2 <- function (expt, theo, min_ms2mass = 115L, d = 1E-5) 
{
  th  <- index_mz(theo, from = min_ms2mass, d = d)
  ex <- index_mz(expt, from = min_ms2mass, d = d)
  t2e <- fastmatch::fmatch(c(th, th - 1L, th + 1L), ex, nomatch = 0L)
  
  l  <- length(th)
  mi <- t2e[1:l]
  bf <- t2e[(l + 1L):(l + l)]
  af <- t2e[(l + l + 1L):(l * 3L)]
  
  okmi <- mi > 0L
  okbf <- bf > 0L
  okaf <- af > 0L
  
  ith <- c(.Internal(which(okmi)), .Internal(which(okbf)), .Internal(which(okaf)))
  iex <- c(mi[okmi], bf[okbf], af[okaf])
  
  es <- rep_len(NA_real_, l)
  names(es) <- names(th)
  es[ith] <- expt[iex]

  list(theo = theo, expt = es, ith = ith, iex = iex, m = length(iex))
}


#' Calculates the delta scores of \code{pep_seq}.
#'
#' A score delta between the best and the second best.
#'
#' There should not be any duplicated rows at the combination of
#' c("pep_isdecoy", "scan_num", "raw_file", "pep_seq", "pep_ivmod")
#'
#' @param x The results from \link{calc_pepscores}.
#' @param out_path An output path.
#' @param mod_indexes Integer; the indexes of fixed and/or variable
#'   modifications.
#' @param is_notched Logical; is a search with MS1 notches or not.
#' @inheritParams matchMS
#' @rawNamespace import(data.table, except = c(last, first, between, transpose,
#'   melt, dcast))
calc_peploc <- function (x = NULL, out_path = NULL, mod_indexes = NULL, 
                         is_notched = FALSE, 
                         locmods = c("Phospho (S)", "Phospho (T)", "Phospho (Y)"), 
                         topn_mods_per_seq = 3L, topn_seqs_per_query = 3L) 
{
  message("Calculating peptide localization scores and deltas.")

  # some shallow copy warnings from data.table
  old_opts <- options()
  options(warn = -1L)
  on.exit(options(old_opts), add = TRUE)
  
  if (is.null(x)) {
    file <- file.path(out_path, "temp", "pepfdr.rds")
    
    if (file.exists(file)) 
      x <- qs::qread(file) 
    else 
      stop("File not found: ", file)
    
    rm(list = "file")
  }
  
  message("\tRank peptides by neutral losses.")
  
  n_cores <- detect_cores(16L)
  para <- nrow(x) > 10000L
  
  x <- data.table::data.table(x)
  x[, pep_isdecoy := as.integer(pep_isdecoy)]

  # finds the rank-1 pep_ms1_offset at each query_id
  # keeps only the rank-1 pep_ms1_offset group at each query_id
  if (is_notched) {
    x[, query_id := paste(pep_isdecoy, pep_scan_num, raw_file, sep = ".")]
    
    if (para) {
      x  <- x[order(x[["query_id"]]), ] # for group split
      cl <- parallel::makeCluster(getOption("cl.cores", n_cores))
      xs <- parallel::clusterApply(
        cl, split(x, find_chunkbreaks(x[["query_id"]], n_cores)), find_bestnotch)
      parallel::stopCluster(cl)
      
      x <- data.table::rbindlist(xs, use.names = FALSE)
      rm(list = c("xs"))
    }
    else {
      x <- find_bestnotch(x)
    }
  }

  # For simplicity `pep_seq` uses interchangeably with `uniq_id` and 
  # `pep_seq_mod` with `uniq_id2` where everything is on top of the same 
  # pep_isdecoy, pep_scan_num, raw_file.
  # 
  # uniq_id --- can differentiate the same `pep_seq` at different mod locations & NL 
  # uniq_id2 --- can differentiate the same `pep_seq_mod` at different NLs
  # uniq_id3 --- can differentiate the same *query* at different `pep_seq`s
  # 
  # pep_rank --- `pep_seq_mod`s under the same `pep_seq`
  #   (note that each `pep_seq_mod` is represented by its best NL)
  # ppe_rank2 --- NLs under the same `pep_seq_mod`
  # pep_rank at output --- `pep_seq`s under the same `query`
  
  
  ## 1. compile `uniq_id`, `uniq_id2` and `pep_rank2`
  x[, uniq_id := paste(pep_isdecoy, pep_scan_num, raw_file, pep_seq, sep = ".")]
  x[, "pep_ivmod2" := gsub(" [\\(\\[]\\d+[\\)\\[]$", "", pep_ivmod)]
  x[, uniq_id2 := paste(uniq_id, pep_ivmod2, sep = ".")]

  if (para) {
    x <- x[order(x[["uniq_id2"]]), ] # for group split

    cl <- parallel::makeCluster(getOption("cl.cores", n_cores))
    xs <- parallel::clusterApply(
      cl, split(x, find_chunkbreaks(x[["uniq_id2"]], n_cores)), calcpeprank_1)
    parallel::stopCluster(cl)
    
    x <- data.table::rbindlist(xs, use.names = FALSE)
    rm(list = c("xs"))
  }
  else {
    x[, pep_rank2 := data.table::frank(-pep_score, ties.method = "min"), 
      by = list(uniq_id2)]
  }
  

  ## 2 separate the best NL (x0) from the rest (y0, z0) at the same `pep_seq_mod`
  # 
  # the same pep_seq_mod only differ by NLs:
  # 
  # uniq_id2                                            pep_rank      pep_ivmod
  # 0.14332.1.ENGGTEDMFVMYLGNKDASK.00000007007000500000    1   00000007007000500000 (1)
  # 0.14332.1.ENGGTEDMFVMYLGNKDASK.00000007007000500000    1   00000007007000500000 (2)
  # 0.14332.1.ENGGTEDMFVMYLGNKDASK.00000007007000500000    1   00000007007000500000 (3)
  # 0.14332.1.ENGGTEDMFVMYLGNKDASK.00000007007000500000    1   00000007007000500000 (4)
  # one pep_seq_mod at different NLs can results in multiple rows in x0 
  # 
  # x0 --- best NL at a pep_seq_mod and only the first one if with ties in NLs
  # y0 --- not the best NL at a pep_seq_mod
  # z0 --- still the best NL at a pep_seq_mod but tied with the first one
  
  # need to order after ranking (better NLs first)
  x <- x[order(-pep_score), by = list(uniq_id2)] 
  x[, nl_id := seq_len(.N), by = uniq_id2]
  x0 <- x[x$pep_rank2 == 1L & x$nl_id == 1L, ]
  y0 <- x[x$pep_rank2 > 1L, ]
  z0 <- x[pep_rank2 == 1L & x$nl_id > 1L, ]
  x0[["pep_rank2"]] <- NULL
  y0[["pep_rank2"]] <- NULL
  z0[["pep_rank2"]] <- NULL
  x0[["nl_id"]] <- NULL
  y0[["nl_id"]] <- NULL
  z0[["nl_id"]] <- NULL
  rm(list = c("x"))

  
  ## 3. keep the top-3 `pep_seq_mod`
  # the `pep_rank` here is after the "collapse" of NLs by only using the best;
  # net effect: the top-3 pep_seq_mod's, each represented by its best NL;
  # nevertheless, there can be ties in NL.
  message("\tSubset peptides by modifications: \"topn_mods_per_seq <= ", 
          topn_mods_per_seq, "\".")

  if (para) {
    x0 <- x0[order(x0[["uniq_id"]]), ] # for group split

    cl <- parallel::makeCluster(getOption("cl.cores", n_cores))
    x0s <- parallel::clusterApply(
      cl, split(x0, find_chunkbreaks(x0[["uniq_id"]], n_cores)), calcpeprank_2)
    parallel::stopCluster(cl)
    
    x0 <- data.table::rbindlist(x0s, use.names = FALSE)
    rm(list = c("x0s"))
  }
  else {
    x0[, pep_rank := data.table::frank(-pep_score, ties.method = "min"), 
       by = list(uniq_id)]
  }
  
  x0 <- x0[pep_rank <= topn_mods_per_seq, ]
  x0[["pep_rank"]] <- NULL

  
  ## 4 `pep_locprob` (the same `pep_seq`, different `pep_seq_mod`)
  # 4.1 separations into ambiguous x0 and non-ambiguous x1
  x0 <- x0[ , n_pep_seq_mod := .N, by = .(uniq_id)]
  x1 <- x0[n_pep_seq_mod == 1L, ] # single pep_seq_mod, no location ambiguity
  x0 <- x0[n_pep_seq_mod > 1L, ]
  x0[["n_pep_seq_mod"]] <- NULL
  x1[["n_pep_seq_mod"]] <- NULL
  
  # 4.2 probability and delta
  if (nrow(x0)) {
    locmod_indexes <- if (length(locmods))
      unname(mod_indexes[names(mod_indexes) %in% locmods])
    else 
      NULL
    
    if (length(locmod_indexes)) {
      message("\tCalculates peptide localization scores.")
      
      us <- split(x0[, c("uniq_id2", "pep_ivmod2", "pep_ms2_ideltas.")], 
                  x0[["uniq_id"]])

      probs <- lapply(us, findLocFracsDF, locmod_indexes)
      
      if (FALSE) {
        deltas <- lapply(probs, function (x) {
          if (all(is.na(x)))
            NA_real_
          else {
            # may be more NA values, e.g. 3L, than 2L
            # topx <- x[which_topx2(x, 2L)]
            topx <- x[which_topx2(x, 2L, na.last = FALSE)]
            abs(topx[1] - topx[2])
          }
        })
      }

      deltas <- lapply(probs, function (x) {
        x <- x[!is.na(x)]
        len <- length(x)
        
        if (len == 1L)
          x
        else if (len > 1L) {
          topx <- x[which_topx2(x, 2L)]
          abs(topx[1] - topx[2])
        }
        else 
          NA_real_
      })
      
      us <- mapply(function (x, y, z) {
        x[["pep_locprob"]] <- y
        x[["pep_locdiff"]] <- z
        x
      }, us, probs, deltas, 
      SIMPLIFY = FALSE, USE.NAMES = FALSE)
      
      us <- data.table::rbindlist(us)
      
      x0 <- quick_leftjoin(x0, us[, c("uniq_id2", "pep_locprob", "pep_locdiff")], 
                           by = "uniq_id2")
      
      rm(list = c("probs", "deltas", "us"))
    }
    else {
      x0[["pep_locprob"]] <- NA_real_
      x0[["pep_locdiff"]] <- NA_real_
    }
  }
  else {
    col_nms <- c(names(x0), "pep_locprob", "pep_locdiff")
    x0 <- data.table::data.table(matrix(ncol = length(col_nms), nrow = 0L))
    colnames(x0) <- col_nms
    rm(list = "col_nms")
  }
  
  # 4.3 adds back x1
  if (nrow(x1)) {
    x1[["pep_locprob"]] <- 1.0
    x1[["pep_locdiff"]] <- 1.0
    x0 <- data.table::rbindlist(list(x0, x1), use.names = FALSE)
  }
  rm(list = c("x1"))
  
  # 4.4 adds back z0
  # ok to replace dplyr::left_join here:
  #   the same number of rows between the new and the old z0
  z0 <- quick_leftjoin(z0, x0[, c("uniq_id2", "pep_locprob", "pep_locdiff")], 
                       by = "uniq_id2")
  x0 <- data.table::rbindlist(list(x0, z0), use.names = FALSE)
  rm(list = "z0")
  
  # 4.5 adds back y0
  if (nrow(y0)) {
    y0[["pep_locprob"]] <- NA_real_
    y0[["pep_locdiff"]] <- NA_real_
    x0 <- data.table::rbindlist(list(x0, y0), use.names = FALSE)
  }
  rm(list = "y0")
  
  ## 5. clean-ups
  x0 <- x0[, -c("uniq_id", "uniq_id2")]
  x0[ , "pep_score" := round(pep_score, 2L)]
  x0[ , "pep_locprob" := round(pep_locprob, 2L)]
  x0[ , "pep_locdiff" := round(pep_locdiff, 2L)]

  # 5.1 NEW `pep_rank`s across different `pep_seq`s under the same `query`
  # (this is different to the earlier `uniq_id` to differentiate LOCATIONS)
  # 
  # e.g., if MS evidence is equally feasible for : 
  #   pep_seq_1: EVEEDSEDEEMSEDE[E]D[D]S[SG]EEVVIPQKK
  #   pep_seq_2: EVEEDSEDEEMSEDE[D]D[S]S[GE]EEVVIPQKK
  # both will be kept (at the same rank)
  
  message("\tSubset peptide sequences by query: \"topn_seqs_per_query <= ", 
          topn_seqs_per_query, "\".")
  
  x0[, uniq_id3 := paste(pep_isdecoy, pep_scan_num, raw_file, sep = ".")]
  
  if (para) {
    x0 <- x0[order(x0[["uniq_id3"]]), ]

    cl <- parallel::makeCluster(getOption("cl.cores", n_cores))
    x0s <- parallel::clusterApply(cl, 
      split(x0, find_chunkbreaks(x0[["uniq_id3"]], n_cores)), calcpeprank_3)
    parallel::stopCluster(cl)
    
    x0 <- data.table::rbindlist(x0s, use.names = FALSE)
    rm(list = c("x0s"))
  }
  else {
    x0[, pep_rank := data.table::frank(-pep_score, ties.method = "min"), 
       by = list(uniq_id3)]
  }
  
  x0 <- x0[pep_rank <= topn_seqs_per_query, ]
  data.table::setorder(x0, uniq_id3, -pep_score)
  x0$uniq_id3 <- NULL
  
  x0 <- x0[, pep_isdecoy := as.logical(pep_isdecoy)]
  x0[["pep_ms2_ideltas."]] <- NULL
  x0[["pep_ivmod2"]] <- NULL
  qs::qsave(x0, file.path(out_path, "temp", "peploc.rds"), preset = "fast")
  
  invisible(x0)
}


#' Helper for parallel frank
#' 
#' @param x A data.table object
calcpeprank_1 <- function (x)
{
  x[, pep_rank2 := data.table::frank(-pep_score, ties.method = "min"), 
    by = "uniq_id2"]
}


#' Helper for parallel frank
#' 
#' @param x0 A data.table object
calcpeprank_2 <- function (x0)
{
  x0[, pep_rank := data.table::frank(-pep_score, ties.method = "min"), 
     by = "uniq_id"]
}


#' Helper for parallel frank
#' 
#' @param x0 A data.table object
calcpeprank_3 <- function (x0) 
{
  x0[, pep_rank := data.table::frank(-pep_score, ties.method = "min"), 
     by = "uniq_id3"]
}


#' Finds the best off-set in precursor masses.
#' 
#' @param x A data.table object
find_bestnotch <- function (x)
{
  # favors pep_ms1_offset == 0
  cols <- names(x)
  x <- data.table::rbindlist(list(x[x$pep_ms1_offset == 0], 
                                  x[x$pep_ms1_offset != 0]), 
                             use.names = FALSE)
  
  if ("pep_score" %in% cols) {
    x[, pep_rank0 := data.table::frank(-pep_score, ties.method = "first"), 
      by = list(query_id)]
  }
  else if ("pep_prob" %in% cols) {
    x[, pep_rank0 := data.table::frank(pep_prob, ties.method = "first"), 
      by = list(query_id)]
  }
  else {
    return(x)
  }

  # the best query at each query_id
  g <- x[, c("pep_rank0", "query_id", "pep_ms1_offset")]
  g <- g[g$pep_rank0 == 1L, ]
  g[["pep_rank0"]] <- NULL
  g[["keep"]] <- TRUE
  g[, uid := paste(query_id, pep_ms1_offset, sep = ".")]
  g[["pep_ms1_offset"]] <- g[["query_id"]] <- NULL
  
  x[, uid := paste(query_id, pep_ms1_offset, sep = ".")]
  x <- quick_leftjoin(x, g, by = "uid")
  x <- x[x$keep, ]
  
  x[["keep"]] <- x[["pep_rank0"]] <- x[["uid"]] <- x[["query_id"]] <- NULL
  
  x
}


#' Finds the break points
#' 
#' @param vals An order vector.
#' @param n_chunks The number of chunks.
#' 
#' @examples 
#' \donttest{
#' library(mzion)
#' 
#' vals <- c(rep("B", 6), rep("A", 6), rep("E", 5), rep("D", 5), rep("C", 7))
#' brs <- mzion:::find_chunkbreaks(vals, 3L)
#' split(vals, brs)
#' }
find_chunkbreaks <- function (vals, n_chunks) 
{
  lenv <- length(vals)
  n_chunks <- min(length(unique(vals)), n_chunks)
  
  if (n_chunks == 1L)
    return(rep_len(1L, lenv))
  
  pos <- floor(lenv/n_chunks) * 1:n_chunks
  len <- length(pos)
  pos[len] <- lenv
  
  for (i in 1:(len - 1L)) {
    icr <- pos[i]
    inx <- icr + 1L
    vcr <- vals[icr]
    vnx <- vals[inx]
    
    while(vcr == vnx) {
      icr <- inx
      inx <- inx + 1L
      vcr <- vals[icr]
      vnx <- vals[inx]
    }
    
    pos[i] <- icr
  }
  
  ds <- c(pos[1], diff(pos))
  rep.int(seq_along(pos), ds)
}


#' Finds the localization fractions of STY.
#'
#' Counting statistics.
#'
#' @param df A data frame containing columns \code{pep_ivmod2} and
#'   \code{pep_ms2_ideltas.}.
#' @param locmod_indexes A vector to the modification indexes.
#'
#' @examples
#' library(mzion)
#' 
#' locmod_indexes <- c("8", "9", "a")
#' df <- data.frame(pep_ivmod2 = c("0080000", "0009000"), pep_ms2_ideltas. = NA)
#' df$pep_ms2_ideltas.[1] <- list(c(1,2,3,4,5,6,8,9,10,11,12,13,14))
#' df$pep_ms2_ideltas.[2] <- list(c(1,2,3,4,5,6,8,9,10,12,13,14))
#' ans <- mzion:::findLocFracsDF(df, locmod_indexes)
#'
#' # Variable Acetyl (K) and fixed TMT6plex (K)
#' locmod_indexes <- "4"
#' df <- data.frame(pep_ivmod2 = c("04000000", "00000000"), pep_ms2_ideltas. = NA)
#' df$pep_ms2_ideltas.[1] <- list(c(2,5,6,7,9,11,14,15,16))
#' df$pep_ms2_ideltas.[2] <- list(c(1,2,5,6,7,9,11,14))
#' ans <- mzion:::findLocFracsDF(df, locmod_indexes)
#'
#' df <- data.frame(pep_ivmod2 = c("0004000", "4000000"), pep_ms2_ideltas. = NA)
#' df$pep_ms2_ideltas.[1] <- list(c(2,3,4,5,6,8,10,11,12,14))
#' df$pep_ms2_ideltas.[2] <- list(c(4,5,6,8,10,14))
#' ans <- mzion:::findLocFracsDF(df, locmod_indexes)
#'
#' df <- data.frame(pep_ivmod2 = c("00040402", "00040204", "00020202"), 
#'   pep_ms2_ideltas. = NA)
#' df$pep_ms2_ideltas.[1] <- list(c(1,4,6,7,9,10,11,12,15,16))
#' df$pep_ms2_ideltas.[2] <- list(c(1,4,11,12,15,16))
#' df$pep_ms2_ideltas.[3] <- list(c(1,4,11,12,15,16))
#' ans <- mzion:::findLocFracsDF(df, locmod_indexes)
#'
#' locmod_indexes <- c("2", "4")
#' df <- data.frame(pep_ivmod2 = c("0004004000402", "0002004000402", "0004004000204"), 
#'   pep_ms2_ideltas. = NA)
#' df$pep_ms2_ideltas.[1] <- list(c(1,3,4,5,6,7,8,10,14,15,16,17,18,19))
#' df$pep_ms2_ideltas.[2] <- list(c(4,5,6,7,8,10,14,15,16,17,18,19))
#' df$pep_ms2_ideltas.[3] <- list(c(1,3,4,5,6,7,8,10,14,16,17,18,19))
#' ans <- mzion:::findLocFracsDF(df, locmod_indexes)
#'
#' # Variable Digly (K), TMT6plex+Digly (K) fixed TMT6plex (K)
#' # 9 - TMT6plex+Digly (K)
#' # 6 - Digly (K)
#' # 2 - TMT6plex (K)
#' # different lengths but equal mass: 26 and 9
#' locmod_indexes <- c(2, 6, 9)
#' df <- data.frame(pep_ivmod2 = c("000000020000000602", "000000090000000002"), 
#'   pep_ms2_ideltas. = NA)
#' df$pep_ms2_ideltas.[1] <- list(c(1,2,3,4,5,6,19,20,21,22,23))
#' df$pep_ms2_ideltas.[2] <- list(c(1,2,3,4,5,6,19,20,      23))
#' ans <- mzion:::findLocFracsDF(df, locmod_indexes)
findLocFracsDF <- function (df, locmod_indexes = NULL) 
{
  ivms <- df[["pep_ivmod2"]]
  seqs <- df[["pep_ms2_ideltas."]]
  ivms <- .Internal(strsplit(ivms, "", fixed = FALSE, perl = FALSE, useBytes = FALSE))
  naas <- length(ivms[[1]])
  
  # if (is.null(locmod_indexes))
  #   ps <- lapply(ivms, function (x) which(x != "0"))
  # else
  #   ps <- lapply(ivms, function (x) which(x %in% locmod_indexes))
  
  ps <- lapply(ivms, function (x) which(x %in% locmod_indexes))
  ns <- .Internal(unlist(lapply(ps, length), recursive = FALSE, use.names = FALSE))
  oks <- ns > 0L

  # (1) set aside entries without the target modifications, e.g. No STY sites
  ans <- numeric(length(ps))
  ans[!oks] <- NA_real_
  ps <- ps[oks]
  seqs <- seqs[oks]
  ns <- ns[oks]
  
  # (2) single non-trivial entry and thus unambiguous
  lenp <- length(ps)
  
  if (!lenp)
    return(ans)

  if (lenp == 1L) {
    ans[oks] <- 1.00
    return(ans)
  }

  # (3) multiple entries (lenp > 1L)
  
  len <- lenp - 1L
  ncr <- nnx <- vector("integer", len)
  
  for (i in 1:len) {
    inx <- i + 1L
    
    pcr <- ps[[i]] # all(pcr <= naas)
    pnx <- ps[[inx]]
    seqcr <- seqs[[i]]
    seqnx <- seqs[[inx]]
    lencr <- ns[[i]]
    lennx <- ns[[inx]]
    
    # ps different lengths: see the Digly (K) and TMT (K) example
    bmin <- min(pcr[[1]], pnx[[1]])
    bmax <- max(pcr[[lencr]], pnx[[lennx]]) # bmax <= naas
    
    # b-ions
    bcr <- seqcr <= naas
    bnx <- seqnx <= naas
    bseqcr <- seqcr[bcr]
    bseqnx <- seqnx[bnx]
    
    # y-ions
    yseqcr <- seqcr[!bcr] - naas
    yseqnx <- seqnx[!bnx] - naas
    ymax <- naas - bmin
    ymin <- naas - bmax
    
    # b & y
    ncr[[i]] <- sum(bseqcr >= bmin & bseqcr < bmax) + sum(yseqcr > ymin & yseqcr <= ymax)
    nnx[[i]] <- sum(bseqnx >= bmin & bseqnx < bmax) + sum(yseqnx > ymin & yseqnx <= ymax)
  }
  
  ans[oks] <- concatFracs(ncr, nnx)
  
  ans
}


#' Concatenates localization fractions.
#'
#' The probability of the second localization with \eqn{y} in \eqn{x = 0; y = 6}
#' is not any more probable than that in \eqn{x = 0; y = 1}. This is different
#' to the binomial model in A-score, which will lead to the finding that the
#' probability of localization 2 at \eqn{x = 0; y = 6} is much more probable.
#'
#' @param x A vector of counts of MS2 matches between two adjacent STY sites
#'   (for a preceding match: pep_ivmod).
#' @param y A vector of counts of MS2 matches between two adjacent STY sites
#'   (for a next match: pep_ivmod).
#' @param d A small positive number to handle value \eqn{0}.
#'
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' mzion:::concatFracs(c(3, 3, 5), c(2, 1, 3))
#' mzion:::concatFracs(c(0, 6), c(1, 3))
#' mzion:::concatFracs(c(0, 6), c(0, 3))
#' mzion:::concatFracs(c(0, 2), c(0, 2))
#' mzion:::concatFracs(c(1, 2), c(1, 2))
#' 
#' mzion:::concatFracs(c(1, 2), c(1, 4))
#' mzion:::concatFracs(c(0, 2), c(0, 4))
#' mzion:::concatFracs(c(1, 2), c(0, 4)) # near 1 0 0
#' 
#' mzion:::concatFracs(0, 2)
#' mzion:::concatFracs(2, 0)
#' mzion:::concatFracs(0, 0) # should not occur
#' }
concatFracs <- function (x, y, d = .001) 
{
  len <- length(x)
  
  if (identical(x, y))
    return(rep(1/(len + 1L), (len + 1L)))
  
  x <- x + d
  y <- y + d
  
  if (len <= 1L)
    return(c(x, y)/sum(x, y))
  
  for (i in 2:len) {
    fct <- y[i-1]/x[i]
    x[i] <- x[i] * fct
    y[i] <- y[i] * fct
  }
  
  ans <- c(x[1], y)
  
  ans/sum(ans)
}


#' Interpolates missing values in a time series.
#'
#' From \code{forecast}. 
#' 
#' @param linear Linear.
#' @inheritParams tsoutliers
na.interp <- function (x, lambda = NULL, 
                       linear = (frequency(x) <= 1 | 
                                   sum(!is.na(x)) <= 2 * frequency(x))) 
{
  missng <- is.na(x)
  
  if (sum(missng) == 0L) 
    return(x)

  origx <- x
  rangex <- range(x, na.rm = TRUE)
  drangex <- rangex[2L] - rangex[1L]
  
  if (is.null(tsp(x))) 
    x <- ts(x)

  if (length(dim(x)) > 1) {
    if (NCOL(x) == 1) 
      x <- x[, 1]
    else 
      stop("The time series is not univariate.")
  }
  
  if (!is.null(lambda)) {
    x <- BoxCox(x, lambda = lambda)
    lambda <- attr(x, "lambda")
  }
  
  freq <- frequency(x)
  tspx <- tsp(x)
  n <- length(x)
  tt <- 1:n
  idx <- tt[!missng]
  
  if (linear) 
    x <- ts(approx(idx, x[idx], tt, rule = 2)$y)
  else {
    if ("msts" %in% class(x)) 
      K <- pmin(trunc(attributes(x)$msts/2), 20L)
    else 
      K <- min(trunc(freq/2), 5)

    X <- cbind(fourier(x, K), 
               poly(tt, degree = pmin(pmax(trunc(n/10), 1), 6L)))

    fit <- lm(x ~ X, na.action = na.exclude)
    pred <- predict(fit, newdata = data.frame(X))
    x[missng] <- pred[missng]
    fit <- mstl(x, robust = TRUE)
    sa <- seasadj(fit)
    sa <- approx(idx, sa[idx], 1:n, rule = 2)$y
    seas <- seasonal(fit)
    
    if (NCOL(seas) > 1) 
      seas <- rowSums(seas)
    
    x[missng] <- sa[missng] + seas[missng]
  }
  
  if (!is.null(lambda)) 
    x <- InvBoxCox(x, lambda = lambda)
  
  tsp(x) <- tspx
  
  if (!linear & (max(x) > rangex[2L] + 0.5 * drangex | min(x) < 
                 rangex[1L] - 0.5 * drangex)) 
    return(na.interp(origx, lambda = lambda, linear = TRUE))
  else 
    return(x)
}


#' Checks if data are constant.
#' 
#' @param x A vector.
is.constant <- function (x) 
{
  x <- as.numeric(x)
  y <- rep(x[1], length(x))
  
  return(isTRUE(all.equal(x, y)))
}


#' Identifies and replace outliers in a time series.
#' 
#' From \code{forecast}.
#' 
#' @param x Time series
#' @param lambda Box-Cox transformation parameter. If lambda="auto", then a
#'   transformation is automatically selected using BoxCox.lambda. The
#'   transformation is ignored if NULL. Otherwise, data transformed before model
#'   is estimated.
#' @param iterate The number of iterations.
tsoutliers <- function (x, iterate = 2, lambda = NULL) 
{
  n <- length(x)
  freq <- frequency(x)
  missng <- is.na(x)
  nmiss <- sum(missng)
  
  xx <- if (nmiss > 0L) 
    na.interp(x, lambda = lambda)
  else 
    x
  
  if (is.constant(xx)) 
    return(list(index = integer(0), replacements = numeric(0)))
  
  tt <- 1:n
  mod <- supsmu(tt, xx)
  resid <- xx - mod$y
  
  if (nmiss) resid[missng] <- NA

  resid.q <- quantile(resid, probs = c(0.25, 0.75), na.rm = TRUE)
  iqr <- diff(resid.q)
  limits <- resid.q + 3 * iqr * c(-1, 1)
  
  outliers <- if ((limits[2] - limits[1]) > 1e-14) 
    which((resid < limits[1]) | (resid > limits[2]))
  else 
    numeric(0)
  
  x[outliers] <- NA
  x <- na.interp(x, lambda = lambda)
  
  if (iterate > 1) {
    tmp <- tsoutliers(x, iterate = 1, lambda = lambda)
    
    if (length(tmp$index)) {
      outliers <- sort(unique(c(outliers, tmp$index)))
      x[outliers] <- NA
      
      if (sum(!is.na(x)) == 1L) 
        x[is.na(x)] <- x[!is.na(x)]
      else 
        x <- na.interp(x, lambda = lambda)
    }
  }
  
  invisible(list(index = outliers, replacements = x[outliers]))
}


#' Removes duplicated entries in 13C results.
#'
#' Removes "n_13c != 0" entries with better matches at "n_13c == 0". By each
#' module as the same combination of raw_file + pep_scan_num can also be
#' duplicated across modification modules.
#'
#' @param df A data frame.
#' @inheritParams matchMS
rm_dup13c <- function (df, n_13c = 0L)
{
  if (length(n_13c) == 1L && n_13c == 0L) 
    return(df)

  esscols <- c("pep_ms1_offset", "pep_scan_num", "raw_file")
  cols <- names(df)
  
  if (!all(esscols %in% cols))
    return(df)
  
  key <- if ("pep_score" %in% cols)
    1L
  else if ("pep_prob" %in%  cols)
    2L
  else
    0L
  
  if (!key)
    return(df)
  
  rows <- df$pep_ms1_offset == 0
  df0 <- df[rows, ]
  df1 <- df[!rows, ]
  rm(list = c("rows", "df"))
  
  # no need of `pep_isdecoy`
  ids0 <- with(df0, paste(raw_file, gsub("\\.\\d+$", "", pep_scan_num), sep = "."))
  ids1 <- with(df1, paste(raw_file, gsub("\\.\\d+$", "", pep_scan_num), sep = "."))

  oks <- ids1 %in% unique(ids0)
  df1a <- df1[!oks, ]
  df1b <- df1[oks, ]
  rm(list = c("oks", "df1"))
  
  oks <- ids0 %in% unique(ids1)
  df0a <- df0[!oks, ]
  df0b <- df0[oks, ]
  rm(list = c("ids0", "ids1", "oks", "df0"))
  
  dfb <- dplyr::bind_rows(df0b, df1b)
  rm(list = c("df0b", "df1b"))
  
  if (nrow(dfb)) {
    dfb$scan_nums. <- gsub("\\.\\d+$", "", dfb$pep_scan_num)
    dfb$query_id <- with(dfb, paste(raw_file, scan_nums., sep = "."))
    dfb$scan_nums. <- NULL
    
    dfb <- split(dfb, dfb$query_id)
    
    # if best(x0) better than best(x1) and x0 is decoy -> still keep x0
    if (key == 1L) {
      dfb <- lapply(dfb, function (x) {
        rows <- x$pep_ms1_offset == 0
        x0 <- x[rows, ]
        x1 <- x[!rows, ]
        s0 <- max(x0$pep_score, na.rm = TRUE)
        s1 <- max(x1$pep_score, na.rm = TRUE)
        if (s1 - s0 > .23) x1 else x0 # see below; can be just 0
      })
    }
    else {
      dfb <- lapply(dfb, function (x) {
        rows <- x$pep_ms1_offset == 0
        x0 <- x[rows, ]
        x1 <- x[!rows, ]
        s0 <- min(x0$pep_prob, na.rm = TRUE)
        s1 <- min(x1$pep_prob, na.rm = TRUE)
        if (s1 / s0 < .95) x1 else x0 # 10^-(.23/10); can be just 1
      })
    }
    
    dfb <- dplyr::bind_rows(dfb)
    dfb$query_id <- NULL
    df <- dplyr::bind_rows(df0a, df1a, dfb)
  }
  else {
    df <- dplyr::bind_rows(df0a, df1a)
  }
}


#' SILAC
#'
#' Searches against mixed SILAC groups (heave and light mixed into one sample).
#'
#' @param this_call An expression from match.call.
#' @param aa_masses An amino acid look-ups.
#' @inheritParams matchMS
matchMS_silac_mix <- function (silac_mix = list(base = NULL, heavy = c("K8 (K)", "R10 (R)")), 
                               this_call, out_path, mgf_path, aa_masses) 
{
  message("Searches against SILAC groups ", 
          "(heavy, light etc. mixed into one sample)")
  message("[x] For reprocessing (with new score function) ", 
          "delete cached 'pepscores_[...]' and 'calc_pepscores.rda'.\n")
  
  lapply(c("silac_mix", "mgf_path", "this_call", "out_path"), function (x) {
    if (is.null(x)) stop("`", x, "` cannot be NULL.")
  })
  
  if (!is.list(silac_mix)) {
    stop("Supply silac_mix groups as lists, e.g., \n\n", 
         "  # unlabelled base (see ?add_unimod for more)\n", 
         "  silac_mix = list(base = c(fixedlabs = NULL, varlabs = NULL), \n", 
         "                   grpC = c(fixedlabs = c(\"Label:13C(6) (R)\", ...), \n", 
         "                            varlabs   = c(\"Label:13C(2) (Protein N-term)\", ...), \n", 
         "                   grpN = c(fixedlabs = c(\"Label:15N(2) (K)\", ...), \n", 
         "                            varlabs   = c(\"Label:15N(-1) (N)\", ...), \n\n", 
         "  # labelled base\n", 
         "  silac_mix = list(base = c(fixedlabs = ..., varlabs = ...), \n", 
         "                   grpC = c(fixedlabs = ..., varlabs = ...), \n", 
         "                   grpN = c(fixedlabs = ..., varlabs = ...), \n\n")
  }
  
  nms <- names(silac_mix)
  
  if (!"base" %in% nms) {
    warning("Required `base` group not found; assume: base = NULL")
    nms <- c("base", nms)
    silac_mix <- c(list(base = NULL), silac_mix)
  }
  
  if (all(unlist(lapply(silac_mix, is.null))))
    stop("`silac_mix` groups cannot be all NULL.")
  
  if ((len <- length(nms)) < 2L)
    stop("Need at least two `silac_mix` groups.")
  
  out_paths <- vector("list", len)
  
  for (i in seq_len(len)) {
    sub_call <- this_call
    sub_nm <- nms[i]
    sub_path <- out_paths[[i]] <- create_dir(file.path(out_path, sub_nm))

    if (file.exists(file.path(sub_path, "psmQ.txt"))) 
      next
    
    if (i > 1L) {
      if (file.exists(mgf_call <- file.path(out_paths[[1]], "Calls", "load_mgfs.rda"))) {
        sub_call_path <- create_dir(file.path(sub_path, "Calls"))
        file.copy(mgf_call, file.path(sub_call_path, "load_mgfs.rda"), overwrite = TRUE)
      }
    }
    
    sub_mods <- silac_mix[[sub_nm]]
    
    if (is.null(sub_mods)) {
      this_aa <- NULL
    }
    else {
      this_aa <- aa_masses

      # fixedlabs and varlabs
      lab_nms <- names(sub_mods)
      oks <- grepl("fixedlabs\\d*", lab_nms)
      fixedlabs <- unname(sub_mods[oks])
      varlabs <- unname(sub_mods[!oks])

      if (!length(fixedlabs)) fixedlabs <- NULL
      if (!length(varlabs)) varlabs <- NULL
      
      sub_call$fixedlabs <- fixedlabs
      sub_call$varlabs <- varlabs
      
      rm(list = c("lab_nms", "oks", "fixedlabs", "varlabs"))
    }
    
    rm(list = "sub_mods")
    
    sub_call$fixedmods <- eval(sub_call$fixedmods)
    sub_call$out_path <- sub_path
    sub_call$mgf_path <- mgf_path
    sub_call$bypass_silac_mix <- TRUE
    sub_call$silac_mix <- NULL
    sub_call$bypass_from_pepscores <- FALSE # flowthrough: silac + noenzyme
    sub_call$aa_masses <- this_aa

    df <- tryCatch(eval(sub_call), error = function (e) NULL)
    
    if (is.null(df)) 
      warning("No results at `silac_mix = ", sub_nm, "`.")
    
    rm(list = c("df"))
    gc()
  }
  
  message("Combine mixed SILAC results.")
  comine_PSMsubs(sub_paths = out_paths, groups = nms, out_path = out_path)
  gc()
  
  enzyme <- as.character(this_call[["enzyme"]])
  
  if (isTRUE(enzyme == "noenzyme"))
    return(NULL)
  
  message("Done (mixed SILAC search).")
  options(show.error.messages = FALSE)
  stop()
}


#' Searches by sets of parameters.
#'
#' @param grp_args The names of arguments in \code{par_groups}.
#' @param mgf_paths The paths to MGF (with group searches).
#' @param this_call An expression from match.call.
#' @inheritParams matchMS
matchMS_par_groups <- function (par_groups = NULL, grp_args = NULL, 
                                mgf_paths = NULL, this_call = NULL, 
                                out_path = NULL) 
{
  message("Multiple searches by parameter groups...")
  message("[x] For reprocessing (with new score function) ", 
          "delete cached 'pepscores_[...]' and 'calc_pepscores.rda'.\n", 
          "[x] To bypass cached results, use \"use_ms1_cache = FALSE\".\n")
  
  lapply(c("par_groups", "grp_args", "this_call", "out_path"), function (x) {
    if (is.null(x))
      stop("`", x, "` cannot be NULL.")
  })
  
  if (!is.list(par_groups)) {
    stop("Supply `par_groups` as list, e.g., \n\n", 
         "par_groups = list(\n", 
         "  list(mgf_path  = \"~/mzion/my_proj/mgfs/grp_1\"", ",\n", 
         "       fixedmods = c(\"Carbamidomethyl (C)\")", "),\n", 
         "  list(mgf_path  = \"~/mzion/my_proj/mgfs/grp_2\"", ",\n", 
         "       fixedmods = c(\"Carbamidomethyl (C)\", \"K8 (K)\", \"R10 (R)\")", ")\n", 
         "  )")
  }
  
  if (all(unlist(lapply(par_groups, is.null))))
    stop("`par_groups` cannot be all NULL.")
  
  nms <- names(par_groups)
  len <- length(nms)
  
  if (len < 2L)
    stop("Need at least two `par_groups`.")
  
  ans <- out_paths <- vector("list", len)
  
  for (i in seq_len(len)) {
    sub_call <- this_call
    sub_nm <- nms[i]
    sub_pars <- par_groups[[i]]
    sub_path <- out_paths[[i]] <- create_dir(file.path(out_path, sub_nm))
    
    file_peploc <- file.path(sub_path, "temp", "peploc.rds")
    
    if (file.exists(file_peploc)) {
      ans[[i]] <- qs::qread(file_peploc)
      next
    }
    
    for (arg in grp_args) 
      sub_call[[arg]] <- sub_pars[[arg]]
    
    sub_call$out_path <- sub_path
    sub_call$bypass_par_groups <- TRUE
    sub_call$bypass_from_protacc <- TRUE
    sub_call$par_groups <- NULL
    
    local({
      mgf_path <- eval(sub_call$mgf_path)
      checkMGF(mgf_path, grp_args = NULL, error = "stop")
    })
    
    df <- tryCatch(eval(sub_call), error = function (e) NULL)
    
    if (!file.exists(file_peploc)) 
      stop("File not found: ", file_peploc)
    
    ans[[i]] <- if (is.null(df)) qs::qread(file_peploc) else df
    rm(list = "df")
    
    if (is.null(ans[[i]])) 
      warning("No results at `par_groups = ", sub_nm, "`.")
    
    gc()
  }
  
  # map `raw_file` and `scan_title` before data combination
  if (!is.null(mgf_paths)) {
    for (i in seq_along(ans)) {
      ans[[i]] <- map_raw_n_scan(ans[[i]], mgf_paths[[i]])
      ans[[i]]$pep_group <- nms[i]
    }
  }
  
  out <- dplyr::bind_rows(ans)
  rm(list = "ans")
  dir.create(file.path(out_path, "temp"), showWarnings = FALSE, recursive = FALSE)
  qs::qsave(out, file.path(out_path, "temp", "peploc.rds"), preset = "fast")
  qs::qsave(out_paths, file.path(out_path, "temp", "out_paths.rds"), preset = "fast")
  rm(list = "out")
  
  gc()
  
  this_call$bypass_pepmasses <- TRUE
  this_call$bypass_bin_ms1 <- TRUE
  this_call$bypass_mgf <- TRUE
  this_call$bypass_ms2match <- TRUE
  this_call$bypass_pepscores <- TRUE
  this_call$bypass_pepfdr <- TRUE
  this_call$bypass_peploc <- TRUE
  this_call$bypass_par_groups <- TRUE
  this_call$bypss_mgf_checks <- TRUE
  this_call$from_group_search <- TRUE
  this_call$par_groups <- NULL
  
  out <- tryCatch(eval(this_call), error = function (e) NULL)
  
  message("Done (group search).")
  
  invisible(out)
}


#' Adds fixedlab masses to aa_masses
#' 
#' @param aa_masses A look-up of amino-acid residue masses.
#' @inheritParams matchMS
add_fixedlab_masses <- function (fixedlabs, aa_masses)
{
  # not yet check the validity of fixedlabs
  # ...
  # not yet test multiple sites, e.g., Oxidation (M) and Carbamyl (M)
  # ...
  
  umods <- lapply(fixedlabs, find_unimod)
  monos <- unlist(lapply(umods, `[[`, "monomass"), use.names = FALSE)
  sites <- unlist(lapply(umods, `[[`, "position_site"), use.names = FALSE)
  names(monos) <- sites
  
  # e.g. the same site to both N and C labels
  us <- unique(sites)
  ds <- unlist(lapply(us, function (x) sum(monos[names(monos) == x])))
  names(ds) <- us
  
  idxes <- match(us, names(aa_masses))
  aa_masses[idxes] <- aa_masses[idxes] + ds
  
  aa_masses
}


#' Noenzyme search.
#'
#' @param this_call An expression from match.call.
#' @param silac_noenzyme Logical; is the search a combination of SILAC and
#'   noenzyme.
#' @param groups_noenzyme Logical; is the search a combination of group search
#'   and noenzyme.
#' @inheritParams matchMS
matchMS_noenzyme <- function (this_call = NULL, min_len = 7L, max_len = 40L, 
                              fasta = NULL, out_path = NULL, mgf_path = NULL, 
                              noenzyme_maxn = 0L, quant = "none", 
                              silac_noenzyme = FALSE, 
                              groups_noenzyme = FALSE) 
{
  if (groups_noenzyme)
    stop("Not yet support group searches with no enzyme specificity")
  
  message("Searches with no enzyme specificity...")
  message("[x] For reprocessing (with new score function) ", 
          "delete cached 'pepscores_[...]' and 'calc_pepscores.rda'.\n")
  
  size <- local({
    if (noenzyme_maxn) 
      return (noenzyme_maxn)
    
    mouse_fasta_size <- 11 
    fasta_size <- sum(unlist(lapply(fasta, file.size)))/1024^2
    
    # large RAM -> large `fct_mem`
    fct_mem <- local({
      mgf_files <- list.files(mgf_path, pattern = "\\.mgf$", full.names = TRUE)
      fct_mgf <- max(1, sum(unlist(lapply(mgf_files, file.size)))/1024^3)
      
      ans <- tryCatch(
        find_free_mem()/1024/fct_mgf,
        error = function (e) NA)
      
      if (is.na(ans))
        ans <- fct_mgf
      
      ans
    })
    
    # large fasta -> large `fct_fasta` (>= 1)
    fct_fasta <- max(1, fasta_size/mouse_fasta_size)
    
    # ^1.5, 0.6: 90% RAM aggressiveness with uniprot fasta human + mouse
    max(1L, floor(fct_mem/(fct_fasta^1.5) * .5))
  })
  
  len <- length(min_len:max_len)
  
  if (len > size) {
    message("Split data by peptide lengths. To overrule, may consider ", 
            "\"noenzyme_maxn = ", len + 1, "\".")

    if (size == 1L) {
      n_chunks <- len
      spans <- split(min_len:max_len, 1:len)
    }
    else {
      n_chunks <- ceiling(len/size)
      spans <- chunksplit(min_len:max_len, n_chunks, rightmost.closed = TRUE)
    }
    
    sub_nms <- out_paths <- vector("list", n_chunks)
    
    for (i in seq_len(n_chunks)) {
      sub_call <- this_call
      span <- spans[[i]]
      start <- span[1]
      end <- span[length(span)]
      sub_nm <- sub_nms[[i]] <- paste0("sub", i, "_", start, "_", end)
      sub_path <- out_paths[[i]] <- create_dir(file.path(out_path, sub_nm))
      
      ok <- file.exists(file.path(sub_path, "psmQ.txt"))
      
      if (ok) next
      
      if (i > 1L) {
        mgf_call <- file.path(out_paths[[1]], "Calls", "load_mgfs.rda")
        
        if (file.exists(mgf_call)) {
          sub_call_path <- create_dir(file.path(sub_path, "Calls"))
          file.copy(mgf_call, file.path(sub_call_path, "load_mgfs.rda"), overwrite = TRUE)
        }
      }
      
      sub_call$min_len <- start
      sub_call$max_len <- end
      sub_call$out_path <- sub_path
      sub_call$mgf_path <- mgf_path
      sub_call$bypass_noenzyme <- TRUE
      sub_call$bypass_from_pepscores <- TRUE
      sub_call$silac_noenzyme <- silac_noenzyme # silac + noenzyme
      
      ans <- tryCatch(eval(sub_call), error = function (e) NULL)
      
      message("Completed `min_len = ", start, "` to `max_len = ", end, "`.")
      gc()
    }
    
    # not necessary for silac_noenzyme
    file.copy(file.path(out_paths[[1]], "Calls"), out_path, recursive = TRUE)
    combine_ion_matches(out_path, out_paths, type = "ion_matches_")
    combine_ion_matches(out_path, out_paths, type = "reporters_")

    this_call$bypass_noenzyme <- TRUE
    this_call$bypass_pepmasses <- TRUE
    this_call$bypass_bin_ms1 <- TRUE
    this_call$bypass_mgf <- TRUE
    this_call$bypass_ms2match <- TRUE
    
    # (a) nested silac + noenzyme: flow through to psmQ -> combine -> done
    # 
    # (b) noenzyme only: early return bypass_from_pepscores -> next length range 
    #     ... -> all lengths -> combine ion_matches ... -> final psmQ
    
    silac_mix <- eval(this_call$silac_mix)
    
    # if (a) nested or (b) noenzyme only
    if (length(silac_mix) > 1L) {
      lapply(c("psmC.txt", "psmQ.txt", "psmT2.txt", "psmT3.txt"), function (file) {
        dfs <- lapply(out_paths, function (sub_path) {
          fi <- file.path(sub_path, file)
          
          if (file.exists(fi)) 
            df <- readr::read_tsv(fi, show_col_types = FALSE)
          else 
            df <- NULL
        })
        
        dfs <- dplyr::bind_rows(dfs)
        readr::write_tsv(dfs, file.path(out_path, file))
        
        invisible(NULL)
      })
      
      this_call$silac_mix <- NULL # just in case 
    }
    else {
      ans <- tryCatch(eval(this_call), error = function (e) NULL)
    }
    
    message("Done (noenzyme search).")
    options(show.error.messages = FALSE)
    stop()
  }
  else {
    this_call$bypass_noenzyme <- TRUE
    this_call$silac_noenzyme <- TRUE # for regular add_protacc
    ans <- tryCatch(eval(this_call), error = function (e) NULL)
  }
  
  invisible(NULL)
}


#' Combines the results of ion matches.
#' 
#' @param out_path A parent output path.
#' @param out_paths Sub output pathes.
#' @param type The type of data for combining.
combine_ion_matches <- function (out_path, out_paths, type = "ion_matches_") 
{
  out_path_temp  <- create_dir(file.path(out_path, "temp"))
  out_paths_temp <- lapply(out_paths, function(x) file.path(x, "temp"))
  
  pat  <- paste0(type, "[0-9]+\\.rds$")
  pat2 <- paste0(type, "([0-9]+)\\.rds$")
  xs   <- list.files(out_paths_temp[[1]], pattern = pat)
  
  files <- if (length(xs)) 
    paste0(type, sort(as.integer(gsub(pat2, "\\1", xs))), ".rds")
  else 
    NULL
  
  if (!length(files)) {
    warning("Files not found: ", type)
    return(NULL)
  }
  
  for (i in seq_along(files)) {
    ans <- lapply(out_paths_temp, function (x) qs::qread(file.path(x, files[i])))
    ans <- dplyr::bind_rows(ans)
    qs::qsave(ans, file.path(out_path_temp, files[i]), preset = "fast")
  }
  
  invisible(NULL)
}


#' Combines PSMs from sub folders.
#'
#' @param sub_paths A list of sub paths.
#' @param groups A character vector of sample groups. The group names will also
#'   be applied to the \code{pep_group} in PSM tables.
#' @param out_path An output path.
comine_PSMsubs <- function (sub_paths, groups, out_path) 
{
  lapply(c("psmC.txt", "psmQ.txt", "psmT2.txt", "psmT3.txt"), function (file) {
    df <- lapply(groups, function (group) {
      fi <- file.path(out_path, group, file)
      
      if (file.exists(fi)) {
        df <- readr::read_tsv(fi, show_col_types = FALSE)
        df$pep_group <- group
        nms <- names(df)
        
        df <- dplyr::bind_cols(
          df[, grepl("^prot_", nms)], 
          df[, grepl("^pep_", nms)], 
          df[, !grepl("^(prot|pep)_", nms)], 
        )
      }
      else {
        df <- NULL
      }
    }) 
    
    df <- dplyr::bind_rows(df)
    readr::write_tsv(df, file.path(out_path, file))
    
    invisible(NULL)
  })
  
  create_dir(file.path(out_path, "Calls"))
  file.copy(file.path(sub_paths[[1]], "Calls"), out_path, recursive = TRUE)
  combine_ion_matches(out_path, sub_paths, type = "ion_matches_")
  suppressWarnings(combine_ion_matches(out_path, sub_paths, type = "reporters_"))

  invisible(NULL)
}


#' Wrapper of \link{matchMS}.
#' 
#' With the calibration of precursor masses.
#' 
#' @param ... Arguments for \link{matchMS}.
matchMS_ms1calib <- function (...)
{
  matchMS(...)
  
  this_call <- match.call()
  fun <- as.character(this_call[1])
  this_fml <- formals()
  
  out_path <- this_call[["out_path"]]
  mgf_path <- this_call[["mgf_path"]]
  calib_ms1mass <- this_call[["calib_ms1mass"]]
  
  if (passed_ms1calib <- check_ms1calib(out_path, calib_ms1mass)) {
    file <- file.path(mgf_path, "ppm_ms1calib.rds")
    ppm_ms1_calib <- if (file.exists(file)) qs::qread(file) else stop()
    ppm_ms1_af <- ppm_ms1_calib[["ppm_ms1_af"]]
  }
  else 
    stop()
  
  matchMS(..., 
          ppm_ms1 = ppm_ms1_af, 
          bypass_mgf = TRUE, 
          calib_ms1mass = FALSE, 
  )
}


#' Parse the name of a Unimod
#'
#' The general format: \code{parse_unimod("title (position = site)")}.
#'
#' @param unimod The name of a \href{https://www.unimod.org/}{Unimod} modification.
#' @seealso \link{table_unimods}, \link{find_unimod}.
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' # "dot" for anywhere (either position or site)
#' x1 <- parse_unimod("Carbamidomethyl (. = C)")
#' x2 <- parse_unimod("Carbamidomethyl (Anywhere = C)")
#' x3 <- parse_unimod("Carbamidomethyl (C)")
#'
#' identical(x1, x2); identical(x2, x3)
#'
#' # Any residue on protein N-term
#' x1 <- parse_unimod("Acetyl (Protein N-term)")
#' x2 <- parse_unimod("Acetyl (Protein N-term = .)")
#' x3 <- parse_unimod("Acetyl (Protein N-term = N-term)")
#'
#' identical(x1, x2); identical(x2, x3)
#'
#' # Any N-term residue
#' x1 <- parse_unimod("Acetyl (N-term)")
#' x2 <- parse_unimod("Acetyl (N-term = .)")
#' x3 <- parse_unimod("Acetyl (N-term = N-term)")
#' x4 <- parse_unimod("Acetyl (Any N-term = N-term)")
#'
#' identical(x1, x2); identical(x2, x3); identical(x3, x4)
#'
#' # N-term Q
#' x1 <- parse_unimod("Gln->pryo-Glu (N-term = Q)")
#' x2 <- parse_unimod("Gln->pryo-Glu (N-term Q)")
#'
#' identical(x1, x2)
#'
#' # ok with parenthesis in the 'title'
#' x <- parse_unimod("Hex(5)HexNAc(2) (N)")
#'
#' # ok with spaces in the 'title'
#' x <- parse_unimod("Met-loss (Protein N-term = M)")
#' 
#' # N-term
#' parse_unimod("Carbamidomethyl (Any N-term = C)")
#' parse_unimod("Carbamidomethyl (Any N-term = N-term)")
#' parse_unimod("Carbamidomethyl (Protein N-term = N-term)")
#' }
#'
#' \dontrun{
#' # No modification of anywhere and anything
#' # (to every position and site)
#' x <- parse_unimod("Carbamidomethyl (Anywhere = .)")
#' x <- parse_unimod("Carbamidomethyl")
#' x <- parse_unimod("Carbamidomethyl (. = .)")
#'
#' # Prefer an "=" sign between 'N-term' and 'Q'
#' x <- parse_unimod("Gln->pyro-Glu (N-term Q)")
#' }
#' @export
parse_unimod <- function (unimod = "Carbamyl (M)") 
{
  # unimod = "Carbamidomethyl (Protein N-term = C)" # --> pos_site = "Protein N-term = C"
  # unimod = "Carbamidomethyl (Any N-term = C)" # --> pos_site = "Any N-term = C"
  # unimod = "Carbamidomethyl (N-term = C)" # --> pos_site = "N-term = C"
  # unimod = "Carbamidomethyl (. = C)" # --> pos_site = ". = C"
  # unimod = "Carbamidomethyl (C)" # --> pos_site = "C"
  # unimod = "Carbamidomethyl ()" # --> pos_site = ""
  # unimod = "Carbamidomethyl" # --> pos_site = ""
  # unimod = "" # --> pos_site = ""
  
  ## any N-term residue
  # unimod = "Carbamidomethyl (Protein N-term = .)"
  
  # unimod = "Hex(5)HexNAc(2) (N)"
  
  ## dual parentheses
  # unimod = "Carbamidomethyl ((. = C))" # --> pos_site = ". = C"
  
  if (grepl("Protein N-term\\s*=\\s*N-term", unimod)) 
    return(
      list(title = gsub("^([^ ]+?) .*", "\\1", unimod), 
           position = "Protein N-term", site = "N-term"))
  
  if (grepl("Protein C-term\\s*=\\s*C-term", unimod)) 
    return(
      list(title = gsub("^([^ ]+?) .*", "\\1", unimod), 
           position = "Protein C-term", site = "C-term"))
  
  if (grepl("([NC]{1}-term|Anywhere) [A-Z]{1}", unimod)) 
    unimod <- 
      gsub("^(.*[NC]{1}-term|.*Anywhere)\\s*([A-Z]{1})", "\\1 = \\2", unimod)
  
  # (assumed) no space in `title`
  title    <- gsub("^([^ ]+?) .*", "\\1", unimod)
  pos_site <- gsub("^[^ ]+", "", unimod)
  pos_site <- gsub("^[^\\(]+[\\(]*([^\\)]*)[\\)]*$", "\\1", pos_site)
  
  if (grepl("=", pos_site)) {
    pos  <- gsub("^([^=]+?)[=].*", "\\1", pos_site)
    pos  <- gsub("^[ ]*", "\\1", pos) # ?
    pos  <- gsub(" *$", "", pos)
    site <- gsub("^[^=]+?[=](.*)", "\\1", pos_site)
    site <- gsub("^[ ]*", "\\1", site) # ?
    site <- gsub(" *$", "", site)
  } 
  else {
    pos  <- "."
    site <- pos_site
  }
  
  if (site == "") 
    site = "."
  
  # site can be temporarily "Protein N-term"
  if (site %in% c("Protein N-term", "Protein C-term",
                  "Anywhere N-term", "Anywhere C-term",
                  "N-term", "C-term")) {
    pos  <- site
    site <- gsub("^(Protein|Anywhere) ", "", site)
  }
  
  # standardize the terminal `position`
  # (no need of handling Protein [NC]-term due to the early return)
  pos <- gsub("^([NC]){1}-term", "Any \\1-term", pos)
  
  if (pos %in% c(".", "")) 
    pos <- "Anywhere"
  
  pos_allowed <- c("Anywhere", "Protein N-term", "Protein C-term",
                   "Any N-term", "Any C-term")
  
  if (!pos %in% pos_allowed) 
    stop("`pos` needs to be one of ", 
         paste0("\n  '", pos_allowed, collapse = "'"), "'")

  # standardize terminal sites
  if (site == ".") {
    if (pos %in% c("Protein N-term", "Any N-term"))
      site <- "N-term"
    else if (pos %in% c("Protein C-term", "Any C-term"))
      site <- "C-term"
  }
  
  if (pos == "Anywhere" && site == ".") 
    stop("'position' or 'site' cannot be both 'Anywhere'.")
  
  list(title = title, position = pos, site = site)
}


#' Finds a Unimod.
#'
#' Finds the mono-isotopic mass, position, site and neutral losses of a
#' modification.
#'
#' In the field of \code{position_site}, \code{position} is the name and
#' \code{site} is the value.
#'
#' @param xml_files Name(s) of Unimod ".xml" files. The file path is a system
#'   setting of \code{system.file("extdata", xml_file, package = "mzion")}.
#' @inheritParams parse_unimod
#' @seealso \link{table_unimods}, \link{parse_unimod}.
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' x1 <- find_unimod("Carbamidomethyl (C)")
#' x2 <- find_unimod("Carbamidomethyl (M)")
#' x3 <- find_unimod("Acetyl (Protein N-term)")
#' x4 <- find_unimod("Gln->pyro-Glu (N-term = Q)")
#' x5 <- find_unimod("Hex(5)HexNAc(2) (N)")
#' }
#'
#' \dontrun{
#' # Prefer an "=" sign between 'N-term' and 'Q'
#' x <- find_unimod("Gln->pyro-Glu (N-term Q)")
#' }
#' @export
find_unimod <- function (unimod = "Carbamidomethyl (C)", 
                         xml_files = c("master.xml", "custom.xml")) 
{
  options(digits = 9L)
  
  res <- parse_unimod(unimod)
  title <- res$title
  position <- res$position
  site <- res$site
  rm(list = c("res"))
  
  this_mod <- hfind_unimod(xml_files = xml_files, unimod)
  
  # mass
  node_delta <- xml2::xml_find_all(this_mod, "umod:delta")
  monomass <- as.numeric(xml2::xml_attr(node_delta, "mono_mass"))
  
  if (length(monomass) != 1L)
    stop("The length of `mono_mass` is not one.")
  
  # sites and positions
  node_specs <- xml2::xml_find_all(this_mod, "umod:specificity")
  attrs_specs <- xml2::xml_attrs(node_specs)
  
  sites <- unlist(lapply(attrs_specs, `[`, "site"))
  positions <- unlist(lapply(attrs_specs, `[`, "position"))
  names(sites) <- positions
  
  idx_ps  <- which(sites == site & positions == position)
  sites   <- sites[idx_ps]
  empties <- unlist(lapply(sites, is.null))
  sites   <- sites[!empties]
  
  if ((len_sites <- length(sites)) > 1L)
    stop("Multiple matches in site and position for '", unimod, "'.")
  else if (len_sites == 0L)
    stop("No matches in site and position for '", unimod, "'.")

  # neutral loss
  idxes_nl <- grep("NeutralLoss", node_specs)
  idxes_nl <- idxes_nl[idxes_nl == idx_ps]
  
  if (length(idxes_nl)) {
    nodes_nl <- xml2::xml_children(node_specs[idxes_nl])
    # ensures the first is 0
    neulosses <- sort(as.numeric(xml2::xml_attr(nodes_nl, "mono_mass")))
  }
  else 
    neulosses <- 0
  
  list(title = title, 
       monomass = monomass,
       position_site = sites,
       nl = neulosses)
}


#' Helper of \link{find_unimod}.
#' 
#' @param xml_files A list of xml file names.
#' @inheritParams find_unimod
hfind_unimod <- function (xml_files = c("master.xml", "custom.xml"), unimod) 
{
  for (xml_file in xml_files) {
    title <- gsub("^([^ ]+?) .*", "\\1", unimod)
    
    xml_root <- xml2::read_xml(system.file("extdata", xml_file, package = "mzion"))
    nodes_lev1_four <- xml2::xml_children(xml_root)
    node_modif <- xml2::xml_find_all(nodes_lev1_four, "//umod:modifications")
    modifications <- xml2::xml_children(node_modif)
    
    if (length((idx <- which(xml2::xml_attr(modifications, "title") == title))))
      return(modifications[[idx]])
  }
  
  stop("Modification not found: '", title, "'.\n",
       "For example, use 'Acetyl' (title) instead of 'Acetylation' (full_name).")
}


#' Tabulates \href{https://www.unimod.org/}{Unimod} entries.
#'
#' For convenience summary of the \code{title}, \code{site} and \code{position}.
#'
#' @param out_nm A name to outputs. If NULL, outputs will not be saved.
#' @seealso \link{find_unimod}, \link{parse_unimod}, \link{add_unimod},
#'   \link{remove_unimod}, \link{remove_unimod_title},
#'   \link{calc_unimod_compmass}.
#' @examples
#' \donttest{
#' library(mzion)
#'
#' ans <- table_unimods()
#'
#' ## TMT-6, -10 and -11 plexes
#' # share the same Unimod entry at title "TMT6plex"
#' # (the same chemistry at tag mass 229.162932 Da)
#' ans[with(ans, title == "TMT6plex"), ]
#' this_mod1 <- parse_unimod("TMT6plex (Anywhere = K)")
#'
#' # Convenience title, "TMT10plex", alias to "TMT6plex"
#' this_mod2 <- parse_unimod("TMT10plex (Anywhere = K)")
#'
#' # Title "TMT11plex" alias to "TMT6plex"
#' this_mod3 <- parse_unimod("TMT11plex (Anywhere = K)")
#'
#' ## TMT-16
#' ans[with(ans, title == "TMTpro"), ]
#' this_mod1 <- parse_unimod("TMTpro (Anywhere = K)")
#'
#' # Both "TMTpro16" and "TMT16plex" alias to "TMTpro"
#' this_mod2 <- parse_unimod("TMTpro16 (Anywhere = K)")
#' this_mod3 <- parse_unimod("TMT16plex (Anywhere = K)")
#'
#' ## Summary of TMT entries and alias
#' ans[with(ans, grepl("^TMT", title)), ]
#'
#'
#' ## Special characters in the title (e.g., "->")
#' ans[with(ans, grepl("^Gln->pyro", title)), ]
#' this_mod <- parse_unimod("Gln->pryo-Glu (N-term = Q)")
#'
#' }
#' @export
table_unimods <- function (out_nm = "~/mzion/unimods.txt") 
{
  xml_files <- c("master.xml", "custom.xml")
  
  ans <- lapply(xml_files, htable_unimods)
  ans <- do.call(rbind, ans)
  rownames(ans) <- NULL
  
  if (is.character(out_nm)) {
    filepath <- gsub("\\\\", "/", out_nm)
    path <- create_dir(gsub("(.*)/.*", "\\1", filepath))
    file <- gsub(".*/(.*)", "\\1", filepath)
    readr::write_tsv(ans, file.path(path, file))
  }

  ans
}


#' Helper of \link{table_unimods}.
#' 
#' @param file A file path to a Unimod ".xml".
htable_unimods <- function (file) 
{
  xml_root <- xml2::read_xml(system.file("extdata", file, package = "mzion"))
  nodes_lev1_four <- xml2::xml_children(xml_root)
  node_modif <- xml2::xml_find_all(nodes_lev1_four, "//umod:modifications")
  modifications <- xml2::xml_children(node_modif)
  
  titles <- xml2::xml_attr(modifications, "title")
  full_name <- xml2::xml_attr(modifications, "full_name")

  nodes_specs <- lapply(modifications, function (this_mod) 
    xml2::xml_find_all(this_mod, "umod:specificity"))

  sites <- lapply(nodes_specs, xml2::xml_attr, "site")
  positions <- lapply(nodes_specs, xml2::xml_attr, "position")
  
  nodes_delta <- lapply(modifications, function (this_mod) 
    xml2::xml_find_all(this_mod, "umod:delta"))
  
  mono_mass <- lapply(nodes_delta, xml2::xml_attr, "mono_mass")
  composition <- lapply(nodes_delta, xml2::xml_attr, "composition")
  
  lens_specs <- lapply(nodes_specs, length)
  titles <- mapply(function (x, y) rep(x, y), titles, lens_specs)
  full_name <- mapply(function (x, y) rep(x, y), full_name, lens_specs)
  mono_mass <- mapply(function (x, y) rep(x, y), mono_mass, lens_specs)
  composition <- mapply(function (x, y) rep(x, y), composition, lens_specs)
  
  if (length(titles))
    data.frame(title = unname(unlist(titles)), 
               full_name = unname(unlist(full_name)), 
               site = unlist(sites), 
               position = unlist(positions), 
               mono_mass = unlist(mono_mass), 
               composition = unlist(composition))
  else
    NULL
}


#' Adds or modifies a Unimod entry.
#'
#' Changes are made to system files.
#'
#' @param header The header of a \href{https://www.unimod.org/}{Unimod}. The
#'   fields of \code{title} and \code{full_name} are required. No spaces are
#'   allowed in \code{title}.
#' @param specificity The specificity of \code{site} and \code{position} of a
#'   modification. The value of \code{site} is an upper-case, one-letter
#'   representation of an amino-acid residue, or "N-term" or "C-term". The value
#'   of \code{position} is one of "Anywhere", "Protein N-term", "Protein
#'   C-term", "Any N-term" or "Any C-term".
#'
#'   See also \link{remove_unimod} for a wildcard approach of \code{site = "."}
#'   and \code{position = "."} to remove all sites and positions under a title.
#' @param delta The mass and composition difference of a modification:
#'   \code{mono_mass}, the difference in mono-isotopic mass; \code{avge_mass},
#'   the difference in average mass; \code{composition}, the difference in
#'   chemical composition.
#'
#'   The precision of \code{mono_mass} is typically set with a decimal place of
#'   \eqn{\ge 5}.
#' @param neuloss The mass and composition \emph{loss} of a neutral species atop
#'   of the \code{delta}. Like many other search engines, \code{mzion} adapts
#'   the common convention where the losses of masses and compositions are
#'   expressed in \emph{positive} forms for both the masses and the
#'   compositions.
#'
#'   See also \link{remove_unimod} for a wildcard approach of \code{neuloss =
#'   c(mono_mass = ".", ...)} to remove all neutral losses under a site and a
#'   position for a given title.
#' @import xml2
#' @seealso \link{table_unimods}, \link{parse_unimod}, \link{find_unimod}.
#' @return An xml object.
#' @examples
#' \donttest{
#' library(mzion)
#'
#' ## To avoid unsound chemistries, mzion prohibits
#' ##   additive modifications to the same site.
#' ## To enable cumulative effects, the solution is to
#' ##   devise a "merged" modification (e.g. TMT + K8).
#'
#' (system.file("extdata", "master.xml", package = "mzion"))
#' (system.file("extdata", "custom.xml", package = "mzion"))
#'
#' ## Additive N-terminal modifications 
#' # (1) TMT + Gln->pyro-Glu (though not chemically sound)
#' masses <- calc_unimod_compmass("H(17) C(8) 13C(4) 15N O(2)")
#' mono_mass <- masses$mono_mass
#' avge_mass <- masses$avge_mass
#' 
#' x <- add_unimod(header      = c(title       = "TMT10plexNterm+Gln->pyro-Glu",
#'                                 full_name   = "Additive N-term TMT10plex and Gln->pyro-Glu"),
#'
#'                 # think about this: site = "Q", not "N-term"
#'                 specificity = c(site        = "Q",
#'                                 position    = "Any N-term"),
#'                 delta       = c(mono_mass   = "212.136383",
#'                                 avge_mass   = "212.2329",
#'                                 composition = "H(17) C(8) 13C(4) 15N O(2)"),
#'                 neuloss     = c(mono_mass   = "0",
#'                                 avge_mass   = "0",
#'                                 composition = "0"))
#'
#' (ans <- table_unimods())
#' (ans[with(ans, title == "TMT10plexNterm+Gln->pyro-Glu"), ])
#'
#' # (2.1) Oxiation + Carbamidomethyl at "C"
#' # (without neutral losses)
#' x <- add_unimod(header      = c(title       = "Oxi+Carbamidomethyl",
#'                                 full_name   = "Oxidation and iodoacetamide derivative"),
#'                 specificity = c(site        = "C",
#'                                 position    = "Anywhere"),
#'                 delta       = c(mono_mass   = "73.016379",
#'                                 avge_mass   = "73.0507",
#'                                 composition = "H(3) C(2) N O(2)"),
#'                 neuloss     = c(mono_mass   = "0",
#'                                 avge_mass   = "0",
#'                                 composition = "0"))
#'
#' # (2.2) Oxiation + Carbamidomethyl at "M"
#' # (with neutral losses)
#' x <- add_unimod(header      = c(title       = "Oxi+Carbamidomethyl",
#'                                 full_name   = "Oxidation and iodoacetamide derivative"),
#'                 specificity = c(site        = "M",
#'                                 position    = "Anywhere"),
#'                 delta       = c(mono_mass   = "73.016379",
#'                                 avge_mass   = "73.0507",
#'                                 composition = "H(3) C(2) N O(2)"),
#'                 neuloss     = c(mono_mass   = "63.998285",
#'                                 avge_mass   = "64.1069",
#'                                 composition = "H(4) C O S"))
#' 
#' # (3.1) Lysine + TMT
#' title <- "TMT+K8"
#' comp <- "H(20) C(2) 13C(10) N(-1) 15N(3) O(2)"
#' full_name <- "Heavy lysine 13C(6) 15N(2) with TMT6plex tag"
#' site <- "K"
#' 
#' K8TMT <- calc_unimod_compmass(comp)
#' mono_mass <- K8TMT$mono_mass
#' avge_mass <- K8TMT$avge_mass
#' 
#' x <- add_unimod(header      = c(title       = title,
#'                                 full_name   = full_name),
#'                 specificity = c(site        = site,
#'                                 position    = "Any C-term"),
#'                 delta       = c(mono_mass   = as.character(mono_mass),
#'                                 avge_mass   = as.character(avge_mass),
#'                                 composition = comp),
#'                 neuloss     = c(mono_mass   = "0",
#'                                 avge_mass   = "0",
#'                                 composition = "0"))
#' 
#' # (3.2) Arginine + TMT
#' title <- "TMT+R10"
#' comp <- "H(20) C(2) 13C(10) N(-3) 15N(5) O(2)"
#' full_name <- "Heavy arginine 13C(6) 15N(4) with TMT6plex tag"
#' site <- "R"
#' 
#' R10TMT <- calc_unimod_compmass(comp)
#' mono_mass <- R10TMT$mono_mass
#' avge_mass <- R10TMT$avge_mass
#' 
#' x <- add_unimod(header      = c(title       = title,
#'                                 full_name   = full_name),
#'                 specificity = c(site        = site,
#'                                 position    = "Any C-term"),
#'                 delta       = c(mono_mass   = as.character(mono_mass),
#'                                 avge_mass   = as.character(avge_mass),
#'                                 composition = comp),
#'                 neuloss     = c(mono_mass   = "0",
#'                                 avge_mass   = "0",
#'                                 composition = "0"))
#' 
#' ## Heavy isotopes
#' # (1.1) Lysine
#' title <- "K8"
#' comp <- "13C(6) C(-6) 15N(2) N(-2)"
#' full_name <- "Heavy lysine 13C(6) 15N(2)"
#' site <- "K"
#' 
#' K8 <- calc_unimod_compmass(comp)
#' mono_mass <- K8$mono_mass
#' avge_mass <- K8$avge_mass
#' 
#' a <- add_unimod(header      = c(title       = title,
#'                                 full_name   = full_name),
#'                 specificity = c(site        = site,
#'                                 position    = "Anywhere"),
#'                 delta       = c(mono_mass   = as.character(mono_mass),
#'                                 avge_mass   = as.character(avge_mass),
#'                                 composition = comp),
#'                 neuloss     = c(mono_mass   = "0",
#'                                 avge_mass   = "0",
#'                                 composition = "0"))
#' 
#' # (typical form used in searches)
#' b <- add_unimod(header      = c(title       = title,
#'                                 full_name   = full_name),
#'                 specificity = c(site        = site, 
#'                                 position    = "Any C-term"),
#'                 delta       = c(mono_mass   = as.character(mono_mass),
#'                                 avge_mass   = as.character(avge_mass),
#'                                 composition = comp),
#'                 neuloss     = c(mono_mass   = "0",
#'                                 avge_mass   = "0",
#'                                 composition = "0"))
#' 
#' # (site = "C-term" is perhaps not what typically wanted)
#' x <- add_unimod(header      = c(title       = title,
#'                                 full_name   = full_name),
#'                 specificity = c(site        = "C-term", 
#'                                 position    = "Any C-term"),
#'                 delta       = c(mono_mass   = as.character(mono_mass),
#'                                 avge_mass   = as.character(avge_mass),
#'                                 composition = comp),
#'                 neuloss     = c(mono_mass   = "0",
#'                                 avge_mass   = "0",
#'                                 composition = "0"))
#' 
#' # (1.2) Arginine
#' title <- "R10"
#' comp <- "13C(6) C(-6) 15N(4) N(-4)"
#' full_name <- "Heavy arginine 13C(6) 15N(4)"
#' site <- "R"
#' 
#' R10 <- calc_unimod_compmass(comp)
#' mono_mass <- R10$mono_mass
#' avge_mass <- R10$avge_mass
#' 
#' a <- add_unimod(header      = c(title       = title,
#'                                 full_name   = full_name),
#'                 specificity = c(site        = site,
#'                                 position    = "Anywhere"),
#'                 delta       = c(mono_mass   = as.character(mono_mass),
#'                                 avge_mass   = as.character(avge_mass),
#'                                 composition = comp),
#'                 neuloss     = c(mono_mass   = "0",
#'                                 avge_mass   = "0",
#'                                 composition = "0"))
#' 
#' # (typical form used in searches)
#' b <- add_unimod(header      = c(title       = title,
#'                                 full_name   = full_name),
#'                 specificity = c(site        = site, 
#'                                 position    = "Any C-term"),
#'                 delta       = c(mono_mass   = as.character(mono_mass),
#'                                 avge_mass   = as.character(avge_mass),
#'                                 composition = comp),
#'                 neuloss     = c(mono_mass   = "0",
#'                                 avge_mass   = "0",
#'                                 composition = "0"))
#' 
#' ## Channels of TMT reporter ions
#' electron <- 0.000549
#' 
#' tmt11_126 <- calc_unimod_compmass("C(8) N(1) H(16)")
#' tmt11_126 <- lapply(tmt11_126, `-`, electron)
#' 
#' tmt11_131n <- calc_unimod_compmass("13C(4) C(4) 15N(1) H(16)")
#' tmt11_131n <- lapply(tmt11_131n, `-`, electron)
#' 
#' tmt11_131c <- calc_unimod_compmass("13C(5) C(3) N(1) H(16)")
#' tmt11_131c <- lapply(tmt11_131c, `-`, electron)
#' }
#' 
#' @export
add_unimod <- function (header = c(title = "Foo", full_name = "Foo bar"), 
                        specificity = c(site  = "C", position = "Anywhere"), 
                        delta = c(mono_mass = "42.010565", 
                                  avge_mass = "42.0367", 
                                  composition = "H(2) C(2) O"), 
                        neuloss = c(mono_mass = "0", 
                                    avge_mass = "0", 
                                    composition = "0")) 
{
  options(digits = 9L)
  
  title <- header[["title"]]
  full_name <- header[["full_name"]]
  position <- specificity[["position"]]
  site <- specificity[["site"]]
  mod_mono_mass <- delta[["mono_mass"]]
  mod_avge_mass <- delta[["avge_mass"]]
  mod_composition <- delta[["composition"]]
  neuloss_mono_mass <- neuloss[["mono_mass"]]
  neuloss_avge_mass <- neuloss[["avge_mass"]]
  neuloss_composition <- neuloss[["composition"]]
  
  xml_file <- system.file("extdata", "master.xml", package = "mzion")
  xml_root <- xml2::read_xml(xml_file)
  nodes_lev1_four <- xml2::xml_children(xml_root)
  node_modif <- xml2::xml_find_all(nodes_lev1_four, "//umod:modifications")
  
  modifications <- xml2::xml_children(node_modif)
  idx_title <- which(xml2::xml_attr(modifications, "title") == title)
  len_title <- length(idx_title)
  
  # not in master
  if (len_title) {
    is_master <- TRUE
  }
  else {
    xml_file <- system.file("extdata", "custom.xml", package = "mzion")
    xml_root <- xml2::read_xml(xml_file)
    nodes_lev1_four <- xml2::xml_children(xml_root)
    node_modif <- xml2::xml_find_all(nodes_lev1_four, "//umod:modifications")
    
    modifications <- xml2::xml_children(node_modif)
    idx_title <- which(xml2::xml_attr(modifications, "title") == title)
    len_title <- length(idx_title)
    
    is_master <- FALSE
  }
  
  # adds entries to custom.xml for the first time
  if (!length(node_modif)) {
    xml2::xml_add_child(xml_root, "umod:modifications")
    node_modif <- xml2::xml_find_all(xml_root, "//umod:modifications")
  }

  if (length(site) != 1L) {
    warning("The length of `site` is not one.")
    return(NULL)
  }

  if (!(length(position) == 1L)) {
    warning("The length of `position` is not one.")
    return(NULL)
  }

  ok_sites <- c("A", "C", "D", "E", "F", "G", "H", "I", "K", "L", "M", "N", 
                "P", "Q", "R", "S", "T", "U", "V", "W", "Y", 
                "N-term", "C-term")
  
  ok_positions <- c("Anywhere", "Protein N-term", "Protein C-term", 
                    "Any N-term", "Any C-term")
  
  if (!site %in% c(LETTERS, "N-term", "C-term")) {
    warning("`site` is not one of ", paste(ok_sites, collapse = ", "), ".")
    return(NULL)
  }

  if (!position %in% ok_positions) {
    warning("`position` is not one of ", paste(ok_positions, collapse = ", "), ".")
    return(NULL)
  }

  if (is.numeric(mod_mono_mass)) 
    mod_mono_mass <- as.character(mod_mono_mass)
  
  if (is.numeric(mod_avge_mass)) 
    mod_avge_mass <- as.character(mod_avge_mass)
  
  if (is.numeric(neuloss_mono_mass)) 
    neuloss_mono_mass <- as.character(neuloss_mono_mass)
  
  if (is.numeric(neuloss_avge_mass)) 
    neuloss_avge_mass <- as.character(neuloss_avge_mass)

  if (!len_title) {
    # `title` not found -> new modifiation
    rec_ids <- as.integer(xml2::xml_attr(modifications, "record_id"))
    
    if (!length(rec_ids))
      rec_ids <- 0L
    
    record_id <- as.character(max(rec_ids) + 1L)
    
    add_modification(node_modif, title = title, full_name = full_name, 
                     site  = site, position = position, 
                     mod_mono_mass = mod_mono_mass, mod_avge_mass = mod_avge_mass, 
                     mod_composition = mod_composition, 
                     neuloss_mono_mass = neuloss_mono_mass, 
                     neuloss_avge_mass = neuloss_avge_mass, 
                     neuloss_composition = neuloss_composition, 
                     record_id = record_id)
  }
  else if (len_title == 1L) {
    # `title` found -> checks `site` and `position`
    this_mod <- modifications[[idx_title]]
    nodes_children <- xml2::xml_children(this_mod)
    attrs_children <- xml2::xml_attrs(nodes_children)
    
    if ((this_full_name <- xml2::xml_attr(this_mod, "full_name")) != full_name)
      warning("The original `full_name = ", this_full_name, "` \n", 
              "replaced by `full_name = ", full_name, "`.")

    if (length((this_delta <- xml2::xml_find_all(this_mod, "umod:delta"))) != 1L) {
      warning("Multiple or no matches.")
      return(NULL)
    }
      
    if ((this_mono_mass <- xml2::xml_attr(this_delta, "mono_mass")) != mod_mono_mass) {
      if (abs(as.numeric(this_mono_mass) - as.numeric(mod_mono_mass)) <= 1E-5)
        mod_mono_mass <- this_mono_mass
      else {
        waring("\nThe user provided `mono_mass = ", mod_mono_mass, "` ", 
               "is different to the current `mono_mass = ", this_mono_mass, "`.\n", 
               "If you believe the new entry is correct: \n", 
               "  try `remove_unimod(title = ", title, "`, ", 
               "then repeat the current call.\n")
        return(NULL)
      }
    }
    
    if ((this_avge_mass <- xml2::xml_attr(this_delta, "avge_mass")) != mod_avge_mass) {
      if (abs(as.numeric(this_avge_mass) - as.numeric(mod_avge_mass)) <= 1E-3)
        mod_avge_mass <- this_avge_mass
      else {
        warning("\nThe user provided `avge_mass = ", mod_avge_mass, "` ", 
                "is different to the current `avge_mass = ", this_avge_mass, "`.\n", 
                "If you believe the new entry is correct: \n", 
                "  try `remove_unimod(title = ", title, "`, ", 
                "then repeat the current call.\n")
        return(NULL)
      }
    }
    
    if ((this_composition <- xml2::xml_attr(this_delta, "composition")) != mod_composition) {
      if (is_master) {
        warning("Changed from the user provided `composition = ", mod_composition, "` ", 
                "to the current `composition = ", this_composition, "`.\n")
        mod_composition <- this_composition
      }
      else {
        warning("\nThe user provided `composition = ", mod_composition, "` ", 
                "is different to the current `composition = ", this_composition, "`.\n", 
                "If you believe the new entry is correct: \n", 
                "  try `remove_unimod(title = ", title, "`, ", 
                "then repeat the current call.\n")
        return(NULL)
      }
    }
    
    sites <- unlist(lapply(attrs_children, `[`, c("site")))
    positions <- unlist(lapply(attrs_children, `[`, c("position")))
    ok_sitepos <- which((sites == site) & (positions == position))
    
    if ((len_sitepos <- length(ok_sitepos)) > 1L) {
      warning("Multiple matches to `site = ", site, "` and ", 
              "`position = ", position, "` at ", 
              "`title = ", title, "`.\n", 
              "Fix the redundancy from ", xml_file, ".")
      return(NULL)
    }
    else if (len_sitepos) 
      # `site` and `position` found -> adds/checks neulosses
      add_neuloss(nodes_children[[ok_sitepos]], 
                  neuloss_mono_mass = neuloss_mono_mass, 
                  neuloss_avge_mass = neuloss_avge_mass, 
                  neuloss_composition = neuloss_composition)
    else 
      # new `site` and `position` with optional neuloss
      add_specificy(this_mod, site = site, position = position, 
                    neuloss_mono_mass = neuloss_mono_mass, 
                    neuloss_avge_mass = neuloss_avge_mass, 
                    neuloss_composition = neuloss_composition)
  }
  else if (len_title > 1L) {
    warning("Multiple matches to `", title, "`.\n", 
            "Fix the redundancy from ", xml_file, ".")
    return(NULL)
  }

  xml2::write_xml(xml_root, xml_file)
  
  invisible(xml_root)
}


#' Adds a new node of modification.
#'
#' @param node A node of top-level \code{modification} (one of the top-4).
#' @param title The title of a modification.
#' @param full_name The full-name description of a modification.
#' @param position The position of a modification.
#' @param site The site of a modification.
#' @param mod_mono_mass The mono-isotopic mass delta of a modification.
#' @param mod_avge_mass The average mass delta of a modification.
#' @param mod_composition The chemical composition of a modification.
#' @param neuloss_mono_mass The mono-isotopic mass delta of neutral loss in a
#'   positive value.
#' @param neuloss_avge_mass The average mass delta of neutral loss in a positive
#'   value.
#' @param neuloss_composition The chemical composition of a neutral loss.
#' @param record_id The index of a modification.
add_modification <- function (node = NULL, title = "Acetyl", full_name = "", 
                              site  = "N-term", position = "Protein N-term", 
                              mod_mono_mass = "42.010565", mod_avge_mass = "42.0367", 
                              mod_composition = "H(2) C(2) O", 
                              neuloss_mono_mass = "0", neuloss_avge_mass = "0", 
                              neuloss_composition = "0", record_id = "0") 
{
  # (0) node: <umod:modifications>
  #   (1) <umod:mod title=... >
  #     (2.1) specificity
  #       (2.1.1) neuloss
  #         (2.1.1.1) element
  #     (2.2) delta
  #       (2.2.1) element

  ## (1) adds a "umod:mod" node
  xml2::xml_add_child(node, "umod:mod")
  modifications <- xml2::xml_find_all(node, "umod:mod")
  this_mod <- modifications[[length(modifications)]]

  xml2::xml_set_attrs(
    this_mod, 
    c(title = title, 
      full_name = full_name, 
      username_of_poster = "unimod", 
      group_of_poster = "user", 
      date_time_posted = as.character(Sys.time()), 
      date_time_modified = as.character(Sys.time()), 
      approved = "0", 
      record_id = record_id))
  
  # (2.1) specificity
  add_specificy(node = this_mod, site = site, position = position, 
                neuloss_mono_mass = neuloss_mono_mass, 
                neuloss_avge_mass = neuloss_avge_mass, 
                neuloss_composition = neuloss_composition) 

  # (2.2) delta
  add_delta(node = this_mod, mod_mono_mass = mod_mono_mass, 
            mod_avge_mass = mod_avge_mass, 
            mod_composition = mod_composition)
  
  invisible(node)
}


#' Adds a node of \code{specificity}.
#' 
#' @param node A node of \code{umod:mod}.
#' @inheritParams add_modification
add_specificy <- function (node = NULL, site = "C", position = "Anywhere", 
                           neuloss_mono_mass = "0", neuloss_avge_mass = "0", 
                           neuloss_composition = "0") 
{
  # (1) node: <umod:mod title=... >
  #   (2.1) specificity
  #     (2.1.1) neuloss
  #       (2.1.1.1) element
  #   (2.2) delta
  #     (2.2.1) element
  
  # (2.1) specificity
  xml2::xml_add_child(node, "umod:specificity")
  
  # DON't: "node_specs <- xml2::xml_children(node)"
  #   because of siblings other than `specificity`
  # 
  # [10] <umod:specificity hidden="1" site="U" position="Anywhere"
  # [11] <umod:specificity hidden="1" site="M" position="Anywhere" 
  # [12] <umod:delta mono_mass=
  # [13] <umod:alt_name>
  # [14] <umod:xref>\n 
  
  node_specs <- xml2::xml_find_all(node, "umod:specificity")

  len <- length(node_specs)
  this_spec <- node_specs[[len]]
  
  xml2::xml_set_attrs(
    this_spec, 
    c(hidden = "0", 
      site  = site, 
      position = position, 
      classification = "other", 
      spec_group = as.character(len)))
  
  # (2.1.1) neuloss
  add_neuloss(node = this_spec, neuloss_mono_mass = neuloss_mono_mass, 
              neuloss_avge_mass = neuloss_avge_mass, 
              neuloss_composition = neuloss_composition)
}


#' Adds a node of \code{delta}.
#' 
#' @param node A node of \code{umod:mod}.
#' @inheritParams add_modification
add_delta <- function (node = NULL, mod_mono_mass = "0", mod_avge_mass = "0", 
                       mod_composition = "0") 
{
  # (1) node: <umod:mod title=... >
  #   (2.1) specificity
  #     (2.1.1) neuloss
  #       (2.1.1.1) element
  #   (2.2) delta
  #     (2.2.1) element
  
  # (2.2) delta
  xml2::xml_add_child(node, "umod:delta")
  node_delta <- xml2::xml_find_all(node, "umod:delta")
  
  len <- length(node_delta)
  this_delta <- node_delta[[len]]
  
  xml2::xml_set_attrs(
    this_delta, 
    c(mono_mass = mod_mono_mass, 
      avge_mass  = mod_avge_mass, 
      composition = mod_composition))
  
  # (2.2.1) adds element children
  add_comp_elements(node_delta, mod_composition)
  
  invisible(node)
}


#' Adds a node of \code{NeutralLoss}.
#' 
#' Including the \code{0} NeutralLoss.
#' 
#' @param node A node of \code{umod:specificity}.
#' @inheritParams add_modification
add_neuloss <- function (node = NULL, neuloss_mono_mass = "0", 
                         neuloss_avge_mass = "0", neuloss_composition = "0") 
{
  #   (2.1) node: specificity
  #     (2.1.1) neuloss
  #       (2.1.1.1) element
  #   (2.2) delta
  #     (2.2.1) element
  
  if (neuloss_mono_mass != "0") {
    nodes_neuloss <- xml2::xml_find_all(node, "umod:NeutralLoss")
    attrs_neuloss <- xml2::xml_attrs(nodes_neuloss)
    masses <- unlist(lapply(attrs_neuloss, `[`, c("mono_mass")))
    
    if (any(masses == neuloss_mono_mass))
      warning("Pre-existed `NeutralLoss`; do nothing.")
    else {
      if (!any(masses == "0")) {
        this_neuloss <- hadd_neuloss(node = node, 
                                     neuloss_mono_mass = "0", 
                                     neuloss_avge_mass  = "0", 
                                     neuloss_composition = "0")
      }

      this_neuloss <- hadd_neuloss(node = node, 
                                   neuloss_mono_mass = neuloss_mono_mass, 
                                   neuloss_avge_mass  = neuloss_avge_mass, 
                                   neuloss_composition = neuloss_composition)
      
      # (2.1.1.1) neuloss elements
      add_comp_elements(this_neuloss, neuloss_composition)
    }
  }
  else
    message("No neutral loss.")
}


#' Helper of \link{add_neuloss}.
#' 
#' @inheritParams add_neuloss
hadd_neuloss <- function (node = NULL, neuloss_mono_mass = "0", 
                          neuloss_avge_mass = "0", neuloss_composition = "0") 
{
  xml2::xml_add_child(node, "umod:NeutralLoss")
  nodes_neuloss <- xml2::xml_find_all(node, "umod:NeutralLoss")
  this_neuloss <- nodes_neuloss[[length(nodes_neuloss)]]
  
  xml2::xml_set_attrs(
    this_neuloss,
    c(mono_mass = neuloss_mono_mass, 
      avge_mass  = neuloss_avge_mass, 
      flag = "false", 
      composition = neuloss_composition))
  
  invisible(this_neuloss)
}


#' Adds a series of nodes of \code{umod:element}.
#' 
#' @param node A node of either \code{NeutralLoss} or \code{delta}.
#' @param composition The chemical composition of a modification.
add_comp_elements <- function (node = NULL, composition = "0") 
{
  df <- parse_unimod_composition(composition)

  old_elems <- xml2::xml_find_all(node, "umod:element")
  xml2::xml_remove(old_elems)
  rm(list = c("old_elems"))
  
  seqs <- seq_len(nrow(df))
  
  for (i in seqs)
    xml2::xml_add_child(node, "umod:element")
  
  mod_elems <- xml2::xml_find_all(node, "umod:element")
  
  for (i in seqs) 
    xml2::xml_set_attrs(mod_elems[[i]], c(symbol = df[i, 1], number = df[i, 2]))

  invisible(node)
}


#' Removes an existing modification.
#'
#' @inheritParams add_unimod
#' @seealso remove_unimod_title
#' @examples 
#' \dontrun{
#' library(mzion)
#' 
#' # site `C`: Oxiation + Carbamidomethyl
#' # (without neutral losses)
#' x <- remove_unimod(header      = c(title       = "Oxi+Carbamidomethyl",
#'                                    full_name   = "Oxidation and iodoacetamide derivative"),
#'                    specificity = c(site        = "C",
#'                                    position    = "Anywhere"),
#'                    delta       = c(mono_mass   = "73.016379",
#'                                    avge_mass   = "73.0507",
#'                                    composition = "H(3) C(2) N O(2)"),
#'                    neuloss     = c(mono_mass   = "0",
#'                                    avge_mass   = "0",
#'                                    composition = "0"))
#' 
#' # site `M`: Oxiation + Carbamidomethyl
#' # (with neutral losses)
#' x <- remove_unimod(header      = c(title       = "Oxi+Carbamidomethyl",
#'                                    full_name   = "Oxidation and iodoacetamide derivative"),
#'                    specificity = c(site        = "M",
#'                                    position    = "Anywhere"),
#'                    delta       = c(mono_mass   = "73.016379",
#'                                    avge_mass   = "73.0507",
#'                                    composition = "H(3) C(2) N O(2)"),
#'                    neuloss     = c(mono_mass   = "63.998285",
#'                                    avge_mass   = "64.1069",
#'                                    composition = "H(4) C O S"))
#' 
#' x <- remove_unimod(header      = c(title       = "Oxi+Carbamidomethyl",
#'                                    full_name   = "Oxidation and iodoacetamide derivative"),
#'                    specificity = c(site        = "M",
#'                                    position    = "Anywhere"),
#'                    delta       = c(mono_mass   = "73.016379",
#'                                    avge_mass   = "73.0507",
#'                                    composition = "H(3) C(2) N O(2)"),
#'                    neuloss     = c(mono_mass   = ".",
#'                                    avge_mass   = ".",
#'                                    composition = "."))
#' 
#' x <- remove_unimod_title("TMT10plexNterm+Gln->pyro-Glu")
#' x <- remove_unimod_title("Oxi+Carbamidomethyl")
#' }
#' @export
remove_unimod <- function (header = c(title = "Foo", full_name = "Foo bar"), 
                           specificity = c(site  = "C", position = "Anywhere"), 
                           delta = c(mono_mass = "42.010565", 
                                     avge_mass = "42.0367", 
                                     composition = "H(2) C(2) O"), 
                           neuloss = c(mono_mass = "0", 
                                       avge_mass = "0", 
                                       composition = "0")) 
{
  options(digits = 9L)

  if (!"title" %in% names(header)) {
    warning("`title` not found in `header`.")
    return(NULL)
  }
  
  if (!"full_name" %in% names(header)) {
    warning("`full_name` not found in `header`.")
    header[["full_name"]] <- ""
  }

  if (!"site" %in% names(specificity)) {
    warning("`site` not found in `specificity`.")
    return(NULL)
  }

  if (!"position" %in% names(specificity)) {
    warning("`position` not found in `specificity`.")
    return(NULL)
  }

  if (is.null(title <- header[["title"]])) {
    warning("`title` cannot be NULL.")
    return(NULL)
  }
  else if (title == "") {
    warning("`title` can be not empty.")
    return(NULL)
  }
  else if (is.na(title)) {
    warning("`title` cannot be NA.")
    return(NULL)
  }
  
  full_name <- header[["full_name"]]
  site <- specificity[["site"]]
  position <- specificity[["position"]]
  mod_mono_mass <- delta[["mono_mass"]]
  mod_avge_mass <- delta[["avge_mass"]]
  mod_composition <- delta[["composition"]]
  neuloss_mono_mass <- neuloss[["mono_mass"]]
  neuloss_avge_mass <- neuloss[["avge_mass"]]
  neuloss_composition <- neuloss[["composition"]]
  
  xml_file <- system.file("extdata", "custom.xml", package = "mzion")
  xml_root <- xml2::read_xml(xml_file)
  nodes_lev1_four <- xml2::xml_children(xml_root)
  node_modif <- xml2::xml_find_all(nodes_lev1_four, "//umod:modifications")
  
  if (!length(node_modif)) {
    warning("Node `umod:modifications` not found and nothing to be removed.")
    return(NULL)
  }

  if (is.null(site <- standardize_unimod_ps(x = c(site = site)))) {
    warning("`site` not found.")
    return(NULL)
  }
  
  if (is.null(position <- standardize_unimod_ps(x = c(position = position)))) {
    warning("`position` not found.")
    return(NULL)
  }

  if (site == "." && position == ".")
    return(remove_unimod_title(title = title))
  
  if (site == "." || position == ".") {
    warning("Specify both `site` and `position`.")
    return(NULL)
  }

  if (is.numeric(mod_mono_mass)) 
    mod_mono_mass <- as.character(mod_mono_mass)
  
  if (is.numeric(mod_avge_mass)) 
    mod_avge_mass <- as.character(mod_avge_mass)
  
  if (is.numeric(neuloss_mono_mass)) 
    neuloss_mono_mass <- as.character(neuloss_mono_mass)
  
  if (is.numeric(neuloss_avge_mass)) 
    neuloss_avge_mass <- as.character(neuloss_avge_mass)
  
  # individual nodes of modifications
  modifications <- xml2::xml_children(node_modif)
  
  # title
  idx_title <- which(xml2::xml_attr(modifications, "title") == title)
  
  if ((len_title <- length(idx_title)) > 1L) {
    warning("Multiple matches to `", title, "`.\n", 
            "Fix the redundancy from ", xml_file, ".")
    return(NULL)
  }
  else if (!len_title) {
    warning("Entry `", title, "` not found.")
    return(NULL)
  }

  # `site` and `position`
  this_mod <- modifications[[idx_title]]
  
  if ((this_full_name <- xml2::xml_attr(this_mod, "full_name")) != full_name)
    warning("Ignored the difference between the original `full_name = ", 
            this_full_name, "` \nand the current ", 
            "`full_name = ", full_name, "`.")
  
  # (children can be `specification`, `delta` etc.)
  nodes_mod_ch <- xml2::xml_children(this_mod)
  attrs_mod_ch <- xml2::xml_attrs(nodes_mod_ch)
  
  sites <- unlist(lapply(attrs_mod_ch, `[`, c("site")))
  positions <- unlist(lapply(attrs_mod_ch, `[`, c("position")))
  ok_sitepos <- which((sites == site) & (positions == position))
  
  if (!(len_sitepos <- length(ok_sitepos))) {
    warning("No matches to `site = ", site, "` and ", 
            "`position = ", position, "` at ", 
            "`title = ", title, "`.\n")
    return(NULL)
  }
  else if (len_sitepos > 1L) {
    waring("Multiple matches to `site = ", site, "` and ", 
           "`position = ", position, "` at ", 
           "`title = ", title, "`.\n", 
           "Fix the redundancy from ", xml_file, ".")
    return(NULL)
  }

  this_spec <- nodes_mod_ch[ok_sitepos]
  
  if (neuloss_mono_mass == "0") {
    xml2::xml_remove(this_spec)
    nodes_mod_ch <- xml2::xml_children(this_mod)
    xml2::write_xml(xml_root, xml_file)
    
    message("Entry `site = ", site, "` and `position = ", position, 
            "` removed from `title = ", title, "`.")
  }
  else if (neuloss_mono_mass == ".") {
    nodes_neuloss <- xml2::xml_find_all(this_spec, "umod:NeutralLoss")
    xml2::xml_remove(nodes_neuloss[seq_along(nodes_neuloss)])
    nodes_neuloss <- xml2::xml_children(this_spec)
    
    if (length(nodes_neuloss)) {
      warning("No NeutralLoss nodes expected; contact the developer for issues.")
      return(NULL)
    }

    xml2::write_xml(xml_root, xml_file)
    
    message("All NeutralLoss under ", 
            "`site = ", site, "` and `position = ", position, 
            "` removed from `title = ", title, "`.")
  }
  else {
    nodes_neuloss <- xml2::xml_find_all(this_spec, "umod:NeutralLoss")
    attrs_neuloss <- xml2::xml_attrs(nodes_neuloss)
    
    neuloss_mono_masses <- unlist(lapply(attrs_neuloss, `[`, c("mono_mass")))
    idx_neuloss <- which((neuloss_mono_masses == neuloss_mono_mass))
    
    if ((len_neuloss <- length(idx_neuloss)) > 1L) {
      warning("Multiple matches to the `mono_mass` in `neuloss`.")
      return(NULL)
    }
    else if (!len_neuloss) {
      warning("No matches to the `mono_mass` in `neuloss`.")
      return(NULL)
    }

    this_neuloss <- nodes_neuloss[idx_neuloss]
    xml2::xml_remove(this_neuloss)
    nodes_neuloss <- xml2::xml_children(this_spec)
    
    # only the "0" NeutralLoss
    if (length(nodes_neuloss) == 1L) {
      this_neuloss_0 <- nodes_neuloss[1]
      xml2::xml_remove(this_neuloss_0)
      nodes_neuloss <- xml2::xml_children(this_spec)
      
      if (length(nodes_neuloss)) {
        warning("No NeutralLoss nodes expected; contact the developer for bugs.")
        return(NULL)
      }
    }
    
    xml2::write_xml(xml_root, xml_file)
    
    message("NeutralLoss at `mono_mass = ", neuloss_mono_mass, "`, ", 
            "`site = ", site, "` and `position = ", position, 
            "` removed from `title = ", title, "`.")
  }
  
  # Remove the node if no more sites under the title
  nodes_mod_ch <- xml2::xml_children(this_mod)
  attrs_mod_ch <- xml2::xml_attrs(nodes_mod_ch)
  
  if (all(is.na(unlist(lapply(attrs_mod_ch, `[`, c("site")))))) {
    remove_unimod_title(title)
  }
  
  invisible(xml_root)
}


#' Standardizes the site and position of a modification.
#' 
#' @param x A name string. Note that \code{x} is either a site or a position.
standardize_unimod_ps <- function (x) 
{
  nm <- names(x)
  x <- unname(x)
  
  if (isFALSE(x)) 
    x <- "."
  
  if (length(x) != 1L) 
    stop("The length of `", nm, "` is not exactly one.", call. = FALSE)
  
  if (nchar(x) == 0L) 
    x <- "."
  
  if (nm == "site") {
    ok_sites <- c("A", "C", "D", "E", "F", "G", "H", "I", "K", "L", "M", "N", 
                  "P", "Q", "R", "S", "T", "U", "V", "W", "Y", 
                  "N-term", "C-term", ".")
    
    # site may later include "X", "Z" etc.
    if (!x %in% c(LETTERS, "N-term", "C-term", ".")) {
      warning("Invalid site = ", x)
      return(NULL)
    }
  }
  
  if (nm == "position") {
    ok_positions <- c("Anywhere", "Protein N-term", "Protein C-term", 
                      "Any N-term", "Any C-term", ".")
    
    if (!x %in% ok_positions) {
      warning("Invalid position = ", x)
      return(NULL)
    }
  }
  
  invisible(x)
}


#' Removes an existing modification.
#'
#' @param title The title of a modification.
#' @examples 
#' \dontrun{
#' library(mzion)
#' x <- remove_unimod_title("Oxi+Carbamidomethyl")
#' }
#' @export
remove_unimod_title <- function (title = NULL) 
{
  if (isFALSE(title) || nchar(title) == 0L) {
    warning("Provide a `title`.")
    return(NULL)
  }

  xml_file <- system.file("extdata", "custom.xml", package = "mzion")
  xml_root <- xml2::read_xml(xml_file)
  
  nodes_lev1_four <- xml2::xml_children(xml_root)
  node_modif <- xml2::xml_find_all(nodes_lev1_four, "//umod:modifications")
  modifications <- xml2::xml_children(node_modif)
  
  idx <- which(xml2::xml_attr(modifications, "title") == title)
  
  if ((len <- length(idx)) > 1L) {
    warning("Multiple matches to `", title, "`.\n", 
            "Fix the redundancy from ", xml_file, ".")
    return(NULL)
  }
  else if (!len) {
    warning("Entry `", title, "` not found.")
    return(NULL)
  }

  xml2::xml_remove(modifications[idx])
  modifications <- xml2::xml_children(node_modif)
  xml2::write_xml(xml_root, xml_file)
  message("Entry `", title, "` removed from ", xml_file, ".")
  
  invisible(xml_root)
}


#' Calculates the masses of a chemical formula.
#'
#' @param composition A chemical composition.
#' @param digits A non-negative integer; the number of decimal places to be
#'   used.
#' @export
#' @examples 
#' \donttest{
#' comp <- "N(1) 15N(-1)"
#' m <- mzion::calc_unimod_compmass(comp)
#' }
calc_unimod_compmass <- function (composition = "H(4) C O S", digits = 6L) 
{
  options(digits = 9L)
  
  allowed <- c(" ", "+", "-", "(", ")", LETTERS, letters, as.character(0:9))
  
  if (composition == "") {
    warning("`composition` cannot be empty.")
    return(NULL)
  }
  
  if (!all(strsplit(composition, "")[[1]] %in% allowed)) {
    warning("`composition` contains special characters.")
    return(NULL)
  }
  
  nm <- system.file("extdata", "elem_masses.txt", package = "mzion")
  
  if (file.exists(nm))
    lookup <- read.delim(file = nm, sep = "\t")
  else
    stop("Not found: ", nm)

  df <- parse_unimod_composition(composition)
  df$number <- as.numeric(df$number)
  df <- dplyr::left_join(df, lookup, by = "symbol")

  if (any(rows <- is.na(df$mono_mass))) {
    stop("Unknown element(s): ", paste(df$symbol[rows], collapse = ", "))
  }

  nums <- df$number
  avges <- df$avge_mass
  monos <- df$mono_mass
  
  avge_mass <- round(sum(avges * nums), digits)
  mono_mass <- round(sum(monos * nums), digits)
  
  list(mono_mass = mono_mass, avge_mass = avge_mass)
}


#' Parses A Unimod position.
#' 
#' @param composition A chemical composition.
parse_unimod_composition <- function (composition = "H(4) C O S") 
{
  options(digits = 9L)
  
  composition <- gsub("\\+", "", composition)
  
  df <- composition |> 
    stringr::str_replace_all("([:alnum:]+)$", paste0("\\1", "(1)")) |> 
    stringr::str_replace_all("([:alnum:]+) ", paste0("\\1", "(1) "))
  df <- gsub("\\s+", "", df)
  df <- stringr::str_match_all(df, "(.*?)\\((-*[0-9]+)\\)")
  df <- df[[1]]
  
  df <- df[, -1, drop = FALSE]
  colnames(df) <- c("symbol", "number")
  
  data.frame(df)
}
#' Finds the indexes of top-n entries without re-ordering.
#'
#' At length(x) >= n, the length of output may be shorter than n with ties.
#'
#' @param x A numeric vector.
#' @param n The number of top entries to keep.
#' @param ... Additional arguments for base function sort.
#' @return The indexes of the top-n entries.
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' mzion:::which_topx(c(1:5), 50)
#'
#' length(mzion:::which_topx(sample(5000, 500), 100))
#'
#' length(mzion:::which_topx(sample(100, 100, replace = TRUE), 100))
#' }
which_topx <- function(x, n = 50L, ...) 
{
  len <- length(x)
  p <- len - n
  
  if (p  <= 0L) 
    return(seq_along(x))
  
  xp <- sort(x, partial = p, ...)[p]
  
  .Internal(which(x > xp))
}


#' Finds the indexes of top-n entries without re-ordering.
#' 
#' Handles ties.
#' 
#' @param replace_na Logical; currently always TRUE; replaces NA or not.
#' @param vna The value of NA replacement.
#' @param exclude_na Logical; removes NA or not.
#' @inheritParams which_topx
#' @return The indexes of the top-n entries.
#' @examples 
#' library(mzion)
#' 
#' p <- 100
#' set.seed(1)
#' x <- sample(1:150, replace = TRUE)
#' 
#' # 103, not 100
#' xp <- sort(x, partial = p)[p]
#' 
#' # multiple ties
#' x <- c(1, 2, 2, 3, 3, 3, 4, 4, 4, 4)
#' p <- 2L
#' 
#' x <- c(1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5)
#' set.seed <- (3)
#' x <- sample(x)
#' p <- 4L
#' 
#' ## more NA values (3) than n (2)
#' x <- c(0.11, 0.11, NA, rep(0.11, 7), NA, NA)
#' ans <- mzion:::which_topx2(x, 2L, na.last = FALSE)
#' 
#' # OK
#' ans <- mzion:::which_topx2(x, 8L, na.last = FALSE)
#' 
#' # results can contain NA
#' x <- c(10, rep_len(NA_integer_, 3), 12, rep_len(NA_integer_, 3), 8, 10, 10)
#' ans <- mzion:::which_topx2(x, n = 7L)
#' x[ans]
#' 
#' # Bad
#' ans <- mzion:::which_topx2(x, 9L, na.last = FALSE)
#' # OK
#' ans <- mzion:::which_topx2(x, 9L, na.last = TRUE)
#'  
#' \donttest{
#' mzion:::which_topx2(5000, NA_integer_)
#' }
which_topx2 <- function(x, n = 50L, replace_na = TRUE, vna = 0, 
                        exclude_na = TRUE, ...) 
{
  if (is.na(n)) 
    return(NULL)
  
  len <- length(x)
  p <- len - n

  if (p  <= 0L) {
    if (exclude_na)
      return(.Internal(which(!is.na(x))))
    else
      return(seq_along(x))
  }

  if (replace_na)
    x[is.na(x)] <- vna
  
  # not yet work at replace_na = FALSE and x contains fewer non-NA than p
  xp <- sort(x, partial = p, ...)[p]
  inds <- .Internal(which(x > xp)) # NA drops by which()

  # in case of ties -> length(inds) < n
  # detrimental e.g. ms2_n = 500 and n = 100
  #   -> expect 100 `ms2_moverzs` guaranteed but may be only 99
  #
  # MGF `ms2_moverzs` is increasing
  # `inds2` goes first to ensure non-decreasing index for `ms2_moverzs`
  d <- n - length(inds)
  
  if (!d)
    return(inds)

  # must exist and length(ties) >= length(d) at replace_na = TRUE
  ties <- .Internal(which(x == xp))
  # better check the length(ties) >= length(d)
  for (i in seq_len(d)) {
    inds <- insVal(ties[[i]], inds)
  }
  
  inds
}


#' Gets top-n values
#' 
#' @param vals a vector of values
#' @param n The top-n values to be retained
get_topn_vals <- function (vals, n) vals[which_topx2(vals, n)]


#' Inserts a value.
#' 
#' @param x A value to be inserted.
#' @param sv A sorted vector of indexes(thus without ties).
#' 
#' @examples
#' library(mzion)
#' sv <- c(4, 10)
#' 
#' sv <- mzion:::insVal(2, sv)
#' sv <- mzion:::insVal(6, sv)
#' sv <- mzion:::insVal(20, sv)
insVal <- function (x, sv) 
{
  grs <- sv > x
  c(sv[!grs], x, sv[grs])
}


#' Finds the top-n entries without re-ordering.
#'
#' @inheritParams which_topx
#' @return The top-n entries.
topx <- function(x, n = 50L, ...) 
{
  len <- length(x)
  p <- len - n
  
  if (p  <= 0L) 
    return(x)
  
  xp <- sort(x, partial = p, ...)[p]
  
  x[x > xp]
}


#' Finds the numeric difference in ppm.
#'
#' @param x A numeric value.
#' @param y A numeric value.
#' @return The difference between \eqn{x} and \eqn{y} in ppm.
find_ppm_error <- function (x = 1000, y = 1000.01) (y - x)/y * 1E6


#' Finds the error range of a number.
#'
#' Assumes \eqn{x} is positive without checking.
#'
#' @param x A numeric value.
#' @param ppm Numeric; the ppm allowed from \code{x}.
#' @return The lower and the upper bound to \eqn{x} by \eqn{ppm}.
find_mass_error_range <- function (x = 500L, ppm = 20L) 
{
  d <- x * ppm/1E6
  c(x - d, x + d)
}


#' Sums elements across lists.
#'
#' Each list has the same length. NA values are removed.
#'
#' @param x A numeric value.
#' @param y A numeric value.
`%+%` <- function(x, y) mapply(sum, x, y, MoreArgs = list(na.rm = TRUE))


#' Sums elements across lists.
#'
#' Each list has the same length. NA values are removed.
#'
#' @param x A numeric value.
#' @param y A numeric value.
`%+%` <- function(x, y) mapply(sum, x, y, MoreArgs = list(na.rm = TRUE))


#' Post frame advancing.
#'
#' Flattens mgfs within each frame.
#' 
#' @param res Results from frame-advanced searches.
#' @param mgf_frames Data of MGF frames.
post_frame_adv <- function (res, mgf_frames) 
{
  res  <- unlist(res, recursive = FALSE, use.names = FALSE)
  out <- do.call(rbind, mgf_frames)
  # stopifnot(nrow(out) == length(res))
  out <- dplyr::mutate(out, matches = res)
  out <- out[lengths(res, use.names = FALSE) > 0L, ]
}


#' Subsets the frames of theoretical peptides.
#' 
#' @param mgf_frames MGFs in frames. Each frame contains one to multiple MGFs
#'   whose MS1 masses are in the same interval.
#' @param theopeps Binned theoretical peptides at a given combination of fixed
#'   and variable.
subset_theoframes <- function (mgf_frames = NULL, theopeps = NULL) 
{
  if ((!length(mgf_frames)) || (!length(theopeps)))
    return(NULL)
  
  frames <- as.integer(names(mgf_frames))
  breaks <- which(diff(frames) != 1L) + 1L
  groups <- findInterval(frames, frames[breaks])
  frames <- split(frames, groups)
  
  frames <- lapply(frames, function (x) c(x[1] - 1, x, x[length(x)] + 1))
  frames <- unlist(frames, recursive = FALSE, use.names = FALSE)
  frames <- frames[!duplicated(frames)]

  # NA names and NULL contents if br_frames not in theopeps
  # (length determined by `br_frames`)
  theopeps[as.character(frames)]
}


#' Subsets theoretical peptides.
#'
#' Only entries containing the site of neuloss will be kept.
#'
#' @param pattern A regex of amino-acid residue(s).
#' @param theopeps Lists of theoretical peptides. A column of \code{pep_seq} is
#'   assumed.
subset_neuloss_peps <- function (pattern, theopeps) 
{
  rows <- lapply(theopeps, function (x) grepl(pattern, x$pep_seq))
  
  mapply(function (x, y) x[y, ], theopeps, rows, 
         SIMPLIFY = FALSE, USE.NAMES = FALSE)
}


#' Finds MS2 N-terminal mass.
#'
#' When \code{length(ntmod) > 0}, \code{aa_mass["N-term"]} must be H given the
#' rule of no additive (terminal) modifications.
#'
#' @param aa_masses A named list containing the (mono-isotopic) masses of amino
#'   acid residues.
find_nterm_mass <- function (aa_masses) 
{
  ntmod <- attr(aa_masses, "ntmod", exact = TRUE)
  
  # (1) For the "if" part at "length(ntmod) > 0": 
  #   aa_mass["N-term"] must be hydrogen, provided the 
  #   rule of no additive (terminal) modifications. Thus, 
  #   aa_masses[names(ntmod)] + aa_masses["N-term"] - e is identical to
  #   aa_masses[names(ntmod)] + 1.00727647
  # 
  # (2) For the "else" part: 
  #   e.g. at fixed `TMT6plex (N-term)`
  #   aa_masses["N-term"] = 229 + H -> 230
  
  # hydrogen <- 1.007825
  # proton <- 1.00727647
  # electr <- 0.000549
  
  if (length(ntmod))
    aa_masses[names(ntmod)] + 1.00727647
  else
    aa_masses["N-term"] - 0.000549
}


#' Finds MS2 C-terminal mass.
#'
#' @param aa_masses A named list containing the (mono-isotopic) masses of amino
#'   acid residues.
find_cterm_mass <- function (aa_masses) 
{
  ctmod <- attr(aa_masses, "ctmod", exact = TRUE)
  
  # (1) For the "if" part at "length(ctmod) > 0": 
  #   aa_mass["C-term"] must be OH, provided the 
  #   rule of no additive (terminal) modifications. Thus, 
  #   aa_masses[names(ctmod)] + aa_masses["C-term"] + (H) + (H+) is identical to
  #   aa_masses[names(ctmod)] + 19

  if (length(ctmod))
    aa_masses[names(ctmod)] + 19.0178415
  else 
    aa_masses["C-term"] + 2.01510147 # + (H) + (H+)
}


#' Right-joining of two data frames.
#'
#' Not a general purpose utility. For simple circumstances that the number of
#' rows in the output is equal to that in \code{y}, and can be use as an
#' alternative to \link[dplyr]{right_join}.
#' 
#' Rows ordered by \code{y}, which is different to \link[dplyr]{right_join}. 
#'
#' @param x The left data frame (to be proliferated by rows).
#' @param y The right data frame (the dominated one).
#' @param by The key.
#' @examples
#' \donttest{
#' library(mzion)
#' library(dplyr)
#' 
#' df1 <- data.frame(A = c("a", "b", "c"), B = c(1, 1, 1))
#' df2 <- data.frame(A = c("a", "c", "d"), C = c(2, 2, "3"))
#'
#' x1 <- mzion:::quick_rightjoin(df1, df2, by = "A")
#' x1 <- x1[, c("A", "B", "C")]
#' rownames(x1) <- seq_len(nrow(x1))
#'
#' x2 <- dplyr::right_join(df1, df2, by = "A")
#' x2 <- x2[, c("A", "B", "C")]
#'
#' stopifnot(identical(x1, x2))
#'
#' # row order may be different
#' x1 <- mzion:::quick_rightjoin(df2, df1, by = "A")
#' x1 <- x1[, c("A", "B", "C")]
#' rownames(x1) <- seq_len(nrow(x1))
#'
#' x2 <- dplyr::right_join(df2, df1, by = "A")
#' x2 <- x2[, c("A", "B", "C")]
#'
#' # FALSE
#' !identical(x1, x2)
#' }
quick_rightjoin <- function (x, y, by = NULL) 
{
  # the indexes of y in x;
  # NA rows in "x", if "y" not found in "x"

  rows <- match(y[[by]], x[[by]])
  x <- x[rows, ]
  x[[by]] <- NULL

  ## faster, but not for data.table
  # x <- x[, -which(names(x) == by), drop = FALSE]

  cbind2(x, y)
}


#' Left-joining of two data frames.
#'
#' Not a general purpose utility. For simple circumstances that the number of
#' rows in the output is equal to that in \code{x}, and can be use as an
#' alternative to \link[dplyr]{left_join}.
#'
#' @param x The left data frame.
#' @param y The right data frame.
#' @param by The key.
#' @examples
#' \donttest{
#' library(mzion)
#' library(dplyr)
#'
#' df1 <- data.frame(A = c("a", "b", "c"), B = c(1, 1, 1))
#' df2 <- data.frame(A = c("a", "c", "d"), C = c(2, 2, "3"))
#'
#' x1 <- mzion:::quick_leftjoin(df1, df2, by = "A")
#' x1 <- x1[, c("A", "B", "C")]
#' rownames(x1) <- seq_len(nrow(x1))
#'
#' x2 <- dplyr::left_join(df1, df2, by = "A")
#'
#' stopifnot(identical(x1, x2))
#' }
quick_leftjoin <- function (x, y, by = NULL) 
{
  rows <- match(x[[by]], y[[by]])
  y <- y[rows, ]
  y[[by]] <- NULL

  ## faster, but not for data.table
  # y <- y[, -which(names(y) == by), drop = FALSE]

  cbind2(x, y)
}


#' Detects and suggests the number of CPU cores.
#'
#' @param max_n_cores The maximum number of cores for uses.
detect_cores <- function (max_n_cores = NULL) 
{
  n_cores <- parallel::detectCores()

  max_n_cores <- if (is.null(max_n_cores)) 
    n_cores
  else 
    min(max_n_cores, n_cores)

  max_n_cores <- if (n_cores > 128L) 
    min(max_n_cores, n_cores - 8L)
  else if (n_cores <= 128L && n_cores > 64L) 
    min(max_n_cores, n_cores - 4L)
  else if (n_cores <= 64L && n_cores > 32L) 
    min(max_n_cores, n_cores - 2L)
  else if (n_cores <= 32L && n_cores > 16L) 
    min(max_n_cores, n_cores - 1L)
  else 
    min(max_n_cores, n_cores)
}


#' Finds the amount of free system memory.
#' 
#' Outputs of free RAM in the unit of MB.
#' 
#' @param sys_ram The putative amount of system RAM, e.g., 32L.
find_free_mem <- function (sys_ram = NULL) 
{
  nm_os <- Sys.info()['sysname']

  if (nm_os == "Windows") {
    free_mem <- system('wmic OS get FreePhysicalMemory /Value', intern=TRUE)[3]
    free_mem <- gsub("^FreePhysicalMemory=(\\d+)\\r", "\\1", free_mem)
    free_mem <- as.numeric(free_mem)/1024
    
    if (!is.null(sys_ram)) 
      free_mem <- min(sys_ram, free_mem)
  } 
  else {
    # not yet tested for "Linux", "Darwin"
    # inaccurate e.g. if physical RAM is 32000 but in .RProfile 
    # `invisible(utils::memory.limit(64000))`
    # memory.limit() - memory.size(max = TRUE)
    
    warning("Cannot determine the amount of RAM with Linux or MAC OS.\n", 
            "To specify, use parameter \"sys_ram\".")
    free_mem <- 24L
  }
  
  free_mem
}


#' Find the indexes of modifications.
#' 
#' @param file A full-path name of file where modifications are recorded.
find_mod_indexes <- function (file) 
{
  if (!file.exists(file)) 
    stop("File not found: ", file)
  
  mod_indexes <- readr::read_tsv(file, show_col_types = FALSE)
  inds <- mod_indexes$Abbr
  names(inds) <- mod_indexes$Desc
  
  inds
}


#' Finds if two sets are equal.
#' 
#' @param x A set.
#' @param y Another set.
is_equal_sets <- function(x, y) all(x %in% y) && all(y %in% x)


#' Expands grids.
#'
#' Outputs are vectors corresponding to rows in the the data.frame from the
#' original expand.grid.
#'
#' Some overhead in making row vectors but can avoid the expensive row
#' subsetting from a data.frame.
#' 
#' @param nmax The maximum number of combinations allowed.
#' @param use.names Logical; uses names or not.
#' @param ... Lists of data.
#' @examples
#' library(mzion)
#' 
#' x <- list(`Oxidation (M)` = c(0.000000, 63.998285),
#'           `Carbamidomethyl (M)` = c(0.000000, 105.024835),
#'           `Oxidation (M)` = c(0.000000, 63.998285))
#'
#' mzion:::expand_grid_rows(x)
#'
#' x <- list(`Bar (M)` = c(0, 3),
#'           `Foo (M)` = c(0, 5, 7),
#'           `Bar (M)` = c(0, 3))
#'
#' mzion:::expand_grid_rows(x)
#'
#' x <- list(`Bar (M)` = c(0, 3))
#' mzion:::expand_grid_rows(x)
expand_grid_rows <- function (..., nmax = 3L, use.names = TRUE) 
{
  args <- list(...)[[1]]
  nargs <- length(args)
  tot <- nargs * nmax
  cargs <- vector("integer", )
  
  rep.fac <- 1L
  ds <- lengths(args)
  orep <- prod(ds)
  nmax <- min(nmax, orep)
  
  sta <- 1L
  end <- nmax
  
  for (i in seq_len(nargs)) {
    x <- args[[i]]
    
    nx <- length(x)
    orep <- orep/nx
    x <- x[rep_len(rep.int(seq_len(nx), rep.int(rep.fac, nx)), nmax)]
    
    cargs[sta:end] <- x
    sta <- sta + nmax
    end <- end + nmax
    rep.fac <- rep.fac * nx
  }
  
  # vectors by rows
  len <- length(x)
  ans <- vector("list", len)
  nms <- names(args)
  
  seqs <- 0:(nargs-1L)
  
  for (i in 1:len) {
    y <- cargs[seqs * nmax + i]
    names(y) <- nms
    ans[[i]] <- y
  }
  
  ans
}


#' Modified from expand.grid
#' 
#' Net yet used.
#' 
#' @param nmax The maximum number of combinations allowed.
#' @param ... Lists of data.
expand_grid <- function (..., nmax = 3L) 
{
  nargs <- length(args <- list(...))
  
  if (!nargs) 
    return(as.data.frame(list()))
  
  if (nargs == 1L && is.list(a1 <- args[[1L]])) 
    nargs <- length(args <- a1)
  if (nargs == 0L) 
    return(as.data.frame(list()))
  
  cargs <- vector("list", nargs)
  iArgs <- seq_len(nargs)
  nmc <- paste0("Var", iArgs)
  nm <- names(args)
  nm <- nmc
  names(cargs) <- nmc
  
  rep.fac <- 1L
  d <- lengths(args)
  orep <- prod(d)
  nmax <- min(nmax, orep)
  
  if (orep == 0L) {
    for (i in iArgs) cargs[[i]] <- args[[i]][FALSE]
  }
  else {
    for (i in iArgs) {
      x <- args[[i]]
      nx <- length(x)
      orep <- orep/nx
      
      x <- x[rep_len(rep.int(seq_len(nx), rep.int(rep.fac, nx)), nmax)]
      cargs[[i]] <- x
      rep.fac <- rep.fac * nx
    }
  }
  
  rn <- .set_row_names(length(x))
  structure(cargs, class = "data.frame", row.names = rn)
}


#' Modified from expand.grid
#' 
#' Inputs are in matrices
#' 
#' @param nmax The maximum number of combinations allowed.
#' @param ... Lists of data.
expand_gr <- function (..., nmax = 3L) 
{
  nargs <- length(args <- list(...))
  
  if (nargs == 1L && is.list(a1 <- args[[1L]])) 
    nargs <- length(args <- a1)
  
  nr <- .Internal(unlist(lapply(args, nrow), recursive = FALSE, use.names = FALSE))
  nc <- .Internal(unlist(lapply(args, ncol), recursive = FALSE, use.names = FALSE))
  cnc <- cumsum(nc)
  orep <- prod(nr)
  nmax <- min(nmax, orep)
  
  M <- matrix(nrow = nmax, ncol = sum(nc))
  rep.fac <- 1L
  c1 <- 1L
  
  for (i in seq_len(nargs)) {
    x <- args[[i]]
    nx <- nr[[i]]
    orep <- orep/nx
    c2 <- cnc[[i]]
    M[, c1:c2] <- x[rep_len(rep.int(seq_len(nx), rep.int(rep.fac, nx)), nmax), ]
    c1 <- c2 + 1L
    rep.fac <- rep.fac * nx
  }
  
  M
}


#' Expands grids.
#'
#' Outputs are vectors corresponding to rows in the the data.frame from the
#' original expand.grid.
#'
#' Some overhead in making row vectors but can avoid the expensive row
#' subsetting from a data.frame.
#'
#' @param use.names Logical; uses names or not.
#' @param ... Lists of data.
#' @examples
#' library(mzion)
#' 
#' x <- list(`Oxidation (M)` = c(0.000000, 63.998285),
#'           `Carbamidomethyl (M)` = c(0.000000, 105.024835),
#'           `Oxidation (M)` = c(0.000000, 63.998285))
#'
#' mzion:::expand_grid_rows0(x)
#'
#' x <- list(`Bar (M)` = c(0, 3),
#'           `Foo (M)` = c(0, 5, 7),
#'           `Bar (M)` = c(0, 3))
#'
#' mzion:::expand_grid_rows0(x)
#'
#' x <- list(`Bar (M)` = c(0, 3))
#' mzion:::expand_grid_rows0(x)
expand_grid_rows0 <- function (..., use.names = TRUE) 
{
  args <- list(...)[[1]]
  nargs <- length(args)
  
  # if (!nargs) return(NULL)
  
  cargs <- vector("list", nargs)
  names(cargs) <- names(args)
  
  rep.fac <- 1L
  ds <- lengths(args)
  orep <- prod(ds)
  
  for (i in seq_len(nargs)) {
    x <- args[[i]]
    
    nx <- length(x)
    orep <- orep/nx
    x <- x[rep.int(rep.int(seq_len(nx), rep.int(rep.fac, nx)), orep)]
    
    cargs[[i]] <- x
    rep.fac <- rep.fac * nx
  }
  
  # vectors by rows
  ans <- vector("list", rep.fac)
  
  for (i in seq_len(rep.fac)) {
    x <- lapply(cargs, `[[`, i)
    x <- .Internal(unlist(x, recursive = FALSE, use.names = use.names))
    ans[[i]] <- x
  }
  
  ans
}



#' A simplified table utility.
#' 
#' A faster alternative to \code{table}.
#' 
#' @param vec A named vector.
#' @examples 
#' \dontrun{
#' library(mzion)
#' library(microbenchmark)
#' 
#' vec <- c("Carbamidomethyl (M)", "Carbamyl (M)", "Carbamidomethyl (M)")
#' microbenchmark(mzion:::count_elements(vec), table(vec))
#' }
count_elements <- function (vec) 
{
  vals <- unique(vec)
  len <- length(vals)
  
  out <- vector("integer", len)
  
  for (i in seq_len(len)) 
    out[i] <- sum(vec == vals[i])
  
  names(out) <- vals
  
  out
}


#' Split a named character vector to lists.
#' 
#' @param x A named character vector.
#' @examples 
#' \dontrun{
#' library(mzion)
#' library(microbenchmark)
#' 
#' x <- c(`Deamidated (N)` = "N", `Carbamidomethyl (S)` = "S")
#' identical(mzion:::vec_to_list(x), split(x, x))
#' microbenchmark(mzion:::vec_to_list(x), split(x, x))
#' }
vec_to_list <- function (x) 
{
  len <- length(x)
  out <- vector("list", len)
  names(out) <- x
  
  for(i in seq_len(len)) 
    out[[i]] <- x[i]
  
  out
}


#' Splits a matrix
#' 
#' @param M A matrix.
#' @param by Split by matrix rows or columns.
split_matrix <- function (M, by = "row") 
{
  if (by == "row")
    len <- nrow(M)
  
  ans <- vector("list", len)
  
  for (i in seq_along(ans))
    ans[[i]] <- M[i, ]
  
  ans
}


#' Split a vector by values
#' 
#' @param vec A vector.
#' @param use_names Logical; uses names or not.
#' 
#' @examples
#' \dontrun{
#' ## M
#' library(mzion)
#' library(microbenchmark)
#' 
#' vec <- c(`Carbamidomethyl (M)` = "M", 
#'          `Carbamyl (M)` = "M")
#' 
#' x <- mzion:::split_vec(vec)
#' y <- split(vec, vec)
#' 
#' stopifnot(identical(x, y))
#' 
#' microbenchmark(mzion:::split_vec(vec), split(vec, vec))
#' 
#' ## N
#' vec <- c(`Deamidated (N)` = "N")
#' 
#' x <- mzion:::split_vec(vec)
#' y <- split(vec, vec)
#' 
#' stopifnot(identical(x, y))
#' 
#' microbenchmark(mzion:::split_vec(vec), split(vec, vec))
#' 
#' ## M, N
#' vec <- c(`Carbamidomethyl (M)` = "M", 
#'          `Carbamyl (M)` = "M", 
#'          `Deamidated (N)` = "N")
#' 
#' x <- mzion:::split_vec(vec)
#' y <- split(vec, vec)
#' 
#' stopifnot(identical(x, y))
#' 
#' microbenchmark(mzion:::split_vec(vec), split(vec, vec))
#' }
#' 
split_vec <- function (vec, use_names = TRUE) 
{
  vals <- unique(vec)
  len <- length(vals)
  
  out <- vector("list", len)
  
  for (i in seq_len(len)) 
    out[[i]] <- vec[vec == vals[i]]
  
  if (use_names)
    names(out) <- vals
  
  out
}


#' Folds a vector evenly
#'
#' Only for the special case that \code{length(vec)} is exactly n-times of the
#' \code{fold}.
#' 
#' @param vec A vector
#' @param fold The number of folds
#' @seealso \link{fold_vec2} for a more generalized solution.
fold_vec <- function (vec, fold = 5L) 
{
  # !!! only applicable when length(vec) is n-times of fold !!!

  ans <- vector("list", fold)
  # `r` must be integer
  r <- length(vec)/fold

  sta <- 1L
  end <- r
  
  for (i in 1:fold) {
    ans[[i]] <- vec[sta:end]
    sta <- sta + r
    end <- end + r
  }

  ans
}


#' Folds a vector evenly
#'
#' A more general form of \link{fold_vec} handling fractional
#' \code{length(vec)/fold}.
#'
#' @param vec A vector
#' @param fold The number of folds
#' @param remove_allna_subvec Logical; if TRUE, removes all NA sub vectors. This
#'   can occur with the rounding of lengths. E.g., at \code{length(vec) == 15}
#'   and \code{fold = 6}, the 6-th subvec will be all NA.
#' @examples
#' vec <- sort(rep(LETTERS[1:5], 1:5))
#' mzion:::fold_vec2(vec, 6L)
#' @seealso \link{find_group_breaks}
fold_vec2 <- function (vec, fold = 5L, remove_allna_subvec = TRUE) 
{
  len <- length(vec)
  r <- ceiling(len/fold)
  
  if (remove_allna_subvec) {
    dif <- r * fold -len
    
    if (dif > 0) {
      mod <- len %/% r
      fold <- if (dif %% r == 0L) mod else mod + 1L
    }
  }

  # faster than mapply
  ans <- vector("list", fold)
  sta <- 1L
  end <- r
  
  for (i in 1:fold) {
    ans[[i]] <- vec[sta:end]
    sta <- sta + r
    end <- end + r
  }

  alast <- ans[[fold]]
  ans[[fold]] <- alast[!is.na(alast)]
  
  ans
}


#' Separates a vector into chunks.
#' 
#' @param vec A vector.
#' @param fold The number of folds.
#' @examples
#' vec <- sort(rep(LETTERS[1:5], 1:5))
#' mzion:::sep_vec(vec, 6L)
#' @return A vector of fold indexes.
sep_vec <- function (vec, fold = 5L)
{
  len <- length(vec)
  seqs <- seq_along(vec)
  mod <- len / fold
  (seqs - 1L) %/% mod + 1L
}


#' Replicates a vector
#' 
#' Slower than rep
#' 
#' @param vec A vector
#' @param fold The number of folds
rep_vec <- function (vec, fold) 
{
  l <- length(vec)
  r <- l * fold
  ans <- vector("character", r)

  sta <- 1L
  end <- l
  
  for (i in 1:fold) {
    ans[sta:end] <- vec
    sta <- sta + l
    end <- end + l
  }
  
  ans
}


#' Accumulates character strings.
#' 
#' @param x A vector of character strings.
#' @param f A function.
#' 
#' @examples 
#' \donttest{
#' library(mzion)
#' 
#' x <- c("aa", "bb", "cc")
#' mzion:::accumulate_char(x, paste0)
#' 
#' x <- c(a = 1, b = 2, c = 3)
#' mzion:::accumulate_char(x, paste0)
#' 
#' x <- "-EDEIQDXI-"
#' mzion:::accumulate_char(x, paste0)
#' }
#' 
#' @export
accumulate_char <- function(x, f) 
{
  len <- length(x)
  
  if (len == 1L) 
    return(x)
  
  out <- vector("character", len)
  
  out[1] <- x[1]
  
  for (i in seq(2, len)) 
    out[i] <- f(out[i-1], x[i])
  
  out
}


#' Populates the count matrix for combinations.
#' 
#' @param nb The number of balls.
#' @param ns The number of samplings (the number of columns). 
combi_mat <- function (nb = 5L, ns = 3L) 
{
  # stopifnot(ns >= 1L)
  
  m <- matrix(nrow = nb, ncol = ns)
  m[, 1] <- rep(1L, nb)
  
  if (ns == 1L) 
    return(m)
  
  for (i in seq(2, ns)) 
    m[, i] <- cumsum(m[, i-1])
  
  m
}


#' Makes a data frame of zero rows.
#' 
#' @param vec A vector of names.
make_zero_df <- function (vec) 
{
  df <- data.frame(matrix(ncol = length(vec), nrow = 0L))
  colnames(df) <- vec
  
  invisible(df)
}


#' Calculates the three-frame ppm.
#'
#' @param ppm A positive integer; the mass tolerance of MS1 species. The default
#'   is 20.
#' @param is_three_frame Logical; is a three-frame search or not. The value is
#'   always TRUE.
#' @param fct_ppm A factor to new ppm error. The value is always 0.5 for a
#'   three-frame search.
calc_threeframe_ppm <- function (ppm = 20L, is_three_frame = TRUE, fct_ppm = .5) 
{
  if (is_three_frame) as.integer(ceiling(ppm * fct_ppm)) else ppm
}


#' Gets the MS1 charges.
#' 
#' @param charges A vector of \code{2+, 3+} etc.
get_ms1charges <- function (charges)
{
  charges <- lapply(charges, stringi::stri_reverse)
  charges <- .Internal(unlist(charges, recursive = FALSE, use.names = FALSE))
  
  as.integer(charges)
}


#' Finds unique elements including the same name in a vector.
#' 
#' The same value at different name will be treated as different elements.
#' 
#' @param x A named vector.
#' @examples
#' \donttest{
#' library(mzion)
#' mzion:::finds_uniq_vec(c(a1 = 3, a2 = 3, a2 = 4, a2 = 3, b1 = 3, b2 = 1))
#' }
finds_uniq_vec <- function (x)
{
  v <- .Internal(paste0(list(x, names(x)), collapse = NULL, recycle0 = FALSE))
  oks <- !duplicated.default(v)
  x[oks]
}


#' Makes a data frame from lists.
#' 
#' Not yet used.
#' 
#' @param l A list of named vectors.
my_dataframe <- function (l)
{
  class(l) <- "data.frame"
  attr(l, "row.names") <- .set_row_names(length(l[[1]]))
  l
}


#' Alternative to \link[purrr]{flatten}
#' 
#' @param data A list of data.
#' @param use_names Logical; to use names or not.
flatten_list <- function (data, use_names = TRUE)
{
  len <- length(data)
  
  if (!len)
    return(data)
  
  lens <- .Internal(unlist(lapply(data, length), recursive = FALSE, 
                           use.names = FALSE))
  oks  <- which(lens > 0L)
  
  if (!length(oks))
    return(vector("list"))

  data <- data[oks]
  lens <- lens[oks]
  len  <- length(data)
  
  if (len == 1L)
    return(data[[1]])
  
  ends <- cumsum(lens)
  stas <- c(1, ends + 1L)

  ans <- vector("list", ends[len])
  
  for (i in 1:len) 
    ans[stas[[i]]:ends[[i]]] <- data[[i]]
  
  if (use_names) 
    names(ans) <- .Internal(unlist(lapply(data, names), recursive = FALSE, 
                                   use.names = FALSE))

  ans
}


#' Calculates the reversed MS2 from the forward
#' 
#' @param af An sequence of answer of the forward.
#' @param aas The sequence of amino acid residues.
calc_rev_ms2 <- function (af, aas) 
{
  l <- length(aas)
  l1 <- l - 1L
  l2 <- l - 2L
  sb <- af[2:l1]
  b <- c(af[1] + sb[l2] - sb[l2:1L], af[l1:l]) # 3.5 us
  nb <- c(aas[1], aas[l1:2], aas[l]) # 2.2 us
  names(b) <- nb
  
  ll <- l + l
  l3 <- ll - 1L
  sy <- af[(l+2L):l3]
  y <- c(af[l+1L] + sy[l2] - sy[l2:1L], af[l3:ll]) # 3.5 us
  names(y) <- nb[l:1L]
  
  c(b, y)
}


#' Binds data frames
#'
#' Assume identical column names across data frames. Also different to
#' \link[dplyr]{bind_rows} by row names.
#'
#' @param dfs A list of data frames.
bind_dfs <- function (dfs)
{
  nrs <- lapply(dfs, nrow)
  oks <- nrs > 0L
  dfs <- dfs[oks]
  nrs <- nrs[oks]
  
  lens <- unlist(nrs)
  tlen <- sum(lens)
  lend <- length(dfs)
  
  if (tlen == 1L || lend == 1L)
    return(dfs[[1]])
  
  cns <- colnames(dfs[[1]])
  out <- data.frame(matrix(ncol = length(cns), nrow = tlen))
  colnames(out) <- cns
  
  ends <- cumsum(lens)
  stas <- c(1, ends + 1L)
  
  for (i in seq_along(dfs))
    out[stas[[i]]:ends[[i]], ] <- dfs[[i]]

  out
}


#' Find the minimal number of cores.
#' 
#' @param x The number of files.
#' @param n The number of cores where \code{x > n > 1}.
find_min_ncores <- function (x = 25, n = 6)
{
  if (x <= 0)
    stop("`x` needs to be greater than zero.")
  
  if (n <= 1L)
    return(n)
  
  if (x <= n)
    return(x)
  
  len <- ceiling(x/n)
  len2 <- ceiling(x/(n2 <- n - 1L))
  # len2 >= len
  
  while(len2 == len) {
    n <- n2
    len <- len2
    n2 <- n - 1L # ok n2 == 0L
    len2 <- ceiling(x/n2)
  }
  
  n
}


### Also in proteoQ

#' Prefix form of colnames(x)[c(2, 5, ...)] for use in pipes
#'
#' \code{names_pos<-} rename the columns at the indexes of \code{pos}.
#'
#' @param x A data frame.
#' @param pos Numeric.  The index of columns for name change.
#' @param value Characters.  The new column names.
#' @return The data frame with new names.
#'
#' @import dplyr
#' @importFrom magrittr %>% %T>% %$% %<>%
`names_pos<-` <- function(x, pos, value) 
{
  names(x)[pos] <- value
  x
}


#' Re-order columns in a data frame
#'
#' \code{ins_cols_after} re-orders columns in a data frame.
#'
#' @param df A data frame.
#' @param idx_bf A column index for the insertion of columns after.
#' @param idx_ins Column index(es) for the columns to be inserted after
#'   \code{idx_bf}.
#' @import dplyr
#' @importFrom stringr str_split
#' @importFrom magrittr %>% %T>% %$% %<>%
ins_cols_after <- function(df = NULL, idx_bf = ncol(df), idx_ins = NULL) 
{
  if (is.null(df)) 
    stop("`df` cannot be `NULL`.", call. = FALSE)
  
  if (is.null(idx_ins)) 
    return(df)
  
  if (idx_bf >= ncol(df)) 
    return(df)
  
  col_nms <- names(df)[idx_ins]
  
  dplyr::bind_cols(
    df[, 1:idx_bf, drop = FALSE],
    df[, idx_ins, drop = FALSE],
    dplyr::select(df[, (idx_bf + 1):ncol(df), drop = FALSE], -col_nms))
}


#' Pad columns to a placeholder data frame.
#'
#' @param df The original data frame.
#' @param df2 The data frame to be inserted.
#' @param idx The index of \code{df} column for \code{df2} to be inserted
#'   (after).
add_cols_at <- function(df, df2, idx) 
{
  if (idx < 0L)
    stop("Column index ", idx, " cannot be negative.")
  
  bf <- if (idx == 0L) 
    NULL
  else 
    df[, seq_len(idx), drop = FALSE]
  
  af <- if ((idx + 1L) <= ncol(df)) 
    df[, (idx + 1L) : ncol(df), drop = FALSE]
  else 
    NULL
  
  dplyr::bind_cols(
    bf,
    df2,
    af)
}


#' Replace columns in the original PSM table.
#'
#' The column index(es) need to be continuous.
#'
#' @param df The original data frame.
#' @param df2 The data columns to replace those in \code{df}.
#' @param idxs The sequences of column indexes in \code{df}. Note that
#'   \code{idxs} need to be a continuous sequences.
replace_cols_at <- function(df, df2, idxs) 
{
  ncol <- ncol(df)
  
  if (!all(idxs >= 1L))
    stop("Not all indexes are greater or equal to one.")
  
  if (!all(idxs <= ncol))
    stop("Not all indexes are smaller or equal to the number of columns.")
  
  idxs <- sort(idxs)
  stopifnot(all.equal(idxs - idxs[1] + 1L, seq_along(idxs)))
  
  bf <- if (idxs[1] >= 2L) 
    df[, 1:(idxs[1]-1L), drop = FALSE]
  else 
    NULL
  
  af <- if (idxs[length(idxs)] < ncol(df)) 
    df[, (idxs[length(idxs)]+1L):ncol(df), drop = FALSE]
  else 
    NULL
  
  dplyr::bind_cols(
    bf,
    df2,
    af)
}


#' Relocate column "to_move" immediately after column "col_before".
#'
#' @param df The original data frame.
#' @param to_move The column to be moved.
#' @param col_before The anchor column to which the \code{to_move} will be moved
#'   after.
reloc_col_after <- function(df, to_move = "after_anchor", col_before = "anchor") 
{
  if (!(to_move %in% names(df) && col_before %in% names(df))) 
    return(df)
  
  if (to_move == col_before) 
    return(df)
  
  df2 <- dplyr::select(df, one_of(to_move))
  df <- dplyr::select(df, -one_of(to_move))
  
  idx <- which(names(df) == col_before)
  df <- add_cols_at(df, df2, idx)
  
  invisible(df)
}


#' Relocate column "to_move" immediately after the last column.
#'
#' @inheritParams reloc_col_after
reloc_col_after_last <- function (df, to_move = "after_anchor") 
{
  col_last <- names(df)[ncol(df)]
  reloc_col_after(df, to_move, col_last)
}


#' Relocate column "to_move" immediately after the first column.
#'
#' @inheritParams reloc_col_after
reloc_col_after_first <- function(df, to_move = "after_anchor") 
{
  col_first <- names(df)[1]
  reloc_col_after(df, to_move, col_first)
}


#' Relocate column "to_move" immediately before anchor column "col_after".
#'
#' The same as \code{reloc_col}.
#'
#' @param df The original data frame.
#' @param to_move The column to be moved.
#' @param col_after The anchor column to which the \code{to_move} will be moved
#'   before.
reloc_col_before <- function(df, to_move = "before_anchor",
                             col_after = "anchor") 
{
  if (!(to_move %in% names(df) && col_after %in% names(df))) 
    return(df)
  
  df2 <- dplyr::select(df, one_of(to_move))
  df <- dplyr::select(df, -one_of(to_move))
  
  idx <- which(names(df) == col_after)
  
  df <- add_cols_at(df, df2, idx - 1)
  
  invisible(df)
}


#' Relocate column "to_move" immediately before the last column.
#'
#' @inheritParams reloc_col_after
reloc_col_before_last <- function(df, to_move = "after_anchor") 
{
  col_last <- names(df)[ncol(df)]
  reloc_col_before(df, to_move, col_last)
}


#' Relocate column "to_move" immediately before the first column.
#'
#' @inheritParams reloc_col_after
reloc_col_before_first <- function (df, to_move = "after_anchor") 
{
  col_first <- names(df)[1]
  reloc_col_before(df, to_move, col_first)
}


#' Helper: find the column name before \code{to_move}.
#'
#' To keep columns at the same order after descriptive summary.
#'
#' @inheritParams reloc_col_after
find_preceding_colnm <- function(df, to_move) 
{
  if (!to_move %in% names(df)) 
    stop("Column ", to_move, " not found.", call. = FALSE)

  ind_bf <- which(names(df) == to_move) - 1L
  
  if (ind_bf == 0L) 
    names(df)[1]
  else 
    names(df)[ind_bf]
}


#' Flatten lists recursively
#'
#' @param x Lists
recur_flatten <- function (x) 
{
  if (!inherits(x, "list")) 
    list(x)
  else 
    .Internal(unlist(c(lapply(x, recur_flatten)), recursive = FALSE, 
                     use.names = FALSE))
}


### End of also in proteoQ



#' Splits data into chunks by length.
#'
#' @param data Input data.
#' @param n_chunks The number of chunks.
#' @param type The type of data for splitting.
#' @param ... Arguments for \link{findInterval}.
chunksplit <- function (data, n_chunks = 5L, type = c("list", "row"), ...)
{
  type <- match.arg(type)
  
  if (!type %in% c("list", "row"))
    stop("The value of \"type\" needs to be either \"list\" or \"row\".")

  if (n_chunks <= 1L) 
    return(data)
  
  if (type == "list") 
    len <- length(data)
  else if (type == "row") 
    len <- nrow(data)
  else 
    stop("Unknown type.", call. = TRUE)
  
  if (len == 0L) 
    return(data)
  
  labs <- levels(cut(1:len, n_chunks))
  
  x <- cbind(lower = floor(as.numeric( sub("\\((.+),.*", "\\1", labs))),
             upper = ceiling(as.numeric( sub("[^,]*,([^]]*)\\]", "\\1", labs))))
  
  grps <- findInterval(1:len, x[, 1], ...)
  
  split(data, grps)
}


#' Splits data into chunks with approximately equal sizes.
#'
#' @param nx Positive integer; an arbitrarily large number for data to be split
#'   into for estimating the cumulative sizes.
#' @inheritParams chunksplit
chunksplitLB <- function (data, n_chunks = 5L, nx = 100L, type = "list") 
{
  if (!type %in% c("list", "row"))
    stop("The value of \"type\" needs to be either \"list\" or \"row\".")

  if (n_chunks <= 1L) 
    return(data)
  
  if (type == "list") 
    len <- length(data)
  else if (type == "row") 
    len <- nrow(data)
  else 
    stop("Unknown type.", call. = TRUE)
  
  if (len == 0L) 
    return(data)
  
  # The finer groups by 'nx'
  grps_nx <- local({
    labsx <- levels(cut(1:len, nx))
    
    xx <- cbind(lower = floor(as.numeric( sub("\\((.+),.*", "\\1",
                                              labsx))),
                upper = ceiling(as.numeric( sub("[^,]*,([^]]*)\\]", "\\1",
                                                labsx))))
    
    findInterval(1:len, xx[, 1])
  })
  
  # The equated size for a chunk
  size_chunk <- local({
    size_nx <- data %>%
      split(., grps_nx) %>%
      lapply(object.size) %>%
      cumsum()
    
    size_nx[length(size_nx)]/n_chunks
  })
  
  #  Intervals
  grps <- local({
    size_data <- data %>%
      lapply(object.size) %>%
      cumsum()
    
    # the position indexes
    ps <- purrr::map_dbl(1:(n_chunks-1), function (x) {
      which(size_data < size_chunk * x) %>% `[`(length(.))
    })
    
    grps <- findInterval(1:len, ps)
  })
  
  split(data, grps)
}


#' Finds a file directory.
#'
#' With the option of creating a directory
#'
#' @param path A file path.
#' @param create Logical; if TRUE create the path if not yet existed.
find_dir <- function (path, create = FALSE) 
{
  if (length(path) != 1L)
    stop("Length of `path` is not exactly one: ", paste(path, collapse = ", "))

  path <- gsub("\\\\", "/", path)
  
  p1 <- fs::path_expand_r(path)
  p2 <- fs::path_expand(path)
  
  if (fs::dir_exists(p1)) {
    path <- p1
  } 
  else if (fs::dir_exists(p2)) {
    path <- p2
  } 
  else {
    if (create) {
      dir.create(file.path(path), recursive = TRUE, showWarnings = FALSE)
      # ensure fs_path class for argument matches 
      path <- fs::path(p1)
    } 
    else {
      message(path, " not found.")
      path <- NULL
    }
  }
  
  path
}


#' Creates a file directory.
#'
#' @inheritParams find_dir
create_dir <- function (path) find_dir(path, create = TRUE)


#' Saves the arguments in a function call
#'
#' @param path A (system) file path.
#' @param fun The name of function being saved.
#' @param time The time stamp.
save_call2 <- function(path, fun, time = NULL) 
{
  if (length(path) != 1L)
    stop("Length of `path` is not exactly one: ", paste(path, collapse = ", "))
  
  if (length(fun) != 1L)
    stop("Length of `fun` is not exactly one: ", paste(fun, collapse = ", "))

  call_pars <- mget(names(formals(fun)), envir = parent.frame(), inherits = FALSE)
  call_pars[names(call_pars) == "..."] <- NULL
  
  if (is.null(time)) {
    p2 <- create_dir(path)
    save(call_pars, file = file.path(p2, paste0(fun, ".rda")))
  } 
  else {
    if (length(time) != 1L)
      stop("Length of `time` is not exactly one: ", paste(time, collapse = ", "))

    p2 <- create_dir(file.path(path, fun))
    save(call_pars, file = file.path(p2, paste0(time, ".rda")))
  }
}


#' Finds the values of a list of arguments from caches.
#'
#' Back-compatibility: if \code{new_args} are not in an earlier version. The
#' \emph{default} value from the current version will be added to cached
#' results.
#'
#' @param args Arguments to be matched.
#' @param new_args vector of argument_name-default_value pairs; new arguments
#'   that are not in earlier versions.
#'
#' @inheritParams save_call2
#' @import dplyr purrr
#' @importFrom magrittr %>% %T>% %$%
#' @return The time stamp of a matched cache results.
find_callarg_vals <- function (time = NULL, path = NULL, fun = NULL,
                               args = NULL, new_args = NULL) 
{
  if (length(path) != 1L)
    stop("Length of `path` is not exactly one: ", paste(path, collapse = ", "))
  
  if (length(fun) != 1L)
    stop("Length of `fun` is not exactly one: ", paste(fun, collapse = ", "))

  file <- if (is.null(time)) file.path(path, fun) else file.path(path, fun, time)

  if (!file.exists(file)) 
    return(NULL)

  load(file = file)
  
  # --- back-compatibility
  if ((!is.null(new_args)) && is.null(names(new_args))) 
    stop("Need named vector for `new_args`.")
  
  if (!is.null(new_args)) {
    call_pars <- local({
      nargs <- c(# n_13c = 0L, min_ms1_charge = 2L, max_ms1_charge = 6L, 
                 new_args)
      
      for (i in seq_along(nargs)) {
        x <- nargs[i]
        nm <- names(x)
        val <- unname(x)
        
        # nm in "must-matched" args but not in earlier "call_pars"
        if ((nm %in% args) && (! nm %in% names(call_pars))) {
          if (is_nulllist(x))
            call_pars <- c(call_pars, x)
          else
            call_pars[[nm]] <- val
        }
      }
      
      call_pars
    })
  }

  nots <- which(! args %in% names(call_pars))
  
  if (length(nots)) 
    stop("Arguments '", paste(args[nots], collapse = ", "),
         "' not found in the latest call to `", fun, "`.\n", 
         "This is probably due to new argument implementation in `matchMS`.\n", 
         "Delete `", file.path(path, fun), "`", " and try again.", 
         call. = FALSE)

  call_pars[args]
}


#' Finds the time stamp of a matched call from cached results.
#'
#' @param nms Names of arguments to be included in or excluded from matching.
#' @param type Logical; if TRUE, includes all arguments in \code{nms}. At FALSE,
#'   excludes all \code{nms}.
#' @param new_args Named vector; new arguments that are not in earlier versions.
#' @inheritParams find_callarg_vals
#' @return An empty object if no matches.
#' @examples
#' \dontrun{
#' library(mzion)
#' 
#' .time_bin <- mzion:::match_calltime(
#'   path = file.path(.path_cache, "calc_pepmasses2", .time_stamp), 
#'   fun = fun,
#'   nms = c("min_mass", "max_mass", "ppm_ms1", "calib_ms1mass"), 
#'   new_args = c(calib_ms1mass = calib_ms1mass)) 
#' }
match_calltime <- function (path = "~/mzion/.MSearches/Cache/Calls",
                            fun = "calc_pepmasses2", nms = c("out_path"),
                            type = c(TRUE, FALSE), new_args = NULL)
{
  if (!(len_path <- length(path)))
    return(NULL)
  
  if (len_path > 1L)
    stop("Multiple pathes to cache folder.")
  
  if (length(fun) != 1L) 
    stop("Multiple functions: ", fun)

  if (length(type) > 1L) 
    type <- TRUE
  
  # if (!all(names(new_args) %in% nms))
  #   warning("Developer: not all new arguments defined in the required list.")
  
  # current values
  fml_nms <- names(formals(fun))
  
  args <- if (type) 
    mget(fml_nms[fml_nms %in% nms], envir = parent.frame(), inherits = FALSE)
  else 
    mget(fml_nms[!fml_nms %in% nms], envir = parent.frame(), inherits = FALSE)

  if (!length(args)) 
    stop("Arguments for matching is empty.")
  
  args  <- lapply(args, function (x) if (is.list(x)) lapply(x, sort) else sort(x))
  times <- list.files(path = file.path(path, fun), pattern = "\\.rda$", all.files = TRUE)

  # cached values
  cached <- lapply(times, find_callarg_vals, path = path, fun = fun,
                   args = names(args), new_args = new_args)
  
  cached <- lapply(cached, function (x) lapply(x, function (v) {
    if (is.list(v)) lapply(v, sort) else sort(v)
  }))
  
  # matched
  oks <- lapply(cached, identical, args)
  oks <- unlist(oks, recursive = FALSE, use.names = FALSE)
  
  gsub("\\.rda$", "", times[oks])
}


#' Deletes files under a directory.
#'
#' The directory will be kept.
#' 
#' @param path A file path.
#' @param ignores The file extensions to be ignored.
#' @param paths_excluded The path to be ignored.
#' @param ... Arguments for file.remove.
delete_files <- function (path, ignores = NULL, paths_excluded = NULL, ...) 
{
  
  # Hadley Ch.19 Quasiquotation, note 97
  dots <- as.list(substitute(...()))
  recursive <- dots[["recursive"]]
  dots$recursive <- NULL
  
  if (is.null(recursive)) 
    recursive <- TRUE
  
  if (!is.logical(recursive)) 
    stop("Not logical `recursive`.")

  args <- c(list(path = file.path(path), recursive = recursive,
                 full.names = TRUE), dots)
  
  nms <- do.call(list.files, args)
  
  if (length(nms) && length(paths_excluded)) {
    ignore_case <- if (Sys.info()['sysname'] == "Windows") TRUE else FALSE
    
    for (i in seq_along(paths_excluded))
      nms <- nms[!grepl(paths_excluded[[i]], nms, ignore.case = ignore_case)]
  }

  if (!is.null(ignores)) {
    dirs <- list.dirs(path, full.names = FALSE, recursive = recursive)
    dirs <- dirs[dirs != ""]
    oks <- purrr::map_lgl(dirs, function (x) 
      any(grepl(x, ignores, ignore.case = TRUE)))
    nms_oks <- list.files(path = file.path(path, dirs[oks]),recursive = TRUE, 
                          full.names = TRUE)
    nms <- nms[!nms %in% nms_oks]
    
    exts <- gsub("^.*(\\.[^.]*)$", "\\1", nms)
    oks <- purrr::map_lgl(exts, function (x) any(grepl(x, ignores)))
    nms <- nms[!oks]
  }

  if (length(nms)) 
    suppressMessages(file.remove(file.path(nms)))

  invisible(NULL)
}


#' Finds the time stamp(s) of MS1 precursors.
#' 
#' @param out_path An output path.
find_ms1_times <- function (out_path) 
{
  file <- file.path(out_path, "Calls", ".cache_info.rds")
  
  if (file.exists(file)) {
    .cache_info <- qs::qread(file)
    .time_stamp <- .cache_info$.time_stamp
    
    if (is.null(.time_stamp))
      stop("Cannot find `.time_stamp`.")
    
    return(.time_stamp)
  }
  
  # not really used; may return(NULL)
  file2 <- file.path(out_path, "temp", "out_paths.rds")
  
  if (file.exists(file2)) {
    out_paths <- qs::qread(file2)
    
    .cache_infos <- 
      lapply(out_paths, function (x) qs::qread(file.path(x, "Calls", ".cache_info.rds")))

    # multiple time stamps (e.g. group searches)
    return(lapply(.cache_infos, function (x) x[[".time_stamp"]]))
  }
  else {
    stop("Cannot find `.time_stamp`.")
  }
}


#' Is a NULL list?
#' 
#' @param x A list.
#' 
#' @examples 
#' \dontrun{
#' library(mzion)
#' mzion:::is_nullist(list(a = NULL))
#' }
is_nulllist <- function (x) length(x) == 1L && is.null(x[[1]])


#' Adds a plain NULL entry to a list.
#' 
#' This is different to, for example, \code{x[["a"]] <- list(NULL)}.
#' 
#' @param l A list.
#' @param nm A character vector of name.
#' 
#' @examples
#' \dontrun{
#' library(mzion)
#' mzion::add_nulllist(list(a = 2, b = 3), "m")
#' } 
add_nulllist <- function (l, nm)
{
  l <- c(l, list(NULL))
  names(l)[length(l)] <- nm
  
  l
}


#' Calculates the mono-isotopic mass of a peptide sequence.
#'
#' Only for direct uses from an R console (with trade-offs in speed).
#'
#' @inheritParams calc_monopep
#' @inheritParams calc_aamasses
#'
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' ## No variable modifications
#' # (1)
#' x <- calc_monopeptide(aa_seq = "MAKEMASSPECFUN",
#'                       fixedmods = NULL,
#'                       varmods = NULL)
#'
#' stopifnot((unlist(x$mass) - 1594.5369) < 1e-4)
#'
#' # (2-a)
#' x <- calc_monopeptide(aa_seq = "MAKEMASSPECFUN",
#'                       fixedmods = "Oxidation (M)",
#'                       varmods = NULL)
#'
#' m <- unlist(x$mass)
#'
#' stopifnot((m[1] - 1626.5267) < 1e-4)
#'
#' # (2-b) combinatorial NL for fixed modifications
#' x <- calc_monopeptide(aa_seq = "MAKEMASSPECFUN",
#'                       fixedmods = "Oxidation (M)",
#'                       varmods = NULL)
#'
#' m <- unlist(x$mass)
#'
#' stopifnot(length(m) == 2L)
#' stopifnot((m[1] - m[2] - 127.9965) < 1e-4)
#'
#' ## With variable modifications
#' # (3-a)
#' x <- calc_monopeptide(aa_seq = "MAKEMASSPECFUN",
#'                       fixedmods = NULL,
#'                       varmods = "Oxidation (M)")
#'
#' m <- unlist(x$mass)
#'
#' stopifnot((m[1] - 1594.5369) < 1e-4)
#' stopifnot((m[2] - m[1]) == (m[3] - m[2]))
#'
#' # x$vmods_ps
#'
#' # (3-b)
#' x <- calc_monopeptide(aa_seq = "MAKEMASSPECFUN",
#'                       fixedmods = NULL,
#'                       varmods = "Oxidation (M)")
#'
#' x$mass
#'
#' # (4-a)
#' x <- calc_monopeptide(aa_seq = "MAKEMASSPECFUN",
#'                       fixedmods = c("TMT6plex (N-term)",
#'                                     "TMT6plex (K)",
#'                                     "Carbamidomethyl (C)"),
#'                       varmods = c("Acetyl (N-term)",
#'                                   "Gln->pyro-Glu (N-term = Q)",
#'                                    "Oxidation (M)"))
#'
#' x$mass
#'
#' # The N-term M realizes with acetylation
#' x$vmods_ps[[1]]
#'
#' # The N-term M realizes with TMT
#' x$vmods_ps[[2]]
#'
#'
#' # (4-b)
#' x <- calc_monopeptide(aa_seq = "MAKEMASSPECFUN",
#'                       fixedmods = c("TMT6plex (N-term)",
#'                                     "TMT6plex (K)",
#'                                     "Carbamidomethyl (C)"),
#'                       varmods = c("Acetyl (N-term)",
#'                                   "Gln->pyro-Glu (N-term = Q)",
#'                                   "Oxidation (M)"))
#'
#' x$mass
#' }
#' @export
calc_monopeptide <- function (aa_seq, fixedmods, varmods,
                              maxn_vmods_setscombi = 64L,
                              maxn_vmods_per_pep = Inf,
                              maxn_sites_per_vmod = Inf,
                              min_mass = 200L, 
                              max_mass = 4500L) 
{
  options(digits = 9L)
  
  aa_masses_all <- calc_aamasses(fixedmods = fixedmods,
                                 varmods = varmods,
                                 maxn_vmods_setscombi = maxn_vmods_setscombi)
  
  peps <- check_aaseq(aa_seq, aa_masses_all, fixedmods, varmods)
  oks <- unlist(lapply(peps, function (x) length(x) > 0L))
  peps <- peps[oks]
  aa_masses_all <- aa_masses_all[oks]
  
  ms <- purrr::map2(peps, aa_masses_all, ~ {
    calc_monopep(.x, .y,
                 maxn_vmods_per_pep = maxn_vmods_per_pep,
                 maxn_sites_per_vmod = maxn_sites_per_vmod,
                 min_mass = min_mass, 
                 max_mass = max_mass)
  })
  
  attrs <- purrr::map(aa_masses_all, attributes)
  vmods_ps <- map(attrs, `[[`, "vmods_ps")
  
  list(mass = ms, vmods_ps = vmods_ps)
}


#' Calculates the mono-isotopic mass of a peptide sequence.
#'
#' Only used for calc_monopeptide at a user's interface. Typically coupled to
#' \link{subpeps_by_vmods} for automatic dispatching of peptide sequences by
#' sets of fixed and variable modifications. For manual calculations, uses
#' \link{calc_monopeptide}.
#'
#' @param aa_seq Character string; a peptide sequences with one-letter
#'   representation of amino acids.
#' @inheritParams add_var_masses
#' @inheritParams calc_pepmasses2
#' @import purrr
#' @importFrom stringr str_split
calc_monopep <- function (aa_seq, aa_masses,
                          maxn_vmods_per_pep = 5L,
                          maxn_sites_per_vmod = 3L,
                          min_mass = 200L, 
                          max_mass = 4500L) 
{
  if (is.na(aa_seq)) return(NULL)
  
  aas <- stringr::str_split(aa_seq, "", simplify = TRUE)
  type <- attr(aa_masses, "type", exact = TRUE)
  
  # bare
  mass <- aas %>%
    aa_masses[.] %>%
    sum() %>%
    `+`(aa_masses["N-term"]) %>%
    `+`(aa_masses["C-term"]) %>%
    stats::setNames(aa_seq) %>%
    round(digits = 4L)
  
  if (type == "amods- tmod- vnl- fnl-") {
    return(mass)
  }
  
  # adds terminal mass
  if (grepl("tmod+", type, fixed = TRUE)) {
    mass <- add_term_mass(mass, aa_masses, min_mass, max_mass)
  }
  
  # --- Mass of variable mods and/or NLs ---
  fmods_ps <- attr(aa_masses, "fmods_ps", exact = TRUE)
  vmods_ps <- attr(aa_masses, "vmods_ps", exact = TRUE)
  fmods_nl <- attr(aa_masses, "fmods_nl", exact = TRUE)
  vmods_nl <- attr(aa_masses, "vmods_nl", exact = TRUE)
  amods <- attr(aa_masses, "amods", exact = TRUE)
  tmod <- attr(aa_masses, "tmod", exact = TRUE)
  
  # (5, 6) "amods- tmod+ vnl- fnl+", "amods- tmod- vnl- fnl+"
  if (TRUE) {
    if (type %in% c("amods- tmod- vnl- fnl+", "amods- tmod+ vnl- fnl+")) {
      fnl_combi <- expand_grid_rows0(fmods_nl)
      deltas <- delta_ms1_a0_fnl1(fnl_combi, aas, aa_masses)
      masses <- round(mass - deltas, digits = 4L)
    }
    else {
      masses <- mass
    }
  } 
  else {
    masses <- mass
  }
  
  # `amods+`; (9-14) nested under (7-8)
  #
  # (7-8) "amods+ tmod- vnl- fnl-", "amods+ tmod+ vnl- fnl-"
  #   (9-10) "amods+ tmod- vnl+ fnl-", "amods+ tmod+ vnl+ fnl-"
  #   (11-12) "amods+ tmod- vnl- fnl+", "amods+ tmod+ vnl- fnl+"
  #   (13-14) "amods+ tmod- vnl+ fnl+", "amods+ tmod+ vnl+ fnl+"
  
  ok <- type %in% c("amods+ tmod- vnl- fnl-",
                    "amods+ tmod+ vnl- fnl-",
                    "amods+ tmod- vnl+ fnl-",
                    "amods+ tmod+ vnl+ fnl-",
                    "amods+ tmod- vnl- fnl+",
                    "amods+ tmod+ vnl- fnl+",
                    "amods+ tmod- vnl+ fnl+",
                    "amods+ tmod+ vnl+ fnl+")
  
  if (ok) {
    vmods_combi <- unique_mvmods(amods = amods, ntmod = NULL, ctmod = NULL,
                                 aa_masses = aa_masses, aas = aas,
                                 maxn_vmods_per_pep = maxn_vmods_per_pep,
                                 maxn_sites_per_vmod = maxn_sites_per_vmod) %>% 
      find_intercombi()

    deltas <- unname(lapply(vmods_combi, function (x) sum(aa_masses[x])))
    
    masses <- 
      sapply(deltas, function (x) round(unlist(masses) + x, digits = 4L))
  }
  
  masses
}


#' Checks the validity of a peptide sequence and dispatched it by fixedmods and
#' varmods.
#'
#' A sequence may be invalid at a given set of fixedmods and varmods. For
#' example, "MAKEMASSPECFUN" cannot have a mod of "Gln->pyro-Glu (N-term = Q)".
#' 
#' @param aa_seq Character string; a peptide sequences with one-letter
#'   representation of amino acids.
#' @param aa_masses_all All the amino acid lookup tables.
#' @inheritParams matchMS
check_aaseq <- function (aa_seq, aa_masses_all, fixedmods, varmods) 
{
  if (any(grepl("Protein N-term", fixedmods))) 
    stop("Need to change fixed 'Protein N-term' modification to variable.", 
         call. = FALSE)

  if (any(grepl("Protein C-term", fixedmods))) 
    stop("Need to change fixed 'Protein C-term' modification to variable.", 
         call. = FALSE)

  # ---
  has_prot_nt <- any(grepl("Protein N-term", varmods))
  
  if (has_prot_nt) {
    aa_seq <- paste0("-", aa_seq)
  }
  
  has_prot_ct <- any(grepl("Protein C-term", varmods))
  
  if (has_prot_ct) 
    aa_seq <- paste0(aa_seq, "-")
  
  peps <- lapply(aa_masses_all, subpeps_by_vmods, aa_seq) %>%
    flatten_list()
  
  if (has_prot_nt) 
    peps <- purrr::map(peps, ~ gsub("^-", "", .x))

  if (has_prot_ct) 
    peps <- purrr::map(peps, ~ gsub("-$", "", .x))

  invisible(peps)
}


#' Calculates the mono-isotopic mass of a MS2 ions.
#'
#' For direct uses from an R console (with trade-offs in speed).
#'
#' @inheritParams calc_ms2ions
#' @inheritParams calc_monopeptide
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' ## No variable modifications
#' # (1)
#' x <- calc_ms2ionseries("MAKEMASSPECFUN", 
#'                        fixedmods = NULL, 
#'                        varmods = NULL)
#' 
#' x$mass
#' 
#' # (2) no combinatorial NL for fixed modifications
#' x <- calc_ms2ionseries("MAKEMASSPECFUN", 
#'                        fixedmods = "Oxidation (M)", 
#'                        varmods = NULL)
#'                        
#' x$mass
#' 
#' ## With variable modifications
#' # (3) combinatorial sites and NL available
#' aa_seq <- "MAKEMASSPECFUN"
#' fixedmods <- NULL
#' varmods <- "Oxidation (M)"
#' ms <- calc_monopeptide(aa_seq, fixedmods, varmods)
#' 
#' x <- calc_ms2ionseries(aa_seq, fixedmods = fixedmods, varmods = varmods, 
#'                        ms1_mass = ms$mass[[2]][1])
#' 
#' x$mass
#' # x$vmods_ps
#' 
#' # (4)
#' aa_seq <- "MAKEMASSPECFUN"
#' fixedmods <- c("TMT6plex (N-term)", "TMT6plex (K)", "Carbamidomethyl (C)")
#' varmods <- c("Acetyl (N-term)", "Gln->pyro-Glu (N-term = Q)", "Oxidation (M)")
#' ms <- calc_monopeptide(aa_seq, fixedmods, varmods)
#' 
#' x <- calc_ms2ionseries(aa_seq, fixedmods = fixedmods, varmods = varmods, 
#'                        ms1_mass = ms$mass[[4]][[1]])
#'                       
#' x$mass
#' 
#' # (5) Neutral losses for occurrences of both fixed 
#' aa_seq <- "MAKEMASSPECFUN"
#' fixedmods <- c("TMT6plex (N-term)", "Oxidation (M)", "Deamidated (N)")
#' varmods <- c("dHex (S)")
#' ms <- calc_monopeptide(aa_seq, fixedmods, varmods)
#' 
#' # and variable modifications ignored
#' x <- calc_ms2ionseries(aa_seq, fixedmods = fixedmods, varmods = varmods, 
#'                        ms1_mass = 2002.7316)
#'                       
#' stopifnot(is.null(x$mass[[2]]))
#' 
#' # Change from fixed to variable for full combinatorials
#' fixedmods <- c("TMT6plex (N-term)", "Deamidated (N)")
#' varmods <- c("Acetyl (Protein N-term)", "Oxidation (M)", "dHex (S)")
#' 
#' x <- calc_ms2ionseries(aa_seq, fixedmods = fixedmods, varmods = varmods, 
#'                        ms1_mass = 2002.7316)
#'                       
#' x$mass[[8]]
#' x$vmods_ps[[8]]
#' 
#' # (6) A lot of S
#' aa_seq <- "MAKEMASSSSSSPECFUNSS"
#' fixedmods <- c("TMT6plex (N-term)", "TMT6plex (K)", "Carbamidomethyl (C)")
#' varmods <- c("Acetyl (N-term)", "Oxidation (M)", "Deamidated (N)", 
#'              "Phospho (S)", "Phospho (T)", "Phospho (Y)", 
#'              "Gln->pyro-Glu (N-term = Q)")
#' ms <- calc_monopeptide(aa_seq, fixedmods, varmods)
#' 
#' x <- calc_ms2ionseries(aa_seq, fixedmods = fixedmods, varmods = varmods, 
#'                        ms1_mass = 2649.0553)
#' 
#' # (7) A lot of S and Y
#' aa_seq <- "MAKEMASSSSSSPECFUNSSYYYYYYY"
#' fixedmods <- c("TMT6plex (N-term)", "TMT6plex (K)", "Carbamidomethyl (C)")
#' varmods <- c("Acetyl (N-term)", "Oxidation (M)", "Deamidated (N)", 
#'              "Phospho (S)", "Phospho (T)", "Phospho (Y)", 
#'              "Gln->pyro-Glu (N-term = Q)")
#' ms <- calc_monopeptide(aa_seq, fixedmods, varmods)
#' x <- calc_ms2ionseries(aa_seq, fixedmods = fixedmods, varmods = varmods, 
#'                        ms1_mass = ms$mass[[21]][[3]])
#' }
#' #' 
#' # (8) Carbamyl (K), Acetyl (K), Oxidation (M)
#' aa_seq <- "MAKKKKKKKKKEMASSPECFUN"
#' fixedmods <- c("TMT6plex (N-term)", "TMT6plex (K)", "Carbamidomethyl (C)")
#' varmods <- c("Oxidation (M)", "Deamidated (N)", 
#'              "Acetyl (K)", "Carbamyl (K)")
#' ms <- calc_monopeptide(aa_seq, fixedmods, varmods)
#' x  <- calc_ms2ionseries(aa_seq, fixedmods = fixedmods, varmods = varmods, 
#'                         ms1_mass = ms$mass[[21]][[5]])
#' @export
calc_ms2ionseries <- function (aa_seq, fixedmods, varmods, 
                               type_ms2ions = "by", ms1_mass = NULL, 
                               maxn_vmods_setscombi = 512L,
                               maxn_vmods_per_pep = 5L, 
                               maxn_sites_per_vmod = 3L, 
                               maxn_vmods_sitescombi_per_pep = 32L, 
                               maxn_fnl_per_seq = 3L, 
                               maxn_vnl_per_seq = 3L) 
{
  options(digits = 9L)
  
  aa_masses_all <- calc_aamasses(fixedmods = fixedmods,
                                 varmods = varmods,
                                 maxn_vmods_setscombi = maxn_vmods_setscombi)
  
  peps <- check_aaseq(aa_seq, aa_masses_all, fixedmods, varmods)
  oks <- unlist(lapply(peps, function (x) length(x) > 0L))
  peps <- peps[oks]
  aa_masses_all <- aa_masses_all[oks]
  
  mod_indexes <- seq_along(c(fixedmods, varmods)) %>% 
    as.hexmode() %>% 
    `names<-`(c(fixedmods, varmods))
  
  ms <- mapply(function (x, y) {
    pri <- calc_ms2ions(x, y, ms1_mass, mod_indexes, type_ms2ions, 
                        maxn_vmods_per_pep = maxn_vmods_per_pep, 
                        maxn_sites_per_vmod = maxn_sites_per_vmod, 
                        maxn_vmods_sitescombi_per_pep = maxn_vmods_sitescombi_per_pep, 
                        maxn_fnl_per_seq = maxn_fnl_per_seq, 
                        maxn_vnl_per_seq = maxn_vnl_per_seq)
    
    sec <- lapply(pri, add_seions, type_ms2ions = type_ms2ions)
    list(pri = pri, sec = sec)
  }, peps, aa_masses_all, SIMPLIFY = FALSE, USE.NAMES = FALSE)

  attrs <- lapply(aa_masses_all, attributes)
  vmods_ps <- lapply(attrs, `[[`, "vmods_ps")
  
  list(mass = lapply(ms, `[[`, "pri"), 
       sec_mass = lapply(ms, `[[`, "sec"), 
       vmods_ps = vmods_ps)
}


#' Calculates the masses of MS2 ion series.
#'
#' For a given type of fragmentation. Minimal error handling for speeds.
#'
#' @param ms1_mass The mass of a theoretical MS1 (for subsetting).
#' @param maxn_vmods_sitescombi_per_pep Integer; the maximum number of
#'   combinatorial variable modifications per peptide sequence.
#' @param type_ms2ions Character; the type of
#'   \href{http://www.matrixscience.com/help/fragmentation_help.html}{ MS2
#'   ions}. Values are in one of "by", "ax" and "cz". The default is "by" for b-
#'   and y-ions.
#' @inheritParams calc_monopep
#' @inheritParams calc_aamasses
#' @inheritParams ms2match
#' @import purrr
#'
#' @examples
#' \donttest{
#' library(mzion)
#' library(magrittr)
#' 
#' ## No variable modifications
#' # (1)
#' fixedmods <- NULL
#' varmods <- NULL
#'
#' mod_indexes <- seq_along(c(fixedmods, varmods)) %>%
#'   as.hexmode() %>%
#'   `names<-`(c(fixedmods, varmods))
#' aa_masses_all <- calc_aamasses(fixedmods, varmods)
#'
#' x <- mzion:::calc_ms2ions("MAKEMASSPECFUN", aa_masses_all[[1]], NULL, mod_indexes)
#'
#' }
calc_ms2ions <- function (aa_seq, aa_masses, ms1_mass = NULL, mod_indexes = NULL, 
                          type_ms2ions = "by", maxn_vmods_per_pep = 5L, 
                          maxn_sites_per_vmod = 3L, 
                          maxn_vmods_sitescombi_per_pep = 64L, 
                          maxn_fnl_per_seq = 3L, maxn_vnl_per_seq = 3L) 
{
  # tmt6_mass <- 229.162932
  # tmtpro_mass <- 304.207146
  # h2o <- 18.010565
  # proton <- 1.00727647
  # hydrogen <- 1.007825
  # carbon <- 12.0
  # oxygen <- 15.99491462
  # nitrogen <- 14.003074
  # h3o_p <- 19.0178415
  # electron <- 0.000549
  
  # moverz <- (mass + h2o + z*proton)/z
  # moverz*z 
  
  if (is.na(aa_seq) || is.null(aa_seq)) 
    return(NULL)
  
  aas <- stringr::str_split(aa_seq, "", simplify = TRUE)
  type <- attr(aa_masses, "type", exact = TRUE)
  
  FUN <- if (type %in% c("amods- tmod- vnl- fnl-", "amods- tmod+ vnl- fnl-"))
    "gen_ms2ions_base"
  else if (type %in% c("amods- tmod- vnl- fnl+", "amods- tmod+ vnl- fnl+"))
    "gen_ms2ions_a0_vnl0_fnl1"
  else if (type %in% c("amods+ tmod- vnl- fnl-", "amods+ tmod+ vnl- fnl-"))
    "gen_ms2ions_a1_vnl0_fnl0"
  else if (type %in% c("amods+ tmod- vnl+ fnl-", "amods+ tmod+ vnl+ fnl-"))
    "gen_ms2ions_a1_vnl1_fnl0"
  else if (type %in% c("amods+ tmod- vnl- fnl+", "amods+ tmod+ vnl- fnl+"))
    "gen_ms2ions_a1_vnl0_fnl1"
  else {
    # "amods+ tmod- vnl+ fnl+"
    message("Unknown modification type.") 
    return(NULL)
  }

  ntmod    <- attr(aa_masses, "ntmod", exact = TRUE)
  ctmod    <- attr(aa_masses, "ctmod", exact = TRUE)
  ntmass   <- find_nterm_mass(aa_masses)
  ctmass   <- find_cterm_mass(aa_masses)
  fmods_nl <- attr(aa_masses, "fmods_nl", exact = TRUE)
  vmods_nl <- attr(aa_masses, "vmods_nl", exact = TRUE)
  amods    <- attr(aa_masses, "amods", exact = TRUE)
  ms1vmods <- make_ms1vmod_i(aa_masses, maxn_vmods_per_pep = maxn_vmods_per_pep,
                             maxn_sites_per_vmod = maxn_sites_per_vmod)
  ms2vmods <- lapply(ms1vmods, make_ms2vmods)
  
  fmods_nl <- if (length(fmods_nl)) fmods_nl else NULL
  vmods_nl <- if (length(vmods_nl)) vmods_nl else NULL
  amods    <- if (length(amods)) amods else NULL
  ms1vmods <- if (length(ms1vmods)) ms1vmods else NULL
  ms2vmods <- if (length(ms2vmods)) ms2vmods else NULL
  
  do.call(FUN, 
          list(aa_seq = aa_seq, 
               ms1_mass = ms1_mass, 
               aa_masses = aa_masses, 
               ms1vmods = ms1vmods, 
               ms2vmods = ms2vmods, 
               ntmod = ntmod, 
               ctmod = ctmod, 
               ntmass = ntmass, 
               ctmass = ctmass, 
               amods = amods, vmods_nl = vmods_nl, fmods_nl = fmods_nl, 
               mod_indexes = mod_indexes, 
               type_ms2ions = type_ms2ions, 
               maxn_vmods_per_pep = maxn_vmods_per_pep, 
               maxn_sites_per_vmod = maxn_sites_per_vmod, 
               maxn_fnl_per_seq = maxn_fnl_per_seq, 
               maxn_vnl_per_seq = maxn_vnl_per_seq, 
               maxn_vmods_sitescombi_per_pep = maxn_vmods_sitescombi_per_pep))
}


#' The unique combinations of variable modifications.
#'
#' The same residue, e.g. M, at different modifications, c("Carbamyl (M",
#' "Oxidation (M)")).
#'
#' Goes over all the \code{Anywhere} modifications specified in \code{amods} for
#' a given \code{aa_masses}.
#'
#' @param amods Anywhere modifications.
#' @param ntmod The attribute \code{ntmod} from a \code{aa_masses} (for MS1
#'   calculations).
#' @param ctmod The attribute \code{ctmod} from a \code{aa_masses} (for MS1
#'   calculations).
#' @param aas \code{aa_seq} split in a sequence of LETTERS.
#' @param .ms1_vmodsets Not used.
#' @param .base_ent Not used.
#' @inheritParams matchMS
#' @inheritParams add_var_masses
#' @import purrr
#' @return Lists by residues in \code{amods}.
#' @seealso \link{ms1_a1_vnl0_fnl0} for examples.
#'
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' ## M
#' fixedmods <- c("TMT6plex (K)", "dHex (S)")
#' varmods <- c("Carbamidomethyl (M)", "Carbamyl (M)", "Acetyl (Protein N-term)")
#'
#' aa_masses_all <- calc_aamasses(fixedmods, varmods)
#'
#' aa_masses <- aa_masses_all[[8]]
#'
#' amods <- list(`Carbamidomethyl (M)` = c(Anywhere = "M"),
#'               `Carbamyl (M)` = c(Anywhere = "M"))
#'
#' aas <- unlist(strsplit("HQGVMNVGMGQKMNS", ""))
#'
#' ans <- mzion:::unique_mvmods(amods = amods, ntmod = NULL, ctmod = NULL,
#'                      aa_masses = aa_masses, aas = aas)
#'
#' stopifnot(length(ans) == 1L,
#'           length(ans[[1]]) == 3L)
#'
#' ## M and N
#' fixedmods <- c("TMT6plex (K)", "dHex (S)")
#' varmods <- c("Carbamidomethyl (M)", "Carbamyl (M)",
#'              "Deamidated (N)", "Acetyl (Protein N-term)")
#'
#' aa_masses_all <- calc_aamasses(fixedmods, varmods)
#'
#' aa_masses <- aa_masses_all[[16]]
#'
#' amods <- list(`Carbamidomethyl (M)` = c(Anywhere = "M"),
#'               `Carbamyl (M)` = c(Anywhere = "M"),
#'               `Deamidated (N)` = c(Anywhere = "N"))
#'
#' aas <- unlist(strsplit("HQGVMNVGMGQKMNS", ""))
#'
#' ans <- mzion:::unique_mvmods(amods = amods, ntmod = NULL, ctmod = NULL,
#'                      aa_masses = aa_masses, aas = aas)
#'
#' stopifnot(length(ans) == 2L,
#'           length(ans[[1]]) == 3L,
#'           length(ans[[2]]) == 2L)
#' }
unique_mvmods <- function (amods, ntmod, ctmod, aa_masses, aas,
                           maxn_vmods_per_pep = 5L,
                           maxn_sites_per_vmod = 3L,
                           .ms1_vmodsets = NULL, 
                           .base_ent = NULL) 
{
  # (6) "amods- tmod- vnl- fnl+"
  if (!length(amods)) 
    return(NULL)
  
  residue_mods <- .Internal(unlist(amods, recursive = FALSE, use.names = FALSE))
  names(residue_mods) <- names(amods)
  residue_mods <- split_vec(residue_mods)
  
  lapply(residue_mods, function (x) {
    vmods_elements(aas = aas, residue_mods = x, 
                   ntmod = ntmod, ctmod = ctmod,
                   maxn_vmods_per_pep = maxn_vmods_per_pep,
                   maxn_sites_per_vmod = maxn_sites_per_vmod,
                   .ms1_vmodsets = .ms1_vmodsets, 
                   .base_ent = .base_ent)
  })
}


#' Find the sets of variable modifications.
#'
#' The same residue, e.g. M, at different modifications, c("Carbamyl (M",
#' "Oxidation (M)")). 
#' 
#' Excluding position differences, i.e., \code{A, B} and \code{B, A} is the
#' same set.
#'
#' @param residue_mods Amino-acid residues with Unimod names. For example
#'   rownames of \code{Carbamidomethyl (M)} and \code{Oxidation (M)} and a
#'   column residues of \code{M, M}.
#' @inheritParams unique_mvmods
#' @import purrr
#' @examples 
#' \donttest{
#' library(mzion)
#' 
#' ntmod <- list(`Acetyl (Protein N-term)` = c(`Protein N-term` = "N-term"))
#' 
#' ctmod <- list()
#' names(ctmod) <- character()
#' 
#' aas <- unlist(strsplit("HQGVMNVGMGQKSMNS", ""))
#' residue_mods <- c(`Carbamidomethyl (M)` = "M", `Carbamyl (M)` = "M")
#' 
#' x <- mzion:::vmods_elements(aas, residue_mods, ntmod, ctmod)
#' }
vmods_elements <- function (aas,
                            residue_mods,
                            ntmod,
                            ctmod,
                            maxn_vmods_per_pep = 5L,
                            maxn_sites_per_vmod = 3L,
                            .ms1_vmodsets = NULL, 
                            .base_ent = NULL) 
{
  residue <- residue_mods[[1]]
  
  ns <- names(residue_mods)
  len_n <- length(ns)
  
  # the exact positions not needed
  len_p <- sum(aas == residue)
  
  # i.e., btw Anywhere "M" and "Acetyl N-term" where "M" on the "N-term"
  # MFGMFNVSMR cannot have three `Oxidation (M)` and `Acetyl (N-term)`
  
  len_nt <- length(ntmod)
  len_ct <- length(ctmod)
  
  if (len_nt && len_ct) {
    len_aas <- length(aas)
    aas_1 <- aas[1]
    aas_n <- aas[len_aas]
    if (aas_1 == residue && aas_n == residue) {
      len_p <- len_p - 2
    } else if ((aas_1 == residue) || (aas_n == residue)) {
      len_p <- len_p - 1
    }
  } else if (len_nt) {
    aas_1 <- aas[1]
    if (aas_1 == residue) {
      len_p <- len_p - 1
    }
  } else if (len_ct) {
    aas_n <- aas[len_aas]
    if (aas_n == residue) {
      len_p <- len_p - 1
    }
  }
  
  if (len_p <= 0) 
    return(list())
  
  len_p <- min(len_p, maxn_vmods_per_pep)
  
  if (is.null(.ms1_vmodsets) || is.null(.base_ent)) {
    if (len_p > len_n) {
      x <- lapply((len_n + 1):len_p, function (x) find_unique_sets(x, ns))
      x <- .Internal(unlist(x, recursive = FALSE, use.names = FALSE))
      x <- c(list(ns), x)
    } else {
      x <- list(ns)
    }
    
    maxn_vmod <- lapply(x, count_elements)
    maxn_vmod <- lapply(maxn_vmod, max)
    rows <- (maxn_vmod <= maxn_sites_per_vmod)
    
    x <- x[rows]
  } else {
    # x <- extract_vmodsets(.ms1_vmodsets, .base_ent, len_p, ns)
  }
  
  invisible(x)
}


#' Finds the combinations across residues.
#'
#' For uses with MS1 precursors. For multiple residues (each residue one to
#' multiple modifications).
#'
#' @param intra_combis The results from \link{unique_mvmods}.
#' @inheritParams matchMS
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' C <- list(c("Carbamidomethyl (C)"),
#'           rep("Carbamidomethyl (C)", 2))
#'
#' N <- list(c("Deamidated (N)"),
#'           rep("Deamidated (N)", 2))
#'
#' intra_combis <- list(C = C, N = N)
#'
#' ans <- mzion:::find_intercombi(intra_combis)
#' 
#' # three large lists
#' S <- list(c("Carbamidomethyl (S)", "Phospho (S)", "Phospho (S)"),
#'            c("Carbamidomethyl (S)", "Phospho (S)", "Phospho (S)", "Phospho (S)"))
#' 
#' M <- list(c("Oxidation (M)", "Carbamidomethyl (M)"), 
#'           c("Oxidation (M)", "Carbamidomethyl (M)", "Carbamyl (M)"))
#' 
#' N <- list(c("Deamidated (N)"),
#'           rep("Deamidated (N)", 2))
#' 
#' ans <- mzion:::find_intercombi(list(S = S, M = M, N = N))
#' }
find_intercombi <- function (intra_combis, maxn_vmods_per_pep = 5L) 
{
  len <- length(intra_combis)
  
  if (!len) { # scalar
    v_out <- list()
  } else if (any(.Internal(unlist(lapply(intra_combis, purrr::is_empty), 
                                  recursive = FALSE, use.names = FALSE)))) { # list
    v_out <- list()
  } else if (len > 1L) {
    v_out <- expand_grid_rows0(intra_combis, use.names = FALSE)
    
    lens <- lapply(v_out, length)
    lens <- .Internal(unlist(lens, recursive = FALSE, use.names = FALSE))
    oks <- (lens <= maxn_vmods_per_pep)
    v_out <- v_out[oks]
    
    ## DONT: 
    ## each aa_masses is a realization of a set of combinatorial amods;
    ## if length > maxn_vmods_per_pep, the combination should be dropped;
    ## duplicated entries if subset by 1:min(length(x), maxn_vmods_per_pep)
    
    # v_out <- lapply(v_out, function (x) x[1:min(length(x), maxn_vmods_per_pep)])
  } else {
    v_out <- flatten_list(intra_combis)
  }
  
  invisible(v_out)
}

#' Matches to the pre-calculated labels of combinatorial MS1 variable
#' modifications.
#'
#' No checking of conflicting [NC]-term and Anywhere sites. Even so, it only
#' sets a overall limit on the counts. Still need to check the MS2 permutation
#' with indexes in aas for exact exclusion of certain permutations.
#'
#' @param aas \code{aa_seq} split in a sequence of LETTERS.
#' @param ms1vmods The i-th result from lapply(aa_masses_all, make_ms1vmod_i).
#' @param amods \code{Anywhere} variable modifications.
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' fixedmods <- c("TMT6plex (N-term)", "TMT6plex (K)",
#'                "Carbamidomethyl (C)")
#'
#' varmods <- c("Acetyl (Protein N-term)", "Oxidation (M)",
#'              "Deamidated (N)",
#'              "Gln->pyro-Glu (N-term = Q)")
#'
#' aa_masses_all <- calc_aamasses(fixedmods = fixedmods,
#'                                varmods = varmods,
#'                                maxn_vmods_setscombi = 64,
#'                                out_path = NULL)
#'
#' maxn_vmods_per_pep <- 5L
#' maxn_sites_per_vmod <- 3L
#'
#' ms1vmods_all <- lapply(aa_masses_all, mzion:::make_ms1vmod_i,
#'                        maxn_vmods_per_pep = maxn_vmods_per_pep,
#'                        maxn_sites_per_vmod = maxn_sites_per_vmod)
#'
#' i <- 11L
#' aa_masses <- aa_masses_all[[i]]
#' amods <- attr(aa_masses, "amods")
#' ms1vmods <- ms1vmods_all[[i]]
#'
#' aas <- unlist(strsplit("HQGVMNVGMGQKMNS", ""))
#'
#' vmods_combi <- mzion:::match_mvmods(aas = aas, ms1vmods = ms1vmods, amods = amods)
#'
#' ## M and N
#' fixedmods = c("TMT6plex (K)", "dHex (S)")
#' varmods = c("Carbamidomethyl (M)", "Carbamyl (M)",
#'             "Deamidated (N)", "Acetyl (Protein N-term)")
#'
#' aa_masses_all <- calc_aamasses(fixedmods, varmods)
#'
#' maxn_vmods_per_pep <- 5L
#' maxn_sites_per_vmod <- 3L
#'
#' ms1vmods_all <- lapply(aa_masses_all, mzion:::make_ms1vmod_i,
#'                        maxn_vmods_per_pep = maxn_vmods_per_pep,
#'                        maxn_sites_per_vmod = maxn_sites_per_vmod)
#'
#' i <- 16L
#' aa_masses <- aa_masses_all[[i]]
#' amods <- attr(aa_masses, "amods")
#' ntmod <- attr(aa_masses, "ntmod")
#' ctmod <- attr(aa_masses, "ctmod")
#'
#' ms1vmods <- ms1vmods_all[[i]]
#'
#' aas <- unlist(strsplit("HQGVMNVGMGQKMNS", ""))
#'
#' vmods_combi <- mzion:::match_mvmods(aas = aas, ms1vmods = ms1vmods, amods = amods)
#'
#' stopifnot(sapply(vmods_combi$ms1, function (x) all(names(amods) %in% x)),
#'           length(vmods_combi$ms1) == 6L)
#'
#' }
match_mvmods <- function (aas = NULL, ms1vmods = NULL, amods = NULL) 
{
  resids <- amods[!duplicated.default(amods)]
  len_r  <- length(resids)
  max_rs <- vector("integer", len_r)
  
  for (i in seq_len(len_r)) 
    max_rs[i] <- sum(aas == resids[[i]])
  
  ## `make_ms1_vmodsets` is obtained from the same `amods`
  ##   -> no mess up in the order of `amods` -> no name sorting
  
  len  <- length(ms1vmods)
  rows <- vector("logical", len)
  
  for (i in seq_len(len)) {
    ps <- attr(ms1vmods[[i]], "ps")
    rows[i] <- all(ps <= max_rs)
  }
  
  rows <- .Internal(which(rows))
  
  list(ms1 = ms1vmods[rows], inds = rows)
}


#' Makes the sets of MS1 labels for a given \code{aa_masses}.
#'
#' For \code{Anywhere} variable modifications (\code{amods}) across all
#' residues.
#'
#' For the universe of labels, loops through \code{aa_masses_all}.
#'
#' By the design of \code{aa_masses}, the \code{amods} in a \code{aa_masses} are
#' all realized. Therefore, each list in the resulted labels should contain at
#' least one of the \code{amods} residues from the \code{aa_masses}. For
#' example, if \code{amods} contain M, N and S, each list in the result should
#' contains at least one of the residues.
#'
#' Currently, variable terminal modifications are exempted from the restriction
#' by \code{maxn_vmods_per_pep}. If taken into account (e.g. variable N-term),
#' the combination of \code{Anywhere} can be further reduced.
#'
#' @param aa_masses A named list containing the (mono-isotopic) masses of amino
#'   acid residues.
#' @inheritParams matchMS
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' ## Simple
#' fixedmods <- c("TMT6plex (N-term)", "TMT6plex (K)",
#'                "Carbamidomethyl (C)")
#'
#' varmods = c("Acetyl (Protein N-term)", "Oxidation (M)",
#'             "Deamidated (N)",
#'             "Gln->pyro-Glu (N-term = Q)")
#'
#' aa_masses_all <- calc_aamasses(fixedmods = fixedmods,
#'                                varmods = varmods,
#'                                maxn_vmods_setscombi = 64,
#'                                out_path = NULL)
#'
#' maxn_vmods_per_pep <- 5L
#' maxn_sites_per_vmod <- 3L
#'
#' ms1vmods_all <- lapply(aa_masses_all, mzion:::make_ms1vmod_i,
#'                        maxn_vmods_per_pep = maxn_vmods_per_pep,
#'                        maxn_sites_per_vmod = maxn_sites_per_vmod)
#'
#' stopifnot(length(ms1vmods_all[[1]]) == 0L,
#'           length(ms1vmods_all[[2]]) == 0L,
#'           length(ms1vmods_all[[3]]) == 0L)
#'
#' # (M, N)
#' len_ps <- lapply(ms1vmods_all[[12]], function (x) attr(x, "ps"))
#'
#' # (M)
#' len_ps <- lapply(ms1vmods_all[[4]], function (x) attr(x, "ps"))
#'
#' ## More complex
#' fixedmods <- c("TMT6plex (N-term)", "TMT6plex (K)")
#'
#' varmods <- c("Acetyl (Protein N-term)", "Deamidated (N)",
#'              "Oxidation (M)", "Carbamidomethyl (M)", "Carbamyl (M)",
#'              "Carbamidomethyl (S)", "Phospho (S)")
#'
#' aa_masses_all <- calc_aamasses(fixedmods = fixedmods,
#'                                varmods = varmods,
#'                                maxn_vmods_setscombi = 64,
#'                                out_path = NULL)
#'
#' maxn_vmods_per_pep <- 5L
#' maxn_sites_per_vmod <- 3L
#'
#' ms1vmods_all <- lapply(aa_masses_all, mzion:::make_ms1vmod_i,
#'                        maxn_vmods_per_pep = maxn_vmods_per_pep,
#'                        maxn_sites_per_vmod = maxn_sites_per_vmod)
#'
#' # No duplication within each aa_masses
#' any_dups <- lapply(ms1vmods_all, function (x) anyDuplicated(x))
#'
#' stopifnot(all(unlist(any_dups) == 0L))
#'
#' # Can have identical sets of labels at different aa_masses
#' identical(ms1vmods_all[[3]], ms1vmods_all[[9]])
#'
#' attr(aa_masses_all[[3]], "tmod")
#' attr(aa_masses_all[[9]], "tmod")
#'
#' ms1vmods <- ms1vmods_all[[64]]
#' n <- length(ms1vmods[[1]])
#'
#'
#' ## "Oxidation (M)" on the N-term
#' fixedmods <- c("TMT6plex (N-term)", "TMT6plex (K)", "Carbamidomethyl (C)")
#'
#' varmods = c("Acetyl (Protein N-term)", "Oxidation (M)", "Deamidated (N)",
#'             "Gln->pyro-Glu (N-term = Q)")
#'
#' aa_masses_all <- calc_aamasses(fixedmods = fixedmods,
#'                                varmods = varmods,
#'                                maxn_vmods_setscombi = 64,
#'                                out_path = NULL)
#'
#' maxn_vmods_per_pep <- 5L
#' maxn_sites_per_vmod <- 3L
#'
#' ms1vmods_all <- lapply(aa_masses_all, mzion:::make_ms1vmod_i,
#'                        maxn_vmods_per_pep = maxn_vmods_per_pep,
#'                        maxn_sites_per_vmod = maxn_sites_per_vmod)
#' ms2vmods_all <- lapply(ms1vmods_all, function (x) lapply(x, mzion:::make_ms2vmods))
#'
#' i <- 6L
#' aa_masses <- aa_masses_all[[i]]
#' amods <- attr(aa_masses, "amods")
#'
#' ms1vmods <- ms1vmods_all[[i]]
#' ms2vmods <- ms2vmods_all[[i]]
#'
#' aas <- unlist(strsplit("MHQGVMNVGMGQKNS", ""))
#'
#' # Subset from ms1vmods by aas
#' oks <- mzion:::match_mvmods(aas = aas, ms1vmods = ms1vmods, amods = amods)$inds
#' ms2vmods <- ms2vmods[oks]
#' }
make_ms1vmod_i <- function (aa_masses = NULL, maxn_vmods_per_pep = 5L, 
                            maxn_sites_per_vmod = 3L) 
{
  # stopifnot(maxn_vmods_per_pep >= 2L)
  
  vmodsets <- make_ms1_vmodsets(aa_masses_all = list(aa_masses), 
                                maxn_vmods_per_pep = maxn_vmods_per_pep, 
                                maxn_sites_per_vmod = maxn_sites_per_vmod)
  
  find_intercombi2(vmodsets = vmodsets, maxn_vmods_per_pep = maxn_vmods_per_pep)
}


#' Makes the sets of labels of variable modifications.
#' 
#' No position permutation (for MS1 masses).
#' 
#' @param aa_masses_all All of the amino acid lookup tables.
#' @inheritParams matchMS
make_ms1_vmodsets <- function (aa_masses_all = NULL, maxn_vmods_per_pep = 5L, 
                               maxn_sites_per_vmod = 3L) 
{
  if (!is.list(aa_masses_all)) 
    aa_masses_all <- list(aa_masses_all)
  
  amods_all <- lapply(aa_masses_all, attr, "amods", exact = TRUE)
  
  len <- length(amods_all)
  resmods_all <- vector("list", len)
  
  for (i in seq_len(len)) {
    aa_masses <- aa_masses_all[[i]]
    amods <- attr(aa_masses, "amods", exact = TRUE)
    
    # split into lists by individual residues
    if (length(amods)) {
      x <- .Internal(unlist(amods, recursive = FALSE, use.names = FALSE))
      names(x) <- names(amods)
      resmods_all[[i]] <- split_vec(x)
    } 
    else
      resmods_all[[i]] <- NULL
  }
  
  # unique sets of modifications by individual residues
  resmods_all <- unlist(resmods_all, recursive = FALSE, use.names = FALSE)
  resmods_all <- unique(resmods_all)
  
  out <- lapply(resmods_all, bacth_vmods_combi, 
                maxn_vmods_per_pep = maxn_vmods_per_pep, 
                maxn_sites_per_vmod = maxn_sites_per_vmod)
  
  resids <- lapply(resmods_all, `[`, 1)
  resids <- unlist(resids, recursive = FALSE, use.names = FALSE)
  names(out) <- resids
  
  invisible(out)
}


#' Helper in cycling through \code{2:maxn_vmods_per_pep} numbers of positions.
#'
#' For the same residue (M) at different names of modifications.
#'
#' @param resmods A vector of amino-acid residues with Unimod in names. For
#'   example, c(`Oxidation (M)` = "M", `Carbamyl` = "M").The residues are the
#'   same and the names (modifications) are different.
#' @inheritParams matchMS
#' @examples 
#' \donttest{
#' library(mzion)
#' resmods <- c(`Oxidation (M)` = "M", `Carbamidomethyl (M)` = "M")
#' ans <- mzion:::bacth_vmods_combi(resmods)
#' }
bacth_vmods_combi <- function (resmods = NULL, maxn_vmods_per_pep = 5L, 
                               maxn_sites_per_vmod = 3L) 
{
  resid <- unname(resmods[[1]])

  ans <- make_unique_sets(p = maxn_vmods_per_pep, 
                          n = length(resmods), 
                          labs = names(resmods), 
                          maxn_vmods_per_pep = maxn_vmods_per_pep, 
                          maxn_sites_per_vmod = maxn_sites_per_vmod)
  
  lapply(ans, function (x) {
    names(x) <- rep(resid, length(x))
    x
  })
}


#' Makes the unique sets of modifications by individual AA residues. 
#' 
#' @param p The number of open positions for filling.
#' @param n The number of labels.
#' @param labs The labels of balls.
#' @inheritParams matchMS
#' @examples 
#' \donttest{
#' library(mzion)
#' 
#' # multiple outs
#' p <- 5
#' labs <- c("Oxidation (M)", "Carbamidomethyl (M)", "Carbamyl (M)")
#' n <- length(labs)
#' stopifnot(n == length(labs))
#' 
#' ans5 <- mzion:::make_unique_sets(5, n, labs)
#' ans7 <- mzion:::make_unique_sets(7, n, labs)
#' 
#' stopifnot(identical(ans5, ans7))
#' 
#' # single out
#' p <- 3
#' labs <- c("Oxidation (M)", "Carbamidomethyl (M)", "Carbamyl (M)")
#' n <- length(labs)
#' stopifnot(n == length(labs))
#' 
#' ans <- mzion:::make_unique_sets(p, n, labs)
#' }
make_unique_sets <- function (p = 5L, n = 2L, labs = c("X", "Y"), 
                              maxn_vmods_per_pep = 5L, 
                              maxn_sites_per_vmod = 3L) 
{
  # stopifnot(n == length(labs))
  
  if (p < n) 
    return(NULL)
  
  p <- min(p, maxn_vmods_per_pep)
  ps <- n:p
  
  combs <- lapply(ps, function (i) {
    ans <- find_unique_sets(i, labs)
    
    n_vmod <- lapply(ans, count_elements)
    maxn_vmod <- lapply(n_vmod, max)
    rows <- (maxn_vmod <= maxn_sites_per_vmod)
    
    ans <- ans[rows]
  })
  
  lens  <- lapply(combs, length)
  lens  <- .Internal(unlist(lens, recursive = FALSE, use.names = FALSE))
  nms_p <- rep(ps, lens)
  # nms_n <- rep(n, length(nms_p))
  
  combs <- .Internal(unlist(combs, recursive = FALSE, use.names = FALSE))
  names(combs) <- nms_p
  
  invisible(combs)
}


#' Finds the sets of unique labels for \code{n} balls in \code{p-positions}.
#'
#' At least one occupancy for each balls in \code{ns}.
#'
#' @param p The number of positions.
#' @param labs The names to be filled into the \code{p}-number of positions.
#' @examples 
#' \donttest{
#' library(mzion)
#' mzion:::find_unique_sets(5, c("Oxidation (M)", 
#'                            "Carbamidomethyl (M)", 
#'                            "Carbamyl (M)"))
#' }
find_unique_sets <- function (p = 5L, labs = c("A", "B", "C")) 
{
  ps <- seq_len(p)
  n  <- length(labs)
  r  <- p - n
  
  if (r == 0L) 
    return(list(labs))
  
  if (r < 0L) 
    return(NULL)
  
  x <- gtools_combn(n, r, labs, repeats.allowed = TRUE)
  
  n_row <- nrow(x)
  out <- vector("list", n_row)
  
  for (i in seq_len(n_row)) 
    out[[i]] <- c(labs, x[i, ])
  
  out
}


#' Finds combination.
#' 
#' From gtools::combinations
#'
#' @param n The number of balls.
#' @param r The number of slots.
#' @param v The labels of the n balls.
#' @param set Logical; duplicates should be removed from the source vector v or
#'   not.
#' @param repeats.allowed Logical; vector v may include duplicated values or
#'   not.
gtools_combn <- function (n, r, v = 1:n, set = TRUE, repeats.allowed = FALSE) 
{
  if (set) 
    v <- unique(sort(v))

  v0 <- vector(mode(v), 0)
  
  if (repeats.allowed) 
    sub <- function(n, r, v) {
      if (r == 0) 
        v0
      else if (r == 1) 
        matrix(v, n, 1)
      else if (n == 1) 
        matrix(v, 1, r)
      else rbind(cbind(v[1], Recall(n, r - 1, v)), Recall(n - 1, r, v[-1]))
    }
  else sub <- function(n, r, v) {
    if (r == 0) 
      v0
    else if (r == 1) 
      matrix(v, n, 1)
    else if (r == n) 
      matrix(v, 1, n)
    else rbind(cbind(v[1], Recall(n - 1, r - 1, v[-1])), Recall(n - 1, r, v[-1]))
  }
  
  sub(n, r, v[1:n])
}


#' Finds the combinations across residues (with attributes).
#'
#' Used after \link{make_ms1_vmodsets} across residues.
#'
#' @param vmodsets The results from \link{make_ms1_vmodsets}.
#' @inheritParams matchMS
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' ## Simple
#' fixedmods <- c("TMT6plex (N-term)", "TMT6plex (K)")
#'
#' varmods <- c("Acetyl (Protein N-term)",
#'              "Oxidation (M)", "Deamidated (N)", 
#'              "Gln->pyro-Glu (N-term = Q)")
#' 
#' aa_masses_all <- calc_aamasses(fixedmods = fixedmods,
#'                                varmods = varmods,
#'                                maxn_vmods_setscombi = 64,
#'                                out_path = NULL)
#' 
#' maxn_vmods_per_pep <- 5L
#' maxn_sites_per_vmod <- 3L
#' 
#' # M and N
#' i <- 10L
#' aa_masses <- aa_masses_all[[i]]
#'
#' vmodsets <- mzion:::make_ms1_vmodsets(aa_masses_all = aa_masses,
#'                               maxn_vmods_per_pep = maxn_vmods_per_pep,
#'                               maxn_sites_per_vmod = maxn_sites_per_vmod)
#'
#' ms1vmods <- mzion:::find_intercombi2(vmodsets)
#' 
#' ## More complex
#' fixedmods <- c("TMT6plex (N-term)", "TMT6plex (K)")
#'
#' varmods <- c("Acetyl (Protein N-term)",
#'              "Oxidation (M)", "Carbamidomethyl (M)",
#'              "Deamidated (N)", "Carbamyl (M)",
#'              "Gln->pyro-Glu (N-term = Q)")
#'
#' aa_masses_all <- calc_aamasses(fixedmods = fixedmods,
#'                                varmods = varmods,
#'                                maxn_vmods_setscombi = 64,
#'                                out_path = NULL)
#' 
#' maxn_vmods_per_pep <- 5L
#' maxn_sites_per_vmod <- 3L
#' 
#' # Only `Oxidation (M)` 
#' i <- 8L
#' aa_masses <- aa_masses_all[[i]]
#'
#' vmodsets <- mzion:::make_ms1_vmodsets(aa_masses_all = aa_masses,
#'                               maxn_vmods_per_pep = maxn_vmods_per_pep,
#'                               maxn_sites_per_vmod = maxn_sites_per_vmod)
#'
#' ms1vmods <- mzion:::find_intercombi2(vmodsets)
#' 
#' ## `Oxidation (M)`, "Carbamidomethyl (M)"
#' fixedmods <- c("TMT6plex (N-term)", "TMT6plex (K)")
#'
#' varmods <- c("Acetyl (Protein N-term)",
#'              "Oxidation (M)", "Carbamidomethyl (M)",
#'              "Deamidated (N)")
#'
#' aa_masses_all <- calc_aamasses(fixedmods = fixedmods,
#'                                varmods = varmods,
#'                                maxn_vmods_setscombi = 64,
#'                                out_path = NULL)
#' 
#' maxn_vmods_per_pep <- 5L
#' maxn_sites_per_vmod <- 3L
#' 
#' i <- 16L
#' aa_masses <- aa_masses_all[[i]]
#'
#' vmodsets <- mzion:::make_ms1_vmodsets(aa_masses_all = aa_masses,
#'                               maxn_vmods_per_pep = maxn_vmods_per_pep,
#'                               maxn_sites_per_vmod = maxn_sites_per_vmod)
#'
#' ms1vmods <- mzion:::find_intercombi2(vmodsets)
#' }
find_intercombi2 <- function (vmodsets = NULL, maxn_vmods_per_pep = 5L) 
{
  len <- length(vmodsets)
  
  # scalar
  if (!len) 
    return(list())
  
  # return "empty" if any is "empty"
  if (any(.Internal(unlist(lapply(vmodsets, purrr::is_empty), 
                           recursive = FALSE, use.names = FALSE)))) 
    return(list())
  
  # all lists are non-empty
  # vmod_nms <- lapply(vmodsets, function (x) lapply(x, names))
  # len_ps   <- lapply(vmodsets, function (x) lapply(x, length))
  vmod_nms <- lapply(vmodsets, lapply, names)
  len_ps   <- lapply(vmodsets, lapply, length)
  
  v_out  <- expand_grid_rows0(vmodsets, use.names = FALSE)
  nm_out <- expand_grid_rows0(vmod_nms, use.names = FALSE)

  v_out <- mapply(function (x, y) {
    names(x) <- y
    x
  }, v_out, nm_out, 
  SIMPLIFY = FALSE, USE.NAMES = FALSE)

  ps <- expand_grid_rows0(len_ps, use.names = TRUE)
  
  ## Characteristics of expand grids: 
  # (residues will be in sections, e.g. M, M, M, N)
  #  M                      M                  M                   N       
  # "Carbamidomethyl (M)", "Carbamyl (M)", "Carbamidomethyl (M)", "Deamidated (N)"
  # 
  # The same order for ps (M > N)
  # M N 
  # 3 1
  # 
  # Therefore can safely tell from ps that the first three are M(s)

  lens <- lapply(v_out, length)
  lens <- .Internal(unlist(lens, recursive = FALSE, use.names = FALSE))
  oks  <- (lens <= maxn_vmods_per_pep)
  
  v_out <- v_out[oks]
  ps <- ps[oks]
  labs <- lapply(v_out, count_elements)
  
  mapply(function (x, y, z) {
    attr(x, "ps") <- y
    attr(x, "labs") <- z
    x
  }, v_out, ps, labs, 
  SIMPLIFY = FALSE, USE.NAMES = FALSE)
}


#' Combinatorial vmods (permutation of positions but not labels).
#'
#' One-to-one correspondence between Names and Sites. Finds the positions of
#' residues (sites) from a given amino acid sequence (aas).
#'
#' @param M A vector of modifications. 
#' @param nmax The maximum number of combinations being allowed.
#' @param aas \code{aa_seq} split in a sequence of LETTERS.
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' aa_seq <- "MHQGVMNVNMGQKMNS"
#' aas <- .Internal(strsplit(aa_seq, "", fixed = TRUE, perl = FALSE, useBytes = FALSE))
#' aas <- .Internal(unlist(aas, recursive = FALSE, use.names = FALSE))
#' ms <- c("M", "M", "N", "N")
#' labs <- ps <- c(2, 2)
#' names(ps) <- c("M", "N")
#' names(labs) <- c("Oxidation (M)", "Deamidated (N)")
#' M <- c("Oxidation (M)", "Oxidation (M)", "Deamidated (N)", "Deamidated (N)")
#' attr(M, "ps") <- ps
#' attr(M, "resids") <- ms
#' 
#' mzion:::find_vmodposU(M, aas)
#' mzion:::find_vmodposU(M, aas, nmax = 1L)
#' 
#' # one residue
#' aa_seq <- "MHQGVMNVNMGQKMSS"
#' aas <- .Internal(strsplit(aa_seq, "", fixed = TRUE, perl = FALSE, useBytes = FALSE))
#' aas <- .Internal(unlist(aas, recursive = FALSE, use.names = FALSE))
#' ms <- c("N")
#' labs <- ps <- c(1)
#' names(ps) <- c("N")
#' names(labs) <- c("Deamidated (N)")
#' M <- c("Deamidated (N)")
#' attr(M, "ps") <- ps
#' attr(M, "resids") <- ms
#' 
#' mzion:::find_vmodposU(M, aas)
#' mzion:::find_vmodposU(M, aas, nmax = 1L)
#' }
find_vmodposU <- function (M, aas, nmax = 64L) 
{
  rs <- attr(M, "resids", exact = TRUE)
  nr <- length(rs)
  ps <- attr(M, "ps", exact = TRUE)
  ss <- names(ps)

  if (nmax == 1L) {
    ns <- length(ss)
    P  <- character(nr)
    ends <- cumsum(ps)
    r1 <- 1L

    for (i in 1:ns) {
      si <- ss[[i]]
      pi <- ps[[i]]
      ei <- ends[[i]]
      P[r1:ei] <- .Internal(which(aas == si))[1:pi]
      r1 <- pi + 1L
    }
    
    # one-row matrix
    P <- .Internal(matrix(P, nrow = 1L, ncol = 1L, byrow = FALSE, 
                              dimnames = NULL, FALSE, TRUE))
    # remove attributes
    attr(P, "mods") <- M[1:nr]
    return(P)
  }
  
  if (nr == 1L) {
    P <- .Internal(which(aas == ss))
    P <- .Internal(matrix(P, nrow = 1L, ncol = 1L, byrow = FALSE, 
                          dimnames = NULL, TRUE, FALSE))
    attr(P, "mods") <- M[1:nr]
    return(P)
  }
  
  ns <- length(ss)
  X  <- vector("list", ns)
  
  for (i in 1:ns) {
    si <- .Internal(which(aas == names(ps)[i]))
    ni <- ps[[i]]
    
    X[[i]] <- if (ni == 1L) 
      matrix(si) 
    else 
      arrangements::combinations(si, ni, nitem = nmax, layout = "row")
  }
  
  P <- expand_gr(X, nmax = nmax)
  
  attr(P, "mods") <- M[1:nr]
  
  P
}


#' Combinatorial vmods (permutation of both positions and labels).
#'
#' Multiple Names to the same Site.
#' 
#' @param M A vector of names (lower-case vec for sites).
#' @param nmax The maximum number of combinations.
#' @inheritParams find_vmodposU
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' Vec <- c("Carbamidomethyl (M)", "Carbamyl (M)")
#' vec <- c("M", "M")
#' aas <- unlist(strsplit("HQGVMNVGMGQKMNS", ""))
#' ps <- c(2)
#' names(ps) <- c("M")
#' attr(Vec, "ps") <- ps
#' attr(Vec, "resids") <- vec
#' rs <- unique(vec)
#' inds <- lapply(rs, function (x) which(vec == x))
#' attr(Vec, "inds") <- inds
#' mzion:::find_vmodposM(Vec, aas)
#' mzion:::find_vmodposM(Vec, aas, nmax = 1L)
#' 
#' Vec <- c("Carbamidomethyl (M)", "Deamidated (N)", "Carbamyl (M)")
#' vec <- c("M", "N", "M")
#' aas <- unlist(strsplit("HQGVMNVGMGQKMNS", ""))
#' ps <- c(2, 1)
#' names(ps) <- c("M", "N")
#' attr(Vec, "ps") <- ps
#' attr(Vec, "resids") <- vec
#' rs <- unique(vec)
#' inds <- lapply(rs, function (x) which(vec == x))
#' attr(Vec, "inds") <- inds
#' mzion:::find_vmodposM(Vec, aas)
#' mzion:::find_vmodposM(Vec, aas, nmax = 1L)
#' 
#' Vec <- c("Carbamidomethyl (M)", "Carbamidomethyl (M)", "Carbamyl (M)", "Deamidated (N)")
#' vec <- c("M", "M", "M", "N")
#' aas <- unlist(strsplit("HQGVMNVGMGQKMNS", ""))
#' ps <- c(3, 1)
#' names(ps) <- c("M", "N")
#' attr(Vec, "ps") <- ps
#' attr(Vec, "resids") <- vec
#' rs <- unique(vec)
#' inds <- lapply(rs, function (x) which(vec == x))
#' attr(Vec, "inds") <- inds
#' mzion:::find_vmodposM(Vec, aas)
#' mzion:::find_vmodposM(Vec, aas, nmax = 1L)
#' 
#' Vec <- c("Carbamidomethyl (M)", "Carbamidomethyl (M)", "Carbamyl (M)", "Deamidated (N)", 
#'          "Carbamidomethyl (S)", "Phospho (S)")
#' vec <- c("M", "M", "M", "N", "S", "S")
#' aas <- unlist(strsplit("HQGVMNVGMGQKMNSSS", ""))
#' ps <- c(3, 1, 2)
#' names(ps) <- c("M", "N", "S")
#' attr(Vec, "ps") <- ps
#' attr(Vec, "resids") <- vec
#' rs <- unique(vec)
#' inds <- lapply(rs, function (x) which(vec == x))
#' attr(Vec, "inds") <- inds
#' mzion:::find_vmodposM(Vec, aas)
#' mzion:::find_vmodposM(Vec, aas, nmax = 1L)
#' mzion:::find_vmodposM(Vec, aas, nmax = 16L)
#' mzion:::find_vmodposM(Vec, aas, nmax = 8L)
#' lapply(1:32, function (x) mzion:::find_vmodposM(Vec, aas, nmax = x))
#' }
find_vmodposM <- function (M, aas, nmax = 64L) 
{
  rs <- attr(M, "resids", exact = TRUE)
  ps <- attr(M, "ps", exact = TRUE)
  ds <- attr(M, "inds", exact = TRUE)
  np <- length(ps)
  A <- P <- vector("list", np)
  nmax2 <- nmax

  for (i in 1:np) {
    ri <- names(ps)[i]
    si <- .Internal(which(aas == ri))
    ni <- ps[[i]]

    nP <- nrow(P[[i]] <- arrangements::combinations(si, ni, nitem = nmax, layout = "row"))
    nmax2 <- nmax2 %/% nP
    
    if (nmax2 <= 1L) {
      A[[i]] <- .Internal(matrix(M[ds[[i]]], nrow = 1L, ncol = 1L, byrow = FALSE, 
                                 dimnames = NULL, FALSE, TRUE))
      A <- A[1:i]
      P <- P[1:i]
      # np <- i
      break
    }
    else {
      Mi <- M[ds[[i]]]
      
      nA <- if (length(Mi) == 1L) # Deamidated (N)
        nrow(A[[i]] <- .Internal(matrix(Mi, nrow = 1L, ncol = 1L, byrow = FALSE, 
                                              dimnames = NULL, TRUE, FALSE)))
      else # Carbamidomethyl (M), Carbamyl (M)
        nrow(A[[i]] <- unique(arrangements::permutations(Mi, nitem = nmax, layout = "row")))

      nmax2 <- nmax2 %/% nA
    }
  }
  
  if (np == 1L) {
    combP <- P[[1]]
    combA <- A[[1]]
  }
  else {
    combP <- expand_gr(P, nmax = nmax)
    # combA <- expand_gr(A, nmax = max(nmax %/% nrow(combP), 1L))
    combA <- expand_gr(A, nmax = nmax)
  }
  
  attr(combP, "mods") <- combA

  combP
}


#' Makes the sets of MS2 labels (with permutations) at an \code{aa_masses}.
#'
#' For \code{Anywhere} variable modifications (\code{amods}) across all
#' residues.
#'
#' The universe of labels. It loops through \code{aa_masses_all}. The indexes of
#' lists are in one-to-one correspondence to \code{aa_masses_all}.
#'
#' By the design of \code{aa_masses}, the \code{amods} in an \code{aa_masses}
#' are all realized. Therefore, each list in the resulted labels should contain
#' at least one of the \code{amods} residues from the \code{aa_masses}. For
#' example, if \code{amods} contain M, N and S, each list in the result should
#' contains at least one of the residues.
#'
#' @param vec A named vector of labels. Site in name, modification in value.
#'
#' @examples
#' \donttest{
#' library(mzion)
#' 
#' ## with a bare vector
#' # One-to-one correspondence between Names and Sites
#' vec <- c(M = "Oxidation (M)", N = "Deamidated (N)")
#' attr(vec, "ps")   <- c(M = 3L, N = 2L)
#' attr(vec, "labs") <- c(`Oxidation (M)` = 3L, `Deamidated (N)` = 2L)
#'
#' ans <- mzion:::make_ms2vmods(vec)
#'
#' # Multiple Names to the same Site (S)
#' vec <- c(M = "Oxidation (M)",
#'          S = "Carbamidomethyl (S)",
#'          S = "Phospho (S)")
#' attr(vec, "ps") <- c(M = 2L, S = 3L)
#' attr(vec, "labs") <- c(`Oxidation (M)` = 2L,
#'                        `Carbamidomethyl (S)` = 2L,
#'                        `Phospho (S)` = 1L)
#'
#' ans <- mzion:::make_ms2vmods(vec)
#'
#' # Another one-to-multiple
#' vec <- c(M = "Oxidation (M)", M = "Carbamyl (M)",
#'          S = "Carbamidomethyl (S)", S = "Phospho (S)")
#' attr(vec, "ps") <- c(M = 2L, S = 2L)
#' attr(vec, "labs") <- c(`Oxidation (M)` = 1L,
#'                        `Carbamyl (M)` = 1L,
#'                        `Carbamidomethyl (S)` = 1L,
#'                        `Phospho (S)` = 1L)
#'
#' ans <- mzion:::make_ms2vmods(vec)
#'
#' ## Simple
#' fixedmods <- c("TMT6plex (N-term)", "TMT6plex (K)",
#'                "Carbamidomethyl (C)")
#'
#' varmods = c("Acetyl (Protein N-term)", "Oxidation (M)",
#'             "Deamidated (N)",
#'             "Gln->pyro-Glu (N-term = Q)")
#'
#' aa_masses_all <- calc_aamasses(fixedmods = fixedmods,
#'                                varmods = varmods,
#'                                maxn_vmods_setscombi = 64,
#'                                out_path = NULL)
#'
#' maxn_vmods_per_pep <- 5L
#' maxn_sites_per_vmod <- 3L
#'
#' ms1vmods_all <- lapply(aa_masses_all, mzion:::make_ms1vmod_i,
#'                        maxn_vmods_per_pep = maxn_vmods_per_pep,
#'                        maxn_sites_per_vmod = maxn_sites_per_vmod)
#'
#' stopifnot(length(ms1vmods_all[[1]]) == 0L,
#'           length(ms1vmods_all[[2]]) == 0L,
#'           length(ms1vmods_all[[3]]) == 0L)
#'
#' # M, N (up to 3 M's or N's and 5 in total)
#' len_ps <- lapply(ms1vmods_all[[12]], function (x) attr(x, "ps"))
#'
#' # M (up to 3 M's)
#' len_ps <- lapply(ms1vmods_all[[4]], function (x) attr(x, "ps"))
#'
#' x <- ms1vmods_all[[12]] # list of 8
#' # x <- ms1vmods_all[[1]] # empty list
#'
#' ans <- lapply(x, mzion:::make_ms2vmods) # list of 8 matrices
#'
#'
#' ## More complex
#' fixedmods <- c("TMT6plex (N-term)", "TMT6plex (K)")
#'
#' varmods <- c("Acetyl (Protein N-term)", "Deamidated (N)",
#'              "Oxidation (M)", "Carbamidomethyl (M)", "Carbamyl (M)",
#'              "Carbamidomethyl (S)", "Phospho (S)")
#'
#' aa_masses_all <- calc_aamasses(fixedmods = fixedmods,
#'                                varmods = varmods,
#'                                maxn_vmods_setscombi = 64,
#'                                out_path = NULL)
#'
#' maxn_vmods_per_pep <- 5L
#' maxn_sites_per_vmod <- 3L
#'
#' ms1vmods_all <- lapply(aa_masses_all, mzion:::make_ms1vmod_i,
#'                        maxn_vmods_per_pep = maxn_vmods_per_pep,
#'                        maxn_sites_per_vmod = maxn_sites_per_vmod)
#'
#' # No duplication within each aa_masses
#' any_dups <- lapply(ms1vmods_all, function (x) anyDuplicated(x))
#'
#' stopifnot(all(unlist(any_dups) == 0L))
#'
#' # Can have identical sets of labels at different aa_masses
#' identical(ms1vmods_all[[3]], ms1vmods_all[[9]])
#'
#' attr(aa_masses_all[[3]], "tmod")
#' attr(aa_masses_all[[9]], "tmod")
#'
#' x <- ms1vmods_all[[64]] # list of 10 vectors
#'
#' # [[1]]
#' #  M                     S                     S
#' # "Carbamyl (M)"  "Carbamidomethyl (S)"  "Phospho (S)"
#' # [[2]]
#' # M                     M                     S               S
#' # "Carbamyl (M)"  "Carbamyl (M)"  "Carbamidomethyl (S)"  "Phospho (S)"
#' # [[3]]
#' # ...
#'
#' ans <- lapply(x, mzion:::make_ms2vmods) # list of 10 matrices
#'
#' ans_all <- lapply(ms1vmods_all, function (x) lapply(x, mzion:::make_ms2vmods))
#' }
make_ms2vmods <- function (vec = NULL) 
{
  n_nms  <- length(unique(names(vec)))
  n_vals <- length(unique(vec))
  oks <- n_nms == n_vals

  ans <- vec
  attr(ans, "ps") <- ps <- attr(vec, "ps")
  attr(ans, "labs") <- attr(vec, "labs")
  attr(ans, "single") <- oks

  rs <- find_ms2resids(ans, vec)
  attr(rs, "single") <- attr(rs, "ps") <- attr(rs, "labs") <- NULL
  attr(ans, "resids") <- rs

  ss <- names(ps)
  inds <- lapply(ss, function (p) which(rs == p))
  inds <- lapply(inds, unname)
  names(inds) <- names(ps)
  attr(ans, "inds") <- inds

  ans
}


#' Helper of \link{make_ms2vmods}.
#' 
#' Makes the corresponding residue matrix from \link{make_ms2vmods}.
#' 
#' @param M A modification-name matrix from \link{make_ms2vmods}.
#' @param vec A vector of labels.
find_ms2resids <- function (M, vec) 
{
  vecinv <- names(vec)
  names(vecinv) <- vec
  vecinv <- vecinv[unique(names(vecinv))]
  
  for (i in seq_along(M))
    M[[i]] <- vecinv[M[[i]]]

  invisible(M)
}




##
# labels: n
# positions: p
# 
# n <- c("A", "A", "B"); n1 <- 2; n2 <- 1
# p <- c(1, 3, 5, 9)
# n <- c("Carbamidomethyl (M)",  "Carbamidomethyl (M)", "Oxidation (M)")
# p <- c(1, 3, 5, 9)
# 
# choose(p, n1 + n2) * choose(n1 + n2, n2)
# = choose(4, 3) * choose(3, 2)
# 
# n <- c("A", "A", "B", "B", "C"); n1 <- 2; n2 <- 2; n3 = 1
# p <- c(1, 3, 5, 7, 8, 9)
# 
# p!/(n1!n2!n3!)/(p-n1-n2-n3)!
# = choose(p, n1+n2+n3) * (n1+n2+n3)!/(n1!n2!n3!)
# = choose(p, n1+n2+n3) * choose(n1+n2+n3, n1+n2) * choose(n1+n2, n1)
##


#' A (faster alternative) to \link[gtools]{permutations} with duplicated labels.
#'
#' @param labs A vector of labels.
#'
#' @examples
#' \dontrun{
#' library(gtools)
#' library(mzion)
#' library(dplyr)
#' 
#' # four positions for four balls in three colors
#' labs  <- c("A", "A", "B", "C")
#' len   <- length(labs)
#' g <- unique(permutations(len, len, labs, set = FALSE, repeats.allowed = FALSE))
#' m <- mzion:::find_perm_sets(labs)
#' 
#' cns <- paste0("p", 1:len)
#' g <- data.frame(g)
#' m <- data.frame(m)
#' colnames(m) <- colnames(g) <- cns
#' 
#' stopifnot(identical(dplyr::arrange_all(g), dplyr::arrange_all(m)))
#' 
#' # example-2
#' labs <- c("A", "A", "A", "B", "B", "C")
#' m <- mzion:::find_perm_sets(labs)
#'
#' # Compares to gtools::permutations
#' len <- length(labs)
#' g <- unique(permutations(len, len, labs, set = FALSE))
#'
#' cns <- paste0("p", 1:len)
#' g <- data.frame(g)
#' m <- data.frame(m)
#' colnames(m) <- colnames(g) <- cns
#' 
#' stopifnot(identical(dplyr::arrange_all(g), dplyr::arrange_all(m)))
#'
#' # Compares to the theoretical number of entries
#' len_labs <- length(labs)
#' ns <- mzion:::count_elements(labs)
#' theo_cts <- factorial(len_labs)/prod(factorial(ns))
#' stopifnot(nrow(m) == theo_cts)
#'
#' ## Others
#' x <- mzion:::find_perm_sets(rep("A", 3))
#' }
find_perm_sets <- function (labs = c("A", "A", "A", "B", "B", "C")) 
{
  grps <- split_vec(labs)
  lens <- count_elements(labs)
  
  ## base perm with unique labels
  ulabs <- names(lens)
  M  <- matrix(ulabs[1])
  
  if (length(ulabs) > 1L) {
    for (ul in ulabs[-1]) 
      M <- add_one_permlab(M, ul)
  }
  
  ## extended perm with duplicated labels
  dlens <- lens - 1L
  dlens <- dlens[dlens > 0L]
  lend  <- length(dlens)

  if (lend) {
    dlabs <- names(dlens)
    
    for (i in 1:lend) {
      ct <- dlens[[i]]
      dl <- dlabs[i]
      
      for (j in seq_len(ct)) 
        M <- add_one_label(M, dl)
    }
  }

  M
}


#' Helper in making permuation table.
#' 
#' @param M A permutation matrix with non-redundant labels.
#' @param x A new label not in M for permutation.
#' 
#' @examples
#' \dontrun{
#' library(mzion)
#' library(gtools)
#' library(dplyr)
#' 
#' unilabs <- c("A", "B", "C")
#' nu <- length(unilabs)
#' 
#' G <- gtools::permutations(nu, nu, unilabs)
#' 
#' M  <- matrix(unilabs[1])
#' for (ulab in unilabs[-1]) M <- mzion:::add_one_permlab(M, ulab)
#' 
#' cns <- paste0("p", 1:nu)
#' M <- data.frame(M)
#' G <- data.frame(G)
#' colnames(G) <- colnames(M) <- cns
#' 
#' stopifnot(identical(dplyr::arrange_all(G), dplyr::arrange_all(M)))
#' }
add_one_permlab <- function (M, x) 
{
  ncol  <- ncol(M)
  nrow  <- nrow(M)
  ncol2 <- ncol + 1L
  nrow2 <- ncol2 * nrow
  
  ins_permlab(M, x, nrow, ncol, nrow2, ncol2, rm_dup = FALSE)
}


#' Helper of \link{find_perm_sets}.
#' 
#' Adds one more labels to a permutation table.
#' 
#' @param M A permutation table with unique sets by rows.
#' @param x A duplicated label that can be found in M.
add_one_label <- function (M, x) 
{
  ncol  <- ncol(M)
  nrow  <- nrow(M)
  ncol2 <- ncol + 1L
  nrow2 <- ncol * nrow
  
  ins_permlab(M, x, nrow, ncol, nrow2, ncol2, rm_dup = TRUE)
}


#' Helper of \code{add_one_label} and \code{add_one_permlab}.
#' 
#' No duplicated labels for base permutation and \code{rm_dup = FALSE}. 
#' 
#' @inheritParams add_one_label
#' @param nrow The number of rows of M.
#' @param ncol The number of columns of M.
#' @param nrow2 The number of rows of the output.
#' @param ncol2 The number of columns of the output.
#' @param rm_dup Logical; remove duplicated rows or not. 
ins_permlab <- function (M, x, nrow, ncol, nrow2, ncol2, rm_dup = FALSE)
{
  out <- matrix(nrow = nrow2, ncol = ncol2)
  
  k <- 1L
  
  for (i in 1:nrow) {
    mi <- M[i, ]
    
    if (ncol > 1L) {
      for (j in 1:(ncol-1L)) {
        out[k, ] <- c(mi[1:j], x, mi[(j+1):ncol])
        k <- k + 1L
      }
    }
    
    out[k, ] <- c(mi, x)
    k <- k + 1L
  }
  
  if (rm_dup)
    out <- out[!duplicated.matrix(out), , drop = FALSE]
  else
    out[k:nrow2, ] <- cbind(x, M)
  
  out
}


#' From \link[utils]{combn}.
#' 
#' To avoid the conversion, e.g., \code{3} to \code{1:3}.
#' 
#' @param x Integer; the vector source for combinations.
#' @param m Integer; the number of elements to choose.
sim_combn <- function (x, m) 
{
  if (length(m) > 1L) 
    stop("length(m) > 1", domain = NA)
  
  if (m < 0L) 
    stop("m < 0", domain = NA)
  
  m <- as.integer(m)
  n <- length(x)
  
  if (n < m) 
    stop("n < m", domain = NA)
  
  x0 <- x
  e <- 0
  h <- m
  a <- seq_len(m)
  
  len.r <- length(r <- x[a])
  count <- as.integer(choose(n, m))
  
  out <- vector("list", count)
  out[[1L]] <- r
  
  if (m > 0) {
    i <- 2L
    nmmp1 <- n - m + 1L
    
    while (a[1L] != nmmp1) {
      if (e < n - h) {
        h <- 1L
        e <- a[m]
        j <- 1L
      } else {
        e <- a[m - h]
        h <- h + 1L
        j <- 1L:h
      }
      
      a[m - h + j] <- e + j
      r <- x[a]
      out[[i]] <- r
      
      i <- i + 1L
    }
  }
  
  out
}


#' A wrapper of \link[stats]{dist} with the handling of partial argument
#' matches.
#' 
#' Not yet used.
#' 
#' @param ... Arguments for \link[stats]{dist}
my_dist <- function (...) 
{
  dots <- as.list(substitute(...()))
  
  dummies <- c("p")
  
  msgs <- c(
    "`p` in `dist()` not used."
  )
  
  # stopifnot(length(dummies) == length(msgs))
  
  purrr::walk2(dummies, msgs, ~ {
    if (.x %in% names(dots)) {
      warning(.y, call. = FALSE)
      dots[[.x]] <<- NULL
    } 
  })
  
  do.call(stats::dist, dots)
}


#' Cosine similarity.
#' 
#' Not yet used.
#' 
#' @param M An input Matrix.
#' 
#' Vectors are in rows: mtcars[1, ].
#' 
#' @examples 
#' library(mzion)
#' 
#' sim <- mzion:::cos_sim(as.matrix(mtcars[1:3, ]))
#' 
#' # distances (against normalized vectors)
#' as.dist(1 - sim)
cos_sim <- function (M) 
{
  if (!is.matrix(M))
    stop("The input data is not a matrix.")

  L <- sqrt(rowSums(M * M)) # vector lengths; no `mean` subtraction
  Mn <- M / L # normalized M 
  Mn %*% t(Mn) # dot products; vectors in the rows of Mn
}


#' Match MS at no enzymatic specificity.
#' 
#' @param ... Variable arguments.
#' @export
matchMS_NES <- function (...)
{
  args <- as.list(substitute(...()))
  nms  <- names(args)
  oks  <- nms != ""
  args <- args[oks]
  nms  <- nms[oks]
  
  if ("max_miss" %in% nms)
    warning("Argument \"max_miss\" has no effect at no enzymatic specificity.")
  
  if ("enzyme" %in% nms && tolower(args[["enzyme"]]) != "noenzyme") {
    warning("Changed setting to `enzyme = Noenzyme`.")
    args["enzyme"] <- NULL
  }
  
  do.call(matchMS, c(list(enzyme = "noenzyme", 
                          # bypass old matchMS_noenzyme
                          bypass_noenzyme = TRUE, 
                          # call add_protacc at enzyme = "noenzyme"
                          direct_prot_acc = TRUE), 
                     args))
}


#' Re-match MS at no enzymatic specificity.
#' 
#' Bypasses ion matches.
#' 
#' @param ... Variable arguments.
#' @export
rematchMS_NES <- function (...)
{
  args <- as.list(substitute(...()))
  nms  <- names(args)
  oks  <- nms != ""
  args <- args[oks]
  nms  <- nms[oks]
  
  if ("max_miss" %in% nms)
    warning("Argument \"max_miss\" has no effect at no enzymatic specificity.")
  
  if ("enzyme" %in% nms && tolower(args[["enzyme"]]) != "noenzyme") {
    warning("Changed setting to `enzyme = Noenzyme`.")
    args["enzyme"] <- NULL
  }
  
  do.call(matchMS, c(list(enzyme = "noenzyme", 
                          bypass_noenzyme = TRUE, 
                          bypass_pepmasses = TRUE,
                          bypass_bin_ms1 = TRUE,
                          bypass_mgf = TRUE,
                          bypass_ms2match = TRUE), 
                     args))
}



.onAttach <- function(libname, pkgname) {
  packageStartupMessage("Welcome to Mzion.\n\n",
                        "============================================================================================\n",
                        # "NEW features (v1.3.3.4):\n",
                        # "[x] MS1, MS2 de-isotoping and chimeric peptide searches.\n\n",
                        "[x] For documents, enter \"?matchMS\".\n", 

                        # "Notes:\n",
                        "[x] Suggested configuration for large datasets: 32GB RAM and 8-cores.\n",
                        # "[x] May need to remove previously cached results (or use a new .path_cache and .path_fasta).\n",
                        # "    (OOps an accidental relocation of amino-acid lookups to a parent directory) \n",
                        # "remotes::install_version(\"RSQLite\", version = \"2.2.5\")\n",
                        "============================================================================================\n")
}
